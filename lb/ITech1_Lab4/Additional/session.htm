<center><h1>СЕССИИ - обучение и /правильное/ использование</h1></center>
<p align=right>Дмитрий Бородин<br>
<a href=mailto:dima@php.spb.ru>dima@php.spb.ru</a></p>

Одна из самых важных веб-технологий - это сессии.
Если вы до их не используете, то многое теряете.
Давайте разберемся, что это такое. <br><br>

Будем считать, что ваш 
сервер настроен по умолчанию (файл php.ini) и в файлах 
httpd.conf или .htaccess не внесали никаких для утановки локальных 
php-настроек (локальных - для каталога и его подкаталогов).
<h2>Когда нам нужны сессии?</h2>
Ответить на этот вопрос проще ответом на другой вопрос - 
<font color=red><b>что мы хотим для удобной работы в PHP?</b></font>
Сейчас мы много чего придумаем (для облегчения программирования), 
потом захотим, чтобы оно само работало,
а еще дальше окажется, что так и работает PHP <nobr>;-)</nobr>
Как только вы поймете, чего вам так не хватало, вы
поймете идею сессий и технические подробности.


<br><br><hr size=1 noshade><br>



<h2>Чего мы хотим для удобной работы в PHP?</h2>
Представьте программу тестирования людей. Есть куча вопросов и куча людей.
Надо постараться, чтобы люди:
<ul>
<li>получали вопросы в случайном порядке (чтобы у соседа по классу
вопросы появлялись в другом порядке)
<li>не могли отвечать на вопросы в произвольном порядке (меняя какие-то
параметры в URL) или еще хуже - подделать кол-во 
набранных балов или узнать правильный ответ
<li>не могли бросить тест и начать его заного (можно лишь дорешать до 
конца)
<li>могли вернуться и продолжить тестирование,
при разрыве связи с сервером (модем повесил трубку) 
<li>не обязаны были бы регистрироваться
<li>могли бы работать все через один прокси сервер и с отключенными куками
<li>и т.д... еще можно много полезного придумать
</ul>
В такой задаче надо перед началом проходжения теста
взять все номера вопросов, перемешать между собой 
и сохранить в область данных посетителя массив номеров.
Затем поместить в туже область флаг (flag=тестирование), чтобы
человек не мог перейти на начало теста (начать его заного), 
не прорешав тест до конца. Это сделать очень просто. 
Предположим, что index.php - это главная страница для старта, 
vopros.php - страница, где выдадут очередной вопрос. Если 
человек с флагом "тестирование" попытается перейти на index.php,
то ему надо написать - "Вы не закончили тестирование".
Если человек обиделся, вырубил комп и ушел спать, через некоторый тайм аут
(к примеру, через 3 дня), надо записать в историю прохождения тестов:
"брошенный тест". Это похоже на игру через Интернет - если человек 
проигрывает, но не хочет признать это, он может как бы потерять связь
с игровым сервером (якобы модем повесил трубку).
<br><br>

Как это все реализовать? Очень просто. Предположим, что у каждого посетителя
есть некая область памяти (у каждого - своя), в которую
наша программа может что-то записывать и читать. 
Эта область памяти должна соответствовать всем требованиям, которые 
мы выдвинули выше. Наша программа не должна заботиться о ней. 
И все это можно сделать. Эта абстрактная область памяти имеет 
идеальный интерфейс. Вернее, не имеет его. 
К примеру, если бы данная область хранилась в файлах, нам надо было бы 
файлы читать и анализировать. Для записи - надо было бы записывать туда 
данные в каком-то формате. При хранении в базе данных - нам
пришлось в начале программы выполнять SQL-запрос, чтобы 
извлечь все данные и в самом конце выполнения программы записать их 
обратно. Все это (затраты на чтение файла или базы данных) - называется 
интерфейс.  Как я сказал, наше общение с базой данных вообще не имеет 
интерфейса. Это значит, что любые переменные, которые мы пожелаем,
будут с некоторого момента считаться областью памяти посетителя.
При каждом запуске программы, от разных посетителей, она будет 
иметь доступ через какие-то переменные только к персональным настройкам.
Чтобы сохранить (закрепить) у пользователя какую-либо информацию 
в переменной, надо просто записать в эту переменную что-нибудь. К примеру,
в программе авторизации пользователей, говорим "хочу, чтобы $auth стала
частью областью памяти". Если человек вводит свой логин и пароль
(их мы проверяем как-то, например по базе данных), то мы записываем в 
переменную $auth единичку, затем в аналогичную переменную $login его логин.
Пароль записывать не надо, т.к. наличие единицы в переменной $auth 
уже будет означать, что человек прошел авторизацию. На всякий случай будем
хранить еще и логин. Пароль хранить совершенно не нужно,
т.к. нет случая его применить... кроме как вывести на экран (но это уже 
будет глупая затея, а не реальная программа). Таким образом, 
мы один раз устанавливаем $auth, а дальше в любом месте может проверить
авторизированность пользователя <tt><nobr><b>if ($auth)</b></nobr></tt>
или <tt><nobr><b>if ($auth==1)</b></nobr></tt>. Так как переменная
$auth будет частью области памяти, то можно не бояться, что какой-нибудь
злой хакер запустит нашу программу как 
<tt><nobr><b>programm.php?auth=1</b></nobr></tt> и окажется
авторизированным. 

<br><br><hr size=1 noshade><br>

<h2>Подведем итог нашей мечте о комфортной работе</h2>

Все, о чем тут было сказано, как не трудно догадаться
по названию, называется сессия. Принцим действия следующий (забудьте 
пока о том, как это все работает):
<ul>
<li>чтобы сохранить о пользователе что-то, выберем для этого переменную
и сообщим php-процессору о нашем желании с помощью 
<tt><nobr><b>session_register("auth")</b></nobr></tt> и 
<tt><nobr><b>session_register("login")</b></nobr></tt>.
Это называется регистрация переменной. Эти строчки пишут в начале программы,
чтобы PHP-код, идущий ниже в программе, мог обращаться к $auth и $login.
<br><br>
<li>если мы что либо запишем в $auth и/или $login, то эта переменная
будет сохранена в персональную область данных посетителя.
Это значит, что при следующем вызове той же программы (или из того же 
каталога или подкаталогов), перед началом работы php-скрипта,
php-процессор узнает пользователя и загрузит сохраненные для него 
переменные (если когда-либо в них что-то записывалось).
<br><br>
<li>и самое главное - вся информация в сессиях не может быть подделана 
пользователем. Т.е. наличие единицы в какой-то переменной сессии означает,
что туда ее могла записать программа, а не кто-либо.
</ul>

Еще раз скажем "итак" и подведем итог. Мы хотим, чтобы PHP-процессор 
умел распознавать пользователей и предоставлял
в свободное распоряжение программе область памяти
(в виде переменной $auth, $login или $любое_название),
которую невозможно никак подделать. Всех новых пользователей
PHP-процессор тоже должен распознавать и присваивать им новую область
памяти. Единственное, что сможет злой пользователь - прикинуться
новым пользователем или вообще бросить наш сайт.


<br><br><hr size=1 noshade><br>


<h2>Как устроены сессии: <font color=blue><b>идентификатор посетителя</b></font></h2>

Выше был описан принцим сессий. Их придумали для того, что
PHP лишен такой нормального свойства программы - хранить что-либо 
о пользователе. И виноват тут не PHP. Если взять что-то другое - 
средневековый язык Perl или язык ASP (для тех, кто решил тормознуть 
P4 1700Mhz dual), они будут работать по тем же самым принципам.
И будут лишены того же - способностью что-то созранить о пользователе.
Это происходит из-за убогости Web'a. Но задача программиста не придумывать
что-то, а писать программы, работающие в любой среде.
<br><br>
Вернемся к устройству сессий.
С помощью чего PHP-процессор различает пользователей? С помощью идентификатора.
Он является 128 битным числом. Если человек пришел на сайт впервые 
и PHP-процессор это видет, то данному посетителю присваивается
какое-то случайное число, не присвоенное еще никому. В дальнейшем,
при повторном заходе, посетитель будет ассоциирован с его личным числом 
(идентификатором), из-за чего программе будет предоставлена 
персональная область памяти.
<br><br>
Запомните главное - если суметь передать идентификатор 
от одной страницы (PHP-скрипта) до другой (до следующего вызова с нашего сайта),
то мы сможем различать всех посетителей. Больше, от не удобного 
для программиста Web'а, ничего не требуется. Так как мы выбрали
очень больше число, то не существует ни малейшего опасения, что злой 
хакер подделает число, тем самым воспользуется чужой 
областью данных. Запомните еще одну главную мысль - подделать сессию 
или идентификатор нельзя. Число из 128 бит (это 2 в 128 степени) 
в десятичном представлениим имеет 38 нулей. Пердположим, 
на вашем сайте будет 10 000 посетителей. Тогда у хакера
шансы несколько возрастают до 2 в степени 114. Но это по прежнему 
нереальная вероятность, что либо подделать. Одна из очевидных
причин следующая.
Чтобы подобрать номер сессии, нужно сделать запрос к вашему веб-серверу.
Пусть каждый запрос занимает 1024 байта. Через миллиард
обращений к вашему сайту, что составит 1000 ГБ трафика, явно что-то случиться:
<ul>
<li>ваш сайт отключат из-за дикого трафика или у вас не хватит денег на оплату
такого большого трафика (по 36 баксов за ГБ - $36000).
Дешевле нанять группу товарищей для взлома сервера или 
группу товарищей в черной одежде для простого выноса сервера :-)
<li>ваш канал или пропусканая способность провайдера слишком слабая, 
чтобы в разумные сроки перебрать все номера
<li>ваш сервер не сможет хоть как-то быстро работать, имея гигантское 
количество пустых файлов, из-за создания фиктивных сессий
<li>ваш сервер переполниться лог файлами и файлами фиктивных сессий,
перестанет работать
<li>всех хакеров посадят за целенаправленную и длительную атаку
</ul>

Хоть сессию подделать нельзя, но существуют следующие непредвиденные случаи:

<ul>
<li>на компьютере посетителя побывал злой хакер, который 
поставил злую программу, ворующую пароли от интернета (статья N##)
и номера сессий
<li>между компьютером посетителя и сервером сидит злой хакер и 
видит все, что передается.
Конечно, есть защищенный (зашифрованный) протокол SSL, но это увы везде
не внедрить
<li>к компьютеру нашего посетителя подошел злой сосед 
и стащил этот номер сессии
</ul>
Как видите, все основано на том, что кто-то что-то у кого-то стащит. 
Но это уже не проблема программиста. Представьте, вы написали идеальную
программу, в которой нет ошибок и дыр для взлома, а через день
злой хакер взломал сервер и скопировал / изменил / удалил все, что посчитал
нужным, даже не запуская программу. Еще раз заметим, хоть вариант 
стащить сессию есть, только это уже проблемы другого рода.
<br><br>
Выглядит этот несчастный идентификатор обычно так:
"<b>7f4cbf53fbcd4717792447f32da7dba8</b>", или так: 
"<b>ac4f4a45bdc893434c95dcaffb1c1811</b>".
Это текстовая запись 128-битного числа (занимает 32 байта).

<ul><i>

По умолчанию, PHP сам заботиться о том, чтобы обнаружить идентификатор 
или выдать новый новому посетителю.
</i></ul>


<br><hr size=1 noshade><br>


<h2>Как устроены сессии: <font color=blue><b>где хранится информация</b></font></h2>
 
Выше мы установили, что для нашей мечты нужно постараться 
передавать идентификатор от вызова к вызову (как именно передают - 
через главу). Имея идентификтор (число) легко загрузить каждому 
пользователю его персональные данные.
Есть два популярных способа хранинения - база данных и файлы. 
Еще можно хранить сессии в памяти сервера (ОЗУ), но при выключеннии сервера
будут потеряны сессии.
Обычно сессии хранят в файлах, чтобы снизить нагрузку на базу данных.
В огромном числе задач сессии позволяют полностью отказаться от базы данных.
Или использовать ее миниматьльно: в базе данных только список логин/паролей,
в сессиях (на файлах) вся рабочая информация.
<ul>
<i>
По умолчанию, PHP хранит все в файлах (в своем формате) и сам достает из 
них сохраненные данные. После работы каждого скипта PHP сам все записывает 
обратно в личный файл из переемнных, помеченных для хранения в сессии.
</i>
</ul>


<br><hr size=1 noshade><br>

<h2>Как устроены сессии: <font color=blue><b>сериализация</b></font></h2>

Если вы посмотрите на файл сессии (где он находиться - 
<a href=#path>узнаете позже</a>),
то увиде нечто такое:

<pre>
myarray|a:4524:{s:7324:"startup";i:98;s:4:"type";i:1;s:2:"ip";s:13:"1572342";s
:2:"tt";i:2;s:3:"b";i:12312;s:621:"max";i:2380;s:6:"min";i:-8334;s:10:"realmax
";i:1213126;s:10:"realmin";i:0;s:1:"kol";i:1;s:1:"n";i:15;s:9:"timestart";i:98
8387008;s:7:"timeend";i:9883218;s:4:"list";a:16:{i:0;s:7:"1002001";i:1;s:7:"10
02007";i:2;s:7:"1002010"; ............ и т.д.
</pre>

Представьте, у нас есть огромный массив сложной структуры, к примеру, $myarray. 
Вам будет интересно узнать, что любую перменную (сложный массив)
с любыми символами (произвольные бинарные данные) очень легко 
запаковать в строку из букв и цифр. Для чего переводить массив в строку?
Строку (просто переменная), да еще и текстовую, легко куда-нибудь
записать. Например, на листочек бумаги. Или в базу данных... Или в 
файл сессии. Позже, можно распаковать такую строку в оригинальную переменную
и получить то, что было до упаковки. Данный метод 
(называется - сериализация) упаковки/распокавки переменных или объектов 
применяется не только в сессиях. Просто PHP, чтобы сохранить все данные
пользователя, запаковывает их и кладет как строку в файл сессии.
<br><br>
<b>$myStr=serialize($myVar)</b> - 
запаковать огромный массив или любую произвольную переменную $myVar в 
текстовую переменную $myStr.
<br><br>
<b>$myVar=serialize($myStr)</b> - 
распаковать (восстановить) данные из ранее запакованной переменной,
хранящейся в $myStr, и записать результат распаковки (оригинальную переменную)
в $myVar
<ul>
<i>
По умолчанию, программиста не должно волновать, как именно 
PHP хранит ваши переменные <nobr>:-)</nobr>
Вы всегда <a href=#handler>можете перейти</a> от метода хранения сессий в файлах,
к хранению в базе данных или любых других местах,
просто дописав нужный модуль по сохранению/извлечению сессий.
Менять что-либо в программе не придеться!
</i>
</ul>



<br><hr size=1 noshade><br>


<h2>Как устроены сессии: <font color=blue><b>передача идентификатора</b></font></h2>

Двумя главами выше вы установили, что для нашей мечты нужно передавать
идентификатор от отного вызова программы к другому. 
Давайте подумаем, какими способами можно что либо передать.
В нашем случае мы установили, что надо передавать идентификатор сессии - 
строку из букв и цифр длиной 32 символа. Отвлекитись от всего
и подумайте, как можно передавать какую-то строку от скрипта к скрипту.

<h3><br>Способ 1: <font color=blue><b>Cookies</b></font></h3>
Это самый популярныи и работающий по умолчанию способ передачи идентификатора.
Можно один раз поместить в куку переменную и все остальные скрипты 
будут ее получать.
Если у пользователя куки включены, PHP сам поместит туда
идентификатор и потом сам его от туда достанет.
О том, как PHP узнает о включенности кук - в следующей главе. 
В этом способе в куках создается переменная с изветным именем
(по-умолчанию: PHPSESSID) и значением идентификатора 
(например: <tt><nobr><b>ac4f4a45bdc893434c95dcaffb1c1811</b></nobr></tt>).
<br><br>

<u><b>Хорошо</b></u>: куки (cookies) - это самый простой способ закрепить за посетителем какие-либо
данные. Трудно стереть куку или изменить.<br>
<u><b>Плохо</b></u>: куки могут быть выключены. Зайдите на Спайлог да узнайте, каков %
посетителей не смогут работать с вашим сайтом.



<h3><br>Способ 2: <font color=blue><b>параметры</b></font> - 
<small>http://php.spb.ru/test.php?PHPSESSID=ac4f4a45bdc893434c95dcaffb1c1811</small></h3>

Если вы будете дописывать все ваши ссылки подобным образом,
то все ваши последующие скрипты получат идентификатор.
PHP использует и данный метод по умолчанию (совмещая с куками, если те выключены).
Т.е. PHP _сам_ применит либо куки, либо способ 2.
PHP сам после работы вашей программы проанализирует ее страницу
для браузера и позаменяет все ссылки так, чтобы
дописать переменную PHPSESSID.
<br><br>
<u><b>Хорошо</b></u>: 100% надежный способ. Легко передавать во всех ссылках номер сессии
(это нагрузка, но она очень простая, поэтому - хорошо).<br>
<u><b>Плохо</b></u>: любой чайник может переделать номер сессии
или удалить ее. Т.к. в принципе нет способа надежной привязки посетителя
к номеру - беда небольшая. Злой сосед по компьютеру может украсть
номер из URL (32 символа).  Но если сделать URL подлиннее 
(test.php?_________....______&PHPSESSID=12345678), то сосед ничего не увидет.
Строка "Адрес" в браузере не бесконечная <nobr>:-))</nobr>



<h3><br>Способ 3: <font color=blue><b>PathInfo</b></font> -
<small>http://php.spb.ru/test.php/ac4f4a45bdc893434c95dcaffb1c1811</small>
</h3>

Это основано на понимании Апачем того, где из этого URL путь к скрипту, а
где параметры. Т.е. Апач распознает данный вызов, как обращение к 
файлу <tt><nobr><b>test.php</b></nobr></tt>
 и передаст любую произвольную строку в переменной 
<tt><nobr><b>$pathinfo=getenv("PATH_INFO")</b></nobr></tt>
 - так ее можно взять и получить от туда 
идентификатор запроса. Соответственно, чтобы 
передать управление в другой скрипт, надо подобным образом 
составить URL (GET-запрос) или передать форму GET или POST запросом.
<br><br>

<b><u>Хорошо</u></b>: ничего хорошего. <br>
<b><u>Плохо</u></b>: трудно ссылаться на локальные скрипты и картинки. Чтобы все 
работало, придется в программах и тегах картинок использовать
абсолютный путь на сервере.


<h3><br>Способ 4: <font color=blue><b>rewrite, виртуальный каталог</b></font> - 
<small>http://php.spb.ru/ac4f4a45bdc893434c95dcaffb1c1811/test.php</small>
</h3>

С помощью стандартного модуля rewrite можно огранизовать подобного 
рода виртуальный каталог. Если написать произвольный путь - 
Апач возьмет скрипт <tt><nobr><b>test.php</b></nobr></tt>
 из фиксированного каталога. В скрипте придеться
проанализировать переменную 
<tt><nobr><b>$url=getenv("REQUEST_URI");</b></nobr></tt>
и взять из нее идентификатор. Далее по нему PHP восстановит нужную сессию.
<br><br>

<b><u>Хорошо</u></b>: все хорошо. Легко работать, в отличии от способа 3. Не нужно передать
идентификатор - сам собой передастся. <br>
<b><u>Плохо</u></b>: ничего плохого. Немного надо написать и немного настроить rewrite.
Чтобы позволить кешировать картинки, путь к ним надо писать
обсолютный.


<h3><br>Способ 5: <font color=blue><b>DNS, виртуальный сервер</b></font> -
<small>http://ac4f4a45bdc893434c95dcaffb1c1811.php.spb.ru/test.php</small>
</h3>

Можно настроить DNS так, чтобы по любому подобному пути 
произошло бы обращение к вашему веб-серверу. В самом сервере
с помощью алиаса "*.php.spb.ru" задать, что эти адреса принадлежат 
главному серверу php.spb.ru. Далее по описанной выше схеме 
из переменной <tt><nobr><b>$host=getenv("HTTP_HOST");</b></nobr></tt>
достаем идентификатор и передаем в PHP. После чего тот 
достает нужную сессию.
<br><br>

<b><u>Хорошо</u></b>: все хорошо.  Совсем ничего не надо делать, по сравнению с
виртуальным каталогом.<br>
<b><u>Плохо</u></b>: злой сосед может срисовать номер сессии. И ее уже
не запрятать за правый край строки "Адрес". Но это не страшно, т.к.
ситуация со злым соседом весьма редкая.
Чтобы позволить кешировать картинки, путь к ним надо писать
обсолютный (ссылаясь на главное имя сервера).


<h3><br>Способ 6: <font color=blue><b>фиктивный логин</b></font> -
<small>http://ac4f4a45bdc893434c95dcaffb1c1811@php.spb.ru/test.php</small>
</h3>

Зеркально похож на способ виртуального каталога. В прессе ранее не 
не упоминался :-) Придумался сам собой, пока писал эту стать. 
Хоть и не оригинальная идея, но реальная для использования.
Для тех, кто не в курсе, URL состоят из следующего вида:
<ul>
<li>название протокола (http)
<li>имя пользователя (логин)
<li>пароль
<li>имя сервера 
<li>порт
<li>путь к скрипту, минимум - содержит "/"
<li>якорь на странице (read.html#якорь)
</ul>
Получается - 
<big><font color=blue><b>http<font color=red><b>://</b></font>логин<font color=red><b>:</b></font>пароль<font color=red><b>@</b></font>ИмяСервера<font color=red><b>:</b></font>порт<font color=red><b>/</b></font>путь<font color=red><b>#</b></font>якорь</b></font>
</big>. Если пароль не указывают, получается http://логин@сервер,
где слово логин может быть любым. К примеру, на этом основаны 
регулярно появляющиеся шутки типа 
<u>http://www.microsoft.com@195.63.2.95/doc/windows_must_die.txt</u>,
где пишут разные приколы, подделав дизайн под нужный сайт.
Есть и полезное свойтво - если чайник от незнания напишет в браузере 
адрес dima@mail.ru, то он попадет на главную страницу почтовой системы.
<br><br>Еще можно простараться впихать идентификтаор в якорь,
только это не имеет смылса, т.к. способ ничем не отличается
от "способа 2".


<br><br><hr size=1 noshade><br>


<h2>Промежуточный итог, характеристика сессий</h2>

В самом начале мы описали персональную область данных, которой так нехватает 
веб-программисту, чтобы хранить что либо. 
Далее, мы установили, что PHP надо только сообщить названия переменных.
После этого ПХП присвоит всем посетителям идентификаторы (число 128 бит),
которое невозможно подделать, откроет на диске файл,
названный аналогично номеру сессии для хранения информации.
Данные там запаковыны с помощью функции сериализации, т.е.
наипростейшим способом. Чтобы наш сайт успешно работал,
мы должны позаботиться о передаче идентификатора от запроса к запросу.
Делать это можно разными путями. БОльшую часть работы ПХП делает сам.
И так, после вводной части (наша мечта -> реальность с четкими задачами)
посмотрим, что проиход по умолчанию.



<br><br><hr size=1 noshade><br>

<h2>Что проиходит по умолчанию</h2>


Читайте данную главу особенно внимательно, здесь описано поведение 
ПХП по умолчанию и что требуется от программера в особых случаях
(если куки у посетителя отключены, но юзать сессии хочеться).
Поведение ПХП при нестандарных параметрах описано ниже.
<br><br>
Представьте, посетитель обратился к одной из страниц вашего сайта.
ПХП прочел файлы конфигурации.
Интерпретатор ПХП начинает выполнять ПХП-файл. Если он там не встретит 
команду <tt><nobr><b>session_register()</b></nobr></tt> или 
<tt><nobr><b>session_start() </b></nobr></tt>, то никакие сессии 
работать не будут.
Если бы ПХП обнаружил параметр настройки <tt><nobr><b>session.auto_start</b></nobr></tt>
равный <tt><nobr><b>1</b></nobr></tt>, 
то сессии стартовали бы без нашей команды
(по умолчанию данный параметр содержит <tt><nobr><b>0</b></nobr></tt> - выключено).
<br><br>
В нашей программе (мы работаем с сессиями) эти строчки будут одними 
из первых, что обработаются ПХП-процессором. Поэтому можно считать,
что поддержка сессии запуститься при старте скрипта.
<br><br>
<b>Что входит в понятие запуск сессий.</b>
ПХП пытается выяснить, новый это посетитель или нет. Если новый - 
надо выдать ему новое случаное число и создать файл под хранение сесии,
если старый - взять его идентификатор и извлеть из соответствуюего файла
переменные сессии. Возможно, посетитель будет иметь номер несуществующей
сессии. Тогда он приравнивается к новому посетителю.
<br><br>


<a name=getid></a>
<b>Алгоритм извлечения идентификатора.</b>
Из настроек сервера известно, что имя переменной, хранящей идентификатор - 
<tt><nobr><b>PHPSESSID</b></nobr></tt> (можно задать произвольное).

<ol>
<li>Если идентификатор будет найден в куках, то пользователь
считается идентифицированным и использующи куки: 
повторно кука не устанавливается, URL не подвергаются автозамене
(о <a href=#zamena>автозамене</a> чуть ниже).
<li>Если идентификатор найден в URL (GET-запрос) или в POST-запросе
и не найден в куках,
то пользователь считается идентифицированным и не использующем 
куки: кука выставлятся (на всякий случай), URL проходят 
автозамену, чтобы вставить в них идентификатор.
<li>Если идентификатор не найден ни в куках, ни в URL, то пользователь
считается новым, используется ли он куки - не известно, 
происходит выделение нового случайного идетификатора
и установка в куки, автозамена всех URL.
</ol>
Таким образом, можно определить поведение ПХП:
<ul>
При первом визите человека на ваш сайт ПХП не находит идентификатора;
он устанавливает куку и производит автозамену всех URL и форм.
При втором и последующем обращениях, если у человека включены куки,
то ПХП будет каждый раз получать идентификатор из кук и соответветственно 
не будет производить повторной установки куки или автозаменять URL.
Если при повторном посещении ПХП обнаружит идентификатор только в 
URL, то ПХП будет и далее пытаться установить куку и производить 
автозамену. Все это следует из приведенных выше 3-х правил.
</ul>



<a name=cookies></a>
<b>Алгоритм установки кук.</b> После завершения первого алгоритма
получается, что все пользователи становятся идентифицированными
с каким-то номером - старым или новым. Если в предыдущей проверке
выполнились 2 или 3 варианты, по ПХП устанавливает куку. 
Если выполнился вариант 1 - кука повторно не отсылается.
Вы скорее всего когда либо работали с куками и знаете, что
устанавить их можно только до вывода на экран какого-либо текста.
Поэтому и надо писать команду <tt><nobr><b>session_start()</b></nobr></tt>
в самом начале программы. Хотя, можно применить буферизацию 
вывода установив <tt><nobr><b>output_buffering</b></nobr></tt> в
<tt><nobr><b>on</b></nobr></tt>. Тогда вы сможете стартовать сессии в 
любом месте программы, ставить куки и писать где угодно
информацию в заголовок страницы (с помощью функции 
<tt><nobr><b>Header()</b></nobr></tt>).
<br><br>



<a name=zamena></a>
<b>Алгоритм автозамены всех ссылок и форм.</b>
После того, как ПХП-программа закончит работу и до вывода результата
браузеру, происходит автозамена ссылок. 
Вернее, ПХП решает, нужно ли ее производить. Если из вышеприведенных
3-х вариантов срабатывают 2-й или 3-й (либо посетитель новый, 
либо у него намерянно отключены куки), то ПХП производит автозамену.
Автозамена всех ссылок такого типа:
<br><br><center><table width=95% border=0 bgcolor=#d8d8d0><tr><td><br>
<pre><xmp>
БЫЛО: <a href=test.php?a=1&name=Dima>click here</a>
СТАЛО: <a href=test.php?a=1&name=Dima&PHPSESSID=ac4f4a45bdc893434c95dcaffb1c1811>click here</a>
</xmp></pre></td></tr></table></center><br>

Подобным образом ПХП пытается вставить идетификаторы во все формы GET 
или POST запроса:

<br><br><center><table width=95% border=0 bgcolor=#d8d8d0><tr><td><pre><br><xmp>
БЫЛО:

<form action=test.php>
Имя: <input type=text name=nick value='$nick'>
<input type=submit>
</form><br>

СТАЛО:

<form action=test.php?PHPSESSID=ac4f4a45bdc893434c95dcaffb1c1811>
<input type=hidden name=PHPSESSID value='ac4f4a45bdc893434c95dcaffb1c1811'>
Имя: <input type=text name=nick value='$nick'>
<input type=submit>
</form>
</xmp></pre></td></tr></table></center>
<br>

Данная автозамена происходит без вашего участия, ПХП сам решает 
когда нужно заменять и сам пытается встроить идетификатор посетителя,
чтобы не потерять его. Таким образом, если вы будете делать
нормальные страницы, содержащие ссылки и формы, ПХП постарается 
все позаменять. Однако, если вы постараесь ему помешать,
например, вставляя HTML-теги с помощью функции javascript:document.write(),
то ПХП явно не станет анализировать эти скрипты.
Короче говоря, ПХП не гарантирует вам 100% замены всех ссылок и форм, но
работает он очень хорошо.
<br><br>
Чтобы автоматичиская замена URL работала, убедитесь, что ПХП  
скомпилирован с опцией <tt><nobr><b>--enable-trans-id</b></nobr></tt>. 
Если на вашем сайте не поисходит автозамены - перекомпилируйте свой 
ПХП. Обычно ПХП компилируют с минимальным количеством параметров
и указанного паратра там нет. Если ваш сервер очень нагружен,
по подумайте, стоит ли вообще включать автозамену URL (скорее всего 
вы можете себе это позволить, т.к. на подовляющем большинстве серверов 
процессор в среднем загружен только на 5-10%).
<br><br>
Обратите внимание, что все связанное с автозаменой нужно только
для пользователей с отключеными куками. Поэтому, если вы 
не хотите рассматривать вариант отключенных кук, соотвественно вам 
не нужен режим автозамены. 
<br><br>
Если вы хотите поддерживать работу сайта с отключенными куками 
но не хотите, чтобы ПХП автоматически заменял ссылки и формы, 
либо если ПХП на какой-то конкретной ссылке/форме глючит и не 
вставляет идентификатор, проделывайте это вручную. Это очень просто.
Для начала отпределим новую константу <tt><nobr><b>SIDFORM</b></nobr></tt>
(после <tt><nobr><b>session_start()</b></nobr></tt>):
<br><br><center><table width=95% border=0 bgcolor=#d8d8d0><tr><td><pre><br><xmp>
define ("SIDFORM","<input type=hidden name=".session_name()." value=".session_id().">");
</xmp></pre></td></tr></table></center><br>
Представим, что у нас есть ссылки и формы (еще бывают фреймы и
теги типа AREA, но там делают аналогично). С помощью двух констант 
SID - определена в ПХП и SIDFORM - придумали сами себе, переработаем текст:


<br><br><center><table width=95% border=0 bgcolor=#d8d8d0><tr><td><pre><br><xmp>
------------------БЫЛО (ПХП-файл)------------------

<html><body>
Ссылка: <a href=test.php?a=1>click here</a> ...
Форма:  <form action=test.php>  
        .... 
        </form>

------------------МЫ ЗАМЕНЯЕМ НА (новая версия ПХП-файла)------------------

<html><body>
Ссылка: <a href=test.php?a=1&<?=SID?>>click here</a> ....
Форма:  <form action=test.php>
        <?=SIDFORM?>  
        .... 
        </form>

------------------РЕЗУЛЬТАТ ВЫПОЛНЕНИЯ (это получит браузер)------------------

<html><body>
Ссылка: <a href=test.php?a=1&PHPSESSID=ac4f4a45bdc893434c95dcaffb1c1811>click here</a> ....
Форма:  <form action=test.php>
        <input type="text" name="PHPSESSID" value="ac4f4a45bdc893434c95dcaffb1c1811">
        .... 
        </form>
</xmp></pre></td></tr></table></center>
<br>
Тоже самое будет и в ПХП-варианте:
<tt><nobr><b>echo "&lt;a href=test.php?e=2>click here&lt;/a>";</b></nobr></tt>
надо заменить на 
<tt><nobr><b>echo "&lt;a href=test.php?e=2&".SID.">click here&lt;/a>";</b></nobr></tt>
<br>
Обратите внимание, что <tt><nobr><b>SID</b></nobr></tt> - это константа. И если 
вы хотите иметь переменную <tt><nobr><b>$SID</b></nobr></tt>, то просто напишите в 
начале программы <tt><nobr><b>$SID=SID;</b></nobr></tt>
(после старта сессий).
<br><br>
Итак, подведем итог автозамене. Если вы не хотите вставлять 
идентификаторы - полагайтесь
на ПХП, который постарается все ссылки заменить. Если вы 
хотите 100% надежность того, что 
все смогут использовать ваш сайт и ни один пользователь
ни на одной старнице случайно не потеряет сессию, то 
прибавляйте к каждой форме и ссылке по небольшой константе (их 
можно названить очень коротко, типа "X" и "Y"). 


<br><br><br>

<hr size=1 noshade>


<h2>Параметры и функции для сессий</h2>

В данной главе приведено описаний сессий - это <b>ФУНКЦИИ</b> и одноименные 
<b>НАСТРОЙКИ</b> в php.ini или .htaccess.
Функции от настроек отличаются тем, что у первых есть скобочки - <tt><nobr><b>функция()</b></nobr></tt>.
Для тех, кто не в курсе. Вы можете настраивать сессии, задавая разные
параметры в php.ini, httpd.conf или .htaccess файлах. 
В php.ini все переменные уже написаны и содержат какие-либо
значения (их называют глобальными настройками),
с помощью httpd.conf или .htaccess можно указать для какого-либо
виртуального сервера или отдельного каталога локальные настройки ПХП.
Для этого используют 
строку <tt><nobr><b>php_value Имя Значение</b></nobr></tt>.
Обратите внимание, что использовать настройки можно только  если ваш 
ПХП является модулем Апача. В противном случае  (ПХП - не модуль,
а отдельная CGI-программа)
такая строка в .htaccess вызовет ошибку, как и любая неправильная строка.




<h3><font color=blue><b>session_start()</b></font></h3>

Запустить поддержку сессий в скрипте. Данная функция подробно была описана
выше. Функцию можно не использовать, т.к. первая же
<tt><nobr><b>session_register("НазваниеПеременнной")</b></nobr></tt> запустит сессии.

<h3><font color=blue><b>session_destroy() </b></font></h3>

Уничтожить: 
<ul>
<li>все данные, хранящиеся в сессии
<li>файл, отведенный для данных
<li>переменные в программе и идентификатор посетителя
</ul>
Функция отменяет действие session_start(). 
Вызывать нужно после вызова session_start().
Можно применять, чтобы
уничтожать сессиию пользователя, а потом сразу вызывать 
в программе второй раз session_start(), получиться совершенно 
новый посетитель с новым идентификатором и чистой сессией.


<h3>
<font color=blue><b>session_name()</b></font>,
<font color=blue><b>session.name</b></font>, 
<font color=blue><b>PHPSESSID</b></font>
</h3>
ПХП для хранения идентификатора использует какую-то переменную
В куку записывают переменную: значение переменной - идентификатор, 
название переменной - PHPSESSID.
PHPSESSID - это название, которое используют по-умолчанию. 
Я рекомендую переименовать ее во 
что-либо короткое, например SID. 
А для этого надо заменить параметр session.name на значение SID:
<ul>
<li>можно заменить php.ini:
<font color=red><b><tt><nobr><b>session.name = SID</b></nobr></tt></b></font>
<li>можно создать <tt><nobr><b>.htaccess</b></nobr></tt> файл
в каталоге со скриптами вашего сайта и поместить строку
<font color=red><b><tt><nobr><b>php_value session.name SID</b></nobr></tt></b></font>
</ul>
После такого переименования получится, что 
константа SID содержит строку "SID=номер_сессии"
(<tt><nobr><b>echo SID;</b></nobr></tt>), а переменная $SID
только сам номер (<tt><nobr><b>echo $SID;</b></nobr></tt>).
Для тех, кто не в курсе, константы в ПХП используют без символа доллара.
<br><br>
Чтобы получить название переменной, которую используют для хранения 
идентификатора, что в свою очередь происходит из-за настроек,
надо воспользоваться функцией без параметра
<font color=red><b><nobr>$name=session_name()</nobr></b></font>
<br><br>
Чтобы установить такую переменную в произвольное название,
воспользуйтесь функцией с параметром
<font color=red><b><nobr>session_name("МоеНазвание")</nobr></b></font>.
Разумеется, если вам почему-то понадобилось изменить имя переменной
для кук с помощью этой функции, то ее надо вызывать 
перед session_start() или session_register(), иначе,
как не трудно догадаться, будет поздно что либо менять.
К тому же, вы должны будете использовать эту функцию во всех своих скриптах,
где требуется заменить "PHPSESSID" на "МоеНазвание".

<h3><font color=blue><b>session_module_name(), session.save_handler</b></font></h3>

Получить или установить текущий модуль сессии.
ПХП может хранить сессии разном виде. По умолчанию - в файлах.
См. так же session_set_save_handler().

<a name=path></a>
<h3><font color=blue><b>session_save_path(), session.save_path</b></font></h3> 

Получить или установить каталог, в котором будут храниться
файлы сессии. <tt><nobr><b>$path=session_save_path()</b></nobr></tt>
- получить. <tt><nobr><b>session_save_path("/mydir/temp");</b></nobr></tt> - установить.
Параметр <tt><nobr><b>session.save_path</b></nobr></tt> 
можно задавать в <tt><nobr><b>php.ini</b></nobr></tt> 
или <tt><nobr><b>.htaccess</b></nobr></tt>.


<h3><font color=blue><b>session_id()</b></font></h3>

Получить или установить идентификатор посетителя (128-битное число,
представленное в виде строки в 32 байта).
В нормальных условиях вам не нужно устанавливать номер сесии.
Но если вы хотите для всех своих посетителей использовать одну 
сессиию, то перед <tt><nobr><b>session_start()</b></nobr></tt>
 придумайте любое имя (произвольная строка)
- <font color=red><b><nobr>session_id("dima");</nobr></b></font>
или получите настоящий идентификатор другим образом.
Вызов функции без параметров вернет вам текущий номер сессии
(в таком случае -
 вызвать после <tt><nobr><b>session_start()</b></nobr></tt>).

<h3><font color=blue><b>session_register()</b></font></h3>

Зарегистрировать одну или несколько переменных. Передавать 
надо имена переменных, а не сами переменные:
<tt><nobr><b>session_register("переменная1", "переменная2", ...)</b></nobr></tt>.
Сама функция подробна описана выше.



<h3><font color=blue><b>session_unregister()</b></font></h3>

Выполнить обратно действие - удалить из сессии необходимую переменную.
Можно передать только одно имя переменной за один вызов функции.



<h3><font color=blue><b>session_unset()</b></font></h3>

Очистить все переменные сессии. В отличии от session_destroy()
сессия и идентификатор остается.


<h3><font color=blue><b>session_is_registered()</b></font></h3>

Проверить, зарегистрирована какая либо переменная в текущей сессии
или нет: <tt><nobr><b>if (session_is_registered("МояПеременная")) ...</b></nobr></tt>


<h3><font color=blue><b>session_get_cookie_params()
и session_set_cookie_params()</b></font></h3>

Получить информацию о куке, хранящей переемнную с идентификатором сессии.
<tt><nobr><b>echo "&lt;pre>SESSION INFO:\n"; print_r(session_get_cookie_params());</b></nobr></tt>
Так можно узнать о времени жизни переменной,
домене и пути куки.
session_set_cookie_params() - соотвественно переустановить 
параметры (хотя все эти параметры надо задавать в php.ini - см. ниже).


<h3><font color=blue><b>session_decode() и session_encode()</b></font></h3>

Раскодировать закодированную строку в сессию и 
получить закодированную строку сессии.


<a name=handler></a>
<h3><font color=blue><b>session_set_save_handler()</b></font></h3>

Возможно, вас не усраивают варианты хранения сессий, предлагающихся в ПХП.
Может быть вы хотите хранить сессии в простых текстовых файлах, 
чтобы их можно было легко редактировать.
Тогда вам нужно создать несколько функций, отвечающих за функционирование
сессий и передать названия этих функций в <tt><nobr><b>session_set_save_handler()</b></nobr></tt>
(чтобы пропустить какой либо параметр, передавайте 
пустую строку - <tt><nobr><b>""</b></nobr></tt>).
Если вы пишите что-не не стандарное, вам будет полезна фукнция. Описывать
ее не буду, т.к. не использовал, да и в мануале есть полное описание и пример.


<h3><font color=blue><b>session.auto_start</b></font></h3>

По умочанию равно 0, сессии автоматически не запускаются.
Если равно 1, то session_start() писать в начале каждого скрипта не нужно.

<h3><font color=blue><b>session.cookie_lifetime</b></font></h3>

Если равно 0 (по-умолчанию), то кука, хранящяя сессию, будет 
уничтожена на компьютера посетителя как только он закроет все окошки
браузера. Если не нуль, то это задает число секунд для хранения куки.


<h3><font color=blue><b>session.gc_maxlifetime</b></font></h3>

Количество секунд, через которое ПХП уничтожит у себя 
на диске устаревший файл сессии. По умолчанию - 1440. 
Это произойдет НЕ РАНЕЕ
кол-ва секунд, указанного в переменной. Данное время
определяет нижнюю гланицу (НЕ РАНЕЕ), когда файл становится кандидатом 
на удаление. Верхняя граница определяется следующей переменной.
Время отсчитывается от последнеого обращения посетителя т.е.
это время доступа к файлу, а не создания.
У любого файла есть время создания. модификации (запись) и доступа (чтение).


<h3><font color=blue><b>session.gc_probability</b></font></h3>

Число от 1 до 100, измеряемое в процентах (по умолчанию - 1, т.е. 1%),
которое задает вероятность запуска механизма удаления старых файлов сессии.
Другими словами, при каждом обращении посетителей
к любой программе вашего сайта, использущей сессии, с вероятностью 1% 
произойдет поиск и удаление устаревших файлов сессии.
Таким образом, по-умолчанию, вы на должны опасаться, что на сервере
скопится огромное число мусора, и вам придется писать программу
для его сбора. Только укажите желаемую частоту сбора.
Не рекомендуется устанавливать 100%, т.к. ПХП будет при каждом обращении 
пользователя искать старые файла, что создаст лишнюю нагрузку.
Разумный максимум для данной переменной - 5%, хотя лучше оставить как есть - 1%.

<h3><font color=blue><b>session.use_cookies</b></font></h3>

Использовать ли куки, для хранения идентификатора сессий или нет.
По умолчанию - 1, можно использовать. Если равно 0, то ПХП 
ничего в куки записывать не будет, а будет пытаться все время 
автозаменять URL и формы.


<h3><font color=blue><b>session.cookie_path</b></font></h3>

Если на вашем сайте используется несколько разных программ (у каждой свои сессии)
и вы не хотите, чтобы сессии случайно пересекались,
то установить нужный путь для кук. Если 
установить <tt><nobr><b>session.cookie_path /programm1</b></nobr></tt>,
то все ваши программы, расположенные в каталоге pogramm1 или его подкатлогах,
будут иметь одно общее пространство для кук, что равносильно 
одной и тожей сессии.
Если посетитель после каталога /programm1 зайдет в /programm2 (для которого
тоже заведены отдельные куки), то он будт идентифицирован новой программой по 
новому. Если у вас на сайте всего одна программа или много программ,
но на разных названиях серверов, то куки/сессии никак не пересекутся.

<h3><font color=blue><b>session.cookie_domain</b></font></h3>

Из той же области, что и предыдущая переменная. 
Для полного понимания ее работы читайте о куках. 
Такой документации на русском языке очень много.

<br><br><br>

<hr size=1 noshade>

<h2>Приступим к работе с сессиями</h2>

Для начала решим, как правильно должны начинаться наши скрипты 
и что мы собираемся хранить в сессиях. Предложение N1 - 
несколько строк, которые будут отвечать за правильный запуск 
сессий и обработки новых пользователей, которым 
надо записать какие-то переменные для начала пработы, 
хорошо бы поместить в отдельный файл.
Итак, файл index.php будет главным на сайте, а описанные 
команды мы поместим в default.php.
<br><br>
Предложение N2 - наша программа
будет содержать много функций, в которых иногда будет
происходить доступ к переменным сессий, следовательно последние надо
будет делать глобальными в функциях. Если у нас будет десяток
переменных, то нам придется писать большую строку
для объявления переменных глобальными. Если же мы зарегистрируем
в сессиях только одну переменную-массив с коротким названием, 
то нам будет легко ее прописывать глобальной и легко обращаться.
Итак, предложение 2 - используем переменную $s, все необходимые 
параметры пишем в $s как в массив: <tt><nobr><b>$s[название]=значение</b></nobr></tt>.
<br><br>
Что записывать всем пользователям по умолчанию?
Давайте, при входе нового посетителя, будет объявлять 
переменную <tt><nobr><b>$s[start]</b></nobr></tt>,
в которой запишим время входа пользователя. Чтобы получить текущее
время (число) используют <tt><nobr><b>time()</b></nobr></tt>.
Больше ничего делать с новыми посетителями не надо. 
На главной страние мы будем выводить фразу "Добро пожаловать!", 
если человек впервые тут и фразу "Вы пришли к нам ?? секунд назад".
Подсчитать кол-во секунд весьма просто: 
<tt><nobr><b>time()</b></nobr></tt> - текущее 
время, <tt><nobr><b>$s[start]</b></nobr></tt> - уже прошедшее 
(когда мы произвели запись <tt><nobr><b>$s[start]</b></nobr></tt>).
Таким образом, надо от большего отнять меньшее. Пишем эту программу.
<br><br>

<font color=blue><b>Файл default.php</b></font>:

<center><table width=95% border=0 bgcolor=#d8d8d0><tr><td><pre><br><xmp>
<?

   // до первой строки с "<?" вы не должны ставить пустые строки или пробелы
   // данный файл должен начинаться с "<?"
   // в тексте программ возможно любое кол-во пустых строк

   unset($s); 
   // удаление переменной $s, если она вдруг была объявлена
   // чтобы никто не мог ничего через URL ничего записать
   // например, так: index.php?s[start]=...
   // сессии еще не запустились, поэтому мы удаляем не ту переменную $s,
   // что появиться после следующей строки

   session_start(); 
   // включить поддержку сессий. Если человек новый, ему
   // выдадут случайный идентификатор. Но мы про это пока не 
   // думает, а сразу приступаем к использованию сессии

   session_register("s"); 
   // зарегистрировать переменную $s как переменную сессии
   // обратите внимание - пишем "s" в функции, а не $s
   // с этого момента вся информация в будущем массиве $s будет сохраняться

?>
</xmp></pre></td></tr></table></center>
<br>

<font color=blue><b>Файл index.php</b></font> (или любой файл вашего будущего сайта)

<center><table width=95% border=0 bgcolor=#d8d8d0><tr><td><pre><br><xmp>
<?

   // до первой строки с "<?" вы не должны ставить пустые строки или пробелы

   include("default.php");
   // подключаем файл default.php из текущего каталога (из того же, где и сам
   // index.php лежит)

   if (!isset($s['start'])) {
      // если выполнится это условие, т.е. переменной $s[start] еще несуществует,
      // то мы может произвести какие-то действия, пусть даже самые простые.
      // Используем переменную $s[start] как флаг и отсчет времени

      $s['start']=time();
      // в переменную запишеться ненулевое положительное число
      // больше данный IF не выполниться, т.к. теперь и далее переменная
      // $s[start] существует (и дополнительно хранит полезное число)

      echo "Добро пожаловать на наш сайт!";
      // выводим сообщение в знак того, что данный посетитель пришел 
      // пришел впервые
   }
   else {
      // если выполниться это условие, то это старый посетитель
      // выводим для него соответствующую фразу и не производим
      // установку переемнных по умолчанию

      echo "Вы впервые пришли на наш сайт ".(time()-$s['start'])." секунд назад";

   }

?>
</xmp></pre></td></tr></table></center><br>

Данный пример поможно посмотреть тут:
<a href=s/example1/>/php/s/example1/</a>
<br><br>

Обратите внимание,
что программа при выключенных куках работать не будет.
Для его работоспособности надо при первом обращении пользователя
сделать <tt><nobr><b>header("Location: $PHP_SELF?".SID);</b></nobr></tt>
(разумеется, при этом человек не увидет приветствие).
<br><br>
На этом пока придеться закончить, остальное допишу через несколько дней.
Пока вы можете смотреть уже готовые примеры этого сайта, использующие сессии:
<ul>
<li><a href=sess.html>простой пример работы с сессиями</a>
<li><a href=/mysql/lock_tables2.html>защита от двойного сабмита (SUBMIT формы)</a>
<li><a href=shop.html>виртуальный магазин</a>
</ul>





<br><br><br><br><br>
<script language="javascript"> 
u="u217.97.spylog.com";d=document;nv=navigator;na=nv.appName;t="";p=1; 
sz=" width=88 height=31 "; 
hl=history.length;d.cookie="b=b";c=0; 
bv=Math.round(parseFloat(nv.appVersion)*100); 
if (d.cookie) c=1;n=(na.substring(0,2)=="Mi")?0:1; 
if((n==0)||(bv >= 300)){rn=Math.random();t=(new Date()).getTimezoneOffset();} else {rn=0;} 
z="p="+p+"&rn="+rn+"&t="+t+"&c="+c+"&hl="+hl; 
if (self != top) { fr=1;} else { fr=0;} 
r=escape(d.referrer);r1=""; 
sl="1.0";h=0; 
</script> 
<script language="javascript1.1"> 
pl="";sl="1.1"; 
if((n==1) && (bv >= 300)) 
{ for(var i = 0; i < nv.plugins.length; i++) 
pl += nv.plugins[i].name+":"; } 
j = (navigator.javaEnabled() ? "Y" : "N"); 
</script> 
<script language=javascript1.2> 
sl="1.2";s=screen;wh=s.width+'x'+s.height; 
px=(n==0)?screen.colorDepth:screen.pixelDepth;z+="&wh="+wh+"&px="+px; 
</script> 
<script language=javascript1.3> 
sl="1.3" 
</script> 
<script language="javascript"> 
y=""; 
y+="<a href='http://"+u+"/cnt?f=3&p="+p+"&rn="+rn+"' target=_blank>"; 
y+="<img src='http://"+u+"/cnt?"; 
y+=z+"&j="+j+"&sl="+sl+"&r="+r+"&r1="+r1+"&fr="+fr+"&pg="+escape(window.location.href)+"&pl="+escape(pl); 
y+="' border=0 "+sz+" alt='SpyLOG'>"; 
y+="</a>"; 
d.write(y); 
</script> 
<script language="javascript1.2"><!-- 
if (n == 0) { d.write("<");d.write("!--"); } 
//--></script> 
<noscript> 
<a href="http://u217.97.spylog.com/cnt?f=3&p=1" target=_blank> 
<img src="http://u217.97.spylog.com/cnt?p=1" alt='SpyLOG' border='0' width=88 height=31 > 
</a> 
</noscript> 
<script language="javascript1.2"><!-- 
if (n == 0) { d.write("--");d.write(">"); } 
//--></script> 







<!--TopList COUNTER--><script language="JavaScript"><!--
d=document;a='';a+=';r='+escape(d.referrer)
js=10//--></script><script language="JavaScript1.1"><!--
a+=';j='+navigator.javaEnabled()
js=11//--></script><script language="JavaScript1.2"><!--
s=screen;a+=';s='+s.width+'*'+s.height
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth)
js=12//--></script><script language="JavaScript1.3"><!--
js=13//--></script><script language="JavaScript"><!--
d.write('<a href="http://top.list.ru/jump?from=267962"'+
' target=_top><img src="http://top.list.ru/counter'+
'?id=267962;t=47;js='+js+a+';rand='+Math.random()+
'" alt="TopList"'+' border=0 height=31 width=88></a>')
if(js>11)d.write('<'+'!-- ')//--></script><noscript><a
target=_top href="http://top.list.ru/jump?from=267962"><img
src="http://top.list.ru/counter?js=na;id=267962;t=47"
border=0 height=31 width=88
alt="TopList"></a></noscript><script language="JavaScript"><!--
if(js>11)d.write('--'+'>')//--></script><!--TopList COUNTER-->


<!-- HotLOG -->
<SCRIPT LANGUAGE="JavaScript">hotlog_js=0; function HotLOG() {}</SCRIPT>
<SCRIPT SRC="http://counter.hotlog.ru/cgi-bin/hotlog/count.js"></SCRIPT>
<SCRIPT LANGUAGE="JavaScript1.1">hotlog_js=1</SCRIPT>
<SCRIPT LANGUAGE="JavaScript1.2">hotlog_js=2</SCRIPT>
<SCRIPT LANGUAGE="JavaScript1.3">hotlog_js=3</SCRIPT>
<SCRIPT LANGUAGE="JavaScript">HotLOG(4535,hotlog_js)</SCRIPT>
<noscript><img src="http://hit.hotlog.ru/cgi-bin/hotlog/count?s=4535" border=0 width=1 height=1></noscript>
<!-- /HotLOG -->

