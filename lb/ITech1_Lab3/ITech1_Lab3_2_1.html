<!DOCTYPE HTML>
<html>
<head>
  <title>3.2.1 Базовые понятия JavaScript</title>
  <meta charset="utf-8">
  <link href="css/styles.css" type="text/css" rel="stylesheet">
</head>
<body>
  <p class="subsection">3.2.1 Базовые понятия JavaScript</p>
  <div id="3_2_1_1">3.2.1.1 Размещение операторов языка на странице
  Встроить сценарий JavaScript в HTML-страницу можно несколькими способами: 
  <ul>
    <li>задать операторы языка внутри тэга &lt;script&gt; языка HTML;</li>
    <li>указать файл с кодом JavaScript в атрибуте SRC тэга &lt;script&gt;;</li>
    <li>использовать выражения JavaScript в качестве значений параметров тэгов HTML;</li>
    <li>определить обработчик события в тэге HTML.</li>
  </ul>
  <p>Для внедрения в HTML-страницу сценария JavaScript в спецификацию языка HTML был введен тэг-контейнер &lt;script&gt; ... &lt;/script&gt;, внутри которого могут располагаться операторы языка JavaScript. Обычно браузеры, не поддерживающие какие-нибудь тэги HTML, просто их игнорируют, анализируя, однако, содержимое пропускаемых тэгов с точки зрения синтаксиса языка HTML, что может приводить к ошибкам при отображении страницы.
  <br>&nbsp; &lt;script type="text/javascript" defer&gt;
  <br>&nbsp;&nbsp;&nbsp; window.alert("Hello!!");
  <br>&nbsp;&nbsp;&nbsp; document.write("Hello!!");
  <br>&nbsp; &lt;/script&gt;</p>
  <p>Тэг &lt;script&gt; имеет параметр SRC, позволяющий связать встраиваемый сценарий с внешним файлом, содержащим программный код на языке JavaScript. 
  <br>&lt;script src="myScript.js"&gt;&lt;/script&gt;</p>
  <p>Операторы внутри тэга &lt;script&gt; игнорирются браузером, если только не произошла ошибка при включении файла в страницу, например, файл не найден.
  <br>
  &lt;script src="jsfunct.js"&gt;
  <br>&nbsp;&nbsp; &lt;!--
  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.alert("Не загрузился файл сценария!")
  <br>&nbsp;&nbsp; --&gt; 
  <br>&lt;/script&gt; 
  </p>
  <p>Комментарии - это специальные замечания программиста, чтобы объяснить, что делает данный скрипт, и они игнорируются интерпретатором. JavaScript поддерживает следующий стиль комментариев:
  <br>Однострочные комментарии начинаются с символа (//).
  <br>Многострочные комментарии начинаются /* и заканчиваются */.</p>
  </div>
  <br>

  <div id="3_2_1_2">3.2.1.2 Вывод информации пользователю
  <p> Метод alert() позволяет выдать окно предупреждения:
  <br>alert("Внимание!!!!!!!!!!!");
  <br>При открытии HTML-страницы появится системное окно.
  <br><img src="images/pic01.JPG" alt="Внимание"></p>
  <p>Вывод информации в документ возможен при помощи document.write("&lt;h1&gt;Test&lt;/h1&gt;");</p>
  </div>
  <br>
  
  <div id="3_2_1_3">3.2.1.3 Переменные
  <p>Переменные используются, чтобы хранить значения в вашем приложении. Названия переменных должны начинаться с символа от "a" до "Z" (верхнего или нижнего регистра) или символа подчеркивания ("_"); в составе также могут быть цифры (0-9). JavaScript учитывает регистр. Некоторые примеры допустимых имен:
  <br>Number_hits
  <br>temp99
  <br>_name</p>
  <p>Переменные объявляются следующим образом:
  <br>var varname1 [= value1 [, varname2 [, varname3 ... [, varnameN]]]]; 
  <br>varnameN - имя переменной, valueN - начальное значение переменной, любое выражение.</p>
  <p>Если при определении переменной ей не присвоено никакого значения, то ее тип неопределен. Ее тип будет определен только после того, как ей будет присвоено некоторое значение оператором присваивания "=". </p>
  <p><i>Область действия</i> переменных определяет, где вы можете использовать их в скрипте. В JavaScript существует две области действия: глобальная (можете использовать переменную в любом месте в приложении) и локальная (внутри текущей функции).</p>
  <p>JavaScript включает в себя арифметические и логические выражения.  Логические вычисляют true(истина) или false(ложь). Значение <i>null</i> используется для переменных, которым не присвоено никакое значение. Любая попытка использовать переменную, имеющую значение null, в вычисляемом выражении приводит к ошибке, за исключением случая присваивания значения null переменной, например, <i>timerID = null</i>.</p>
  </div>
  <br>
  
  <div id="3_2_1_4">3.2.1.4 Операторы
  <p>Операторы могут быть бинарными и унарными. 
  <br>Бинарный оператор требует два операнда:
  <br><i>operand1 operator operand2</i>
  <br>Например, <i>3 + 4</i> или <i>x * y</i>.
  <br>
  <br>Унарный оператор требует один операнд, до или после оператора:
  <br><i>operator operand</i> или <i>operand operator</i>
  <br>Например, <i>x++</i> или <i>++x</i>.</p>
  <p>Операторы <b>присваивания</b> (=, + =, - =, * =, / =) присваивают значение на основе правого операнда левому операнду.
  <br>Оператор присваивания "+=" может также использоваться, чтобы конкатенировать строки. Например, если переменная <i>mystring</i> - строка, которая имеет значение "<i>alpha</i>", то выражение <i>mystring += "bet"</i> вычисляет как "<i>alphabet</i>" и присваивает это значение переменной <i>mystring</i>.</p>
  <p><b>Арифметические</b> операторы принимают численные значения в качестве операндов и возвращают числовое значение. Стандартные арифметические операторы - сложение (+), вычитание (-), умножение (*) и деление (/).
  <br>Сложение, конкатенация (x += y, x = x + y). Конкатенация, применительно к строковым операндам, возвращает строку, которая является соединением двух строк операндов. Например, "my " + "string" возвращает строку "my string".
  <br>Вычитание: x -= y, x = x - y.
  <br>Умножение: x *= y, x = x * y.
  <br>Деление: x /= y, x = x / y.
  <br>Вычисление остатка от деления: x %= y, x = x % y. Var1 % var2. Оператор модуля возвращает первый операнд по модулю второго операнда, то есть var1 по модулю var2, где var1 и var2 - переменные. Например, 12 % 5 возвращает 2.
  <br>Инкримент (++) имеет постфиксную (var++) и префиксную (++var) формы. Этот оператор увеличивает операнд и возвращает значение. Если используемый постфикс, с оператором после операнда (например, x ++), то возвращает значение перед увеличением. Если используемый префикс с оператором перед операндом (например, ++x), то возвращает значение после увеличения.
  <br>Декремент (--) уменьшает операнд и возвращает значение. Если используемый постфикс (например x--) то возвращает значение перед уменьшением. Если используемый префикс (например, --x), то возвращает значение после уменьшения.
  <br>Унарный оператор вычитания должен предшествовать его операнду. Например, x = -x вычитает значение x; если бы x был равен 3, то стал бы равным -3.</p>
  <p><b>Побитовые</b> операторы воздействуют на операнды как набор битов (0 и 1). Например, десятичное число 9 имеет двоичное представление 1001. Побитовые операторы выполняют действия на таких двоичных представлениях, но они возвращают стандартное JavaScript численное значение. Побитовые операторы:
  <br>Побитовое И: x &= y, x = x & y. Возвращает 1, если оба операнда 1.
  <br>Побитовое ИЛИ: x |= y, x = x | y. Возвращает 1, если любой операнд 1.
  <br>Исключающее побитое ИЛИ: x ^= y, x = x ^ y. Возвращает 1, если есть 1, но не оба операнда 1.
  <br>Например, бинарное представление 9 - 1001, и бинарное представление 15 - 1111. Так, когда побитовые операторы применяются к этим значениям, то результаты выглядят следующим образом:
  <br>15 & 9 возвращает 9 (1111 & 1001 = 1001)
  <br>15 | 9 возвращает 15 (1111 | 1001 = 1111) 
  <br>15 ^ 9 возвращает 6 (1111 ^ 1001 = 0110) 
  <br>Побитовые операторы сдвига: 
  <br>Операторы сдвига преобразуют операнды к 32-битное целое число, и возвращают результат того же самого типа что и левый оператор.
  <br>Побитовый сдвиг влево: x &lt;&lt;= y, x = x &lt;&lt; y. Сдвиг влево перемещает все биты влево на количество позиций, указанных в правой части выражения, заполняя освободившиеся позиции нулями. Например, 9&gt;&gt;2 возвращает 36, потому что 1001 сдвигается на 2 бита влево и становится равным 100100, что равно в десятеричной системе 36.
  <br>Побитовый сдвиг вправо: x &gt;&gt;= y, x = x &gt;&gt; y. Cдвиг вправо заполняет освободившиеся слева позиции значением самого левого бита исходного значения. Например, 9 &gt;&gt; 2 возвращает 2, потому что 1001 сдвигается на два бита вправо и становится 10, что равно в десятеричной системе 2. Аналогично, -9 &gt;&gt; 2 возвращает -3, потому что знак сохраняется.
  <br>Побитовый сдвиг вправо с заполнением нулями: x &gt;&gt;&gt;= y, x = x &gt;&gt;&gt; y. Сдвиг вправо с заполнением нулями работает аналогично сдвигу влево, только в противоположном направлении. Например, 19 &gt;&gt;&gt; 2 возвращает 4, потому что 10011 сдвигается на два бита вправо и становятся 100, что равно в десятеричной системе 4. Для postive чисел, ноль - заполняет правый сдвиг, и распространяющийся знак сдвигается вправо и выдает тот же самый результат.
  <br></p>
  <p><b>Логические</b> операторы принимают логические (булевы) значения как операнды. Они возвращают логическое значение true (истина) и false (ложь).
  <br><b>И (&&)</b>: expr1 && Expr2
  <br>Логический "и" возвращает оператор true, если оба логических выражения и expr1 и expr2 true. Иначе, возвращается false.
  <br><b>Или (||)</b>: expr1 || expr2
  <br>Логический "или" возвращает оператор true, если хотя бы одно из логических выражений или expr1 или expr2 true. Если и expr1 и expr2 false, то возвращается false.
  <br><b>Нет (!)</b>:! Expr
  <br>Логический оператор "нет" - унарный оператор, который отрицает выражение операнда expr. То есть если expr true, то возвращает false, и если expr false, то возвращает true.</p>
  <p>Операторы <b>сравнения</b> (==, &gt;, &gt;=, =&lt;, &lt;=, !=) возвращают логическое значение true или false. Операндами операторов сравнения могут быть численные и строковые значения. Строки сравниваются, исходя из стандартного лексикографического порядка при использовании Unicode.
  <br>Операторы:
  <br><b>Равно (==)</b>: возвращает true, если операнды равны. Для строгого сравнения оба операнда должны иметь одинаковый тип и:</p>
    <ul>
      <li>Две строки строго равны, если состоят из одинаковой последовательности символов.</li>
      <li>Два числа строго равны, если равны в обычном смысле слова. +0 строго равен -0.</li>
      <li>NaN строго не равно ничему, включая NaN.</li>
      <li>Два булевых операнда строго равны, если они оба true или false.</li>
      <li>Два операнда-объекта строго равны, если являются ссылками на один и тот же общий объект.</li>
      <li>Null и Undefined равны ==, но не строго равны ===.</li>
    </ul>
  <p><b>Не равно (!=)</b>: возвращает true, если операнды не равны. 
  <br><b>Больше чем (>)</b>: возвращает true, если левый операнд больше чем правый операнд. Пример: x>y возвращает true, если x больше чем y.
  <br><b>Больше или равно чем (&gt;=)</b>: возвращает true, если левый операнд больше чем или равен правому операнду. Пример: x>=y возвращает true, если x больше или равен чем y.
  <br><b>Меньше чем (&lt;)</b>: возвращает true, если левый операнд - меньше чем правый операнд. Пример: x&lt;y возвращает true, если x - меньше чем y.
  <br><b>Меньше или равно чем (&lt;=)</b>: возвращает true, если левый операнд - меньше или равен правому операнду. Пример: x&lt;= y возвращает true, если x - меньше или равен y.</p>
  <p><b>Старшинство</b> операторов
  <br>Старшинством операций называется порядок, в котором выполняются операции в сложных выражениях. Операции на одном уровне имеют равное старшинство. Вычисления производятся слева направо для всех бинарных операций, начиная с операций, перечисленных в верхней части списка, и заканчивая операциями в нижней части.
  <br>Старшинство операторов, от самого низкого до самого высокого будут следующие:
  <br>Присвоение: = += -= *= /= %= &lt; &lt;= &gt; &gt;= &gt;&gt;&gt;= &= ^= |=
  <br>Выбор по условию: ? :
  <br>Логическое ИЛИ: ||
  <br>Логическое И: &&
  <br>Побитовое ИЛИ: |
  <br>Побитовое исключающее: ^
  <br>Побитовое И: &
  <br>Равенство/Неравенство: == !=
  <br>Сравнение: &lt; &lt;= &gt; &gt;=
  <br>Побитовый сдвиг: &lt;&lt;&lt; &lt;&lt; &gt;&gt; &gt;&gt;&gt;
  <br>Сложение/вычитание: + -
  <br>Умножение/деление/взятие модуля:  * / %
  <br>Отрицание/дополнение/унарный минус/инкримент/дикримент: ! ~ - ++ --
  <br>Вызов, передача параметров: () [].</p>
  </div>
  <br>
  
  <div id="3_2_1_5">3.2.1.5 Условия и циклы  
  <p>Оператор <b>if...else</b> - это условный оператор, который выполняет первый набор утверждений, если проверяемое условие истинно. В противном случае выполняется второй набор утверждений, заключенный в операторе <i>else</i>, если условие ложно. Если набор утверждений, заключенных в фигурные скобки {} содержит один оператор, то скобки можно опустить. Условные операторы могут быть вложены друг в друга без ограничений.
  <br>
  <i>if (condition) {
  <br>&nbsp;...statements... 
  <br>}[else {
  <br>else
  <br>&nbsp;...statements...
  <br>}]</i></p>
  <p>Условное выражение (тернарный оператор) может иметь одно из двух значений, основанных на условии: <i>(Условие)? Val1: val2</i>. Если условие истинно, то выражение имеет значение val1, иначе имеет значение val2. Например, <i>status = (age >= 18) ? "adult" : "minor"</i>. Это утверждение присваивает значение "adult" переменной status, если age равно 18 или больше чем 18. Иначе присваивает значение "minor" переменной status.</p>
  <p>Оператор <b>while</b> - это оператор, который повторяет цикл, пока значение <i>condition</i> истинно (true). Как только значение <i>condition</i> становится ложным (false), то управление переходит к первому оператору после фигурной скобки, закрывающей тело цикла <i>while</i>:
  <br><i>while (condition) {
  <br>&nbsp;...statment...
  <br>}</i>
  <br>Примеры:
  <br>Следующий цикл <i>while</i> повторяется, пока переменная n меньше чем три. Каждая итерация увеличивает n и прибавляет его к x. Следовательно, x и n принимают следующие значения:
  <br>После первой итерации: n = 1, x = 1
  <br>После второй итерации: n = 2, x = 3 
  <br>После третьей итерации: n = 3, x = 6 
  <br>После завершения третьей итерации, условие n &lt; 3 становится ложным, следовательно, цикл прекращается.
  <br><i>n = 0;
  <br>x = 0; 
  <br>while( n &lt; 3 ) {
  <br>&nbsp;n++; x += n; 
  <br>}</i>
  <br>Следующий пример проверяет наличее в строке определенного символа и прекращает поиск по окончании перебора всех символов строки или после того, как находит искомый символ.
  <br><i>var found=false;
  <br>n=0;
  <br>while (n &lt;= searhcString.length || !found) {
  <br>&nbsp;if (searhcString.charAt[n] == "?")
  <br>&nbsp;&nbsp;found = true;
  <br>&nbsp;else n++;
  <br>}</i></p>
  <p>Оператор <b>for</b> создает цикл с тремя необязательными выражениями, заключенными в круглых скобках и разделенными точкой с запятой:
  <br><i>for (initialExpression;condition;updateExpression) {
  <br>&nbsp;...строки кода...
  <br>}</i>
  <br>где выражение <i>initialExpression</i> используется для инициализации переменной счетчика, которую можно создать с помощью оператора var. Это выражение необязательно.
  <br>Выражение <i>condition</i>, которое вычисляется на каждом проходе через цикл. Если это условие истинно, то выполняются выражения внутри цикла. Это условие необязательно. Если оно опущено, то условие всегда считается равным истинному, тогда цикл продолжается до ошибки или до оператора <i>break</i>.
  <br>Выражение <i>updateExpression</i> используется для изменения значения переменной счетчика. Оно тоже является необязательным. В этом случае можно обновлять значение переменной счетчика внутри цикла.
  <br>Примеры
  <br>Оператор <i>for</i> создает цикл, продолжающийся до тех пор пока переменная счетчика i меньше чем девять, увеличивает i на одни после каждого прохода через цикл.
  <br><i>for (var i = 0; i &lt; 9; i++) {
  <br>&nbsp;n += i;
  <br>&nbsp;myfunc(n);
  <br>}</i>
  <br>Следующий пример создает цикл <i>for</i>, продолжающийся до наступления ошибки или выполнения оператора <i>break</i>. Переменная счетчика увеличевается на при каждом проходе цикла:
  <br><i>for (var i = 0; ; i+=2)
  <br>{
  <br>...строки кода...
  <br>}</i>
  </p>
  <p>Оператор <b>for...in</b> присваевает переменной поочередно все свойства объекта. Для каждого свойства цикл <i>for...in</i> выполняет операторы, содержащиеся в теле цикла:
  <br>
  <br><i>for (var in obj) {
  <br>&nbsp;...statements...
  <br>}</i>
  <br>
  <br>Примеры
  <br>Цикл <i>for...in</i> является полезным средством для отладки благодаря своей способности вывести на экран все свойства объекта в одном цикле.
  <br>
  <br><i>function objectDisplay(obj) {
  <br>&nbsp;var displayLine;
  <br>&nbsp;for (var prop in obj) {
  <br>&nbsp;&nbsp;displayLine = obj.name + "." + prop + "=" + obj[prop];
  <br>&nbsp;&nbsp;document.write(displayLine+"&lt;BR&gt;");
  <br>&nbsp;}
  <br>&nbsp;document.write("End of object"+obj.name);
  <br>}</i>
  </p>
  <p>Оператор <b>break</b> прерывает текущий цикл for и while, передавая управление первому оператору после цикла.
  <br>Оператор <b>continue</b> передает управление оператору проверки истенности условия в цикле while и оператору обновления значения счетчика в цикле for. Важное отличие от оператора break заключается в том, что оператор continue не прерывает цикл, а переходит к следующей итерации.
  <br>Следующий пример демострирует цикл while, содержащий оператор <i>continue</i>, который выполняется, когда переменная i равна 3.
  <br><i>i = 0;
  <br>n = 0; 
  <br>while (i&lt;5) {
  <br>&nbsp;i++; if (i == 3);
  <br>&nbsp;&nbsp;continue n += i; 
  <br>} </i></p>
  </div>
  <br>
  
  <div id="3_2_1_6">3.2.1.6 Функции
  <p>Синтаксис определения функций:
  <br>&nbsp;function [name]([param1, param2, ..., paramN]) {
  <br>&nbsp;&nbsp;statements
  <br>&nbsp;} 
  <br>Аргументы:
  <br>name - имя функции. Может быть опущено, при этом создаваемая функция будет "анонимной" 
  <br>paramN - название аргумента, передаваемого функции. Функция может иметь до 255 аргументов.
  <br>statements - тело функции.
  <br>Для того чтобы возвращать значение, функция должна иметь в себе оператор <i>return</i>, который указывает возвращаемое функцией значение. Пример функции для перевода градусов по Фаренгейту в градусы Цельсия: 
  <pre><code>
  function F (fordeg)
  {
     return (5/9*(fordeg-35));
  }
  var res = prompt("Enter F","127");
  alert ("It's " + F(res) + " Celsing degrees");
  </code></pre>
  Пользовательские функции для получения случайных чисел:
  <pre><code>
  // Возвращает случайное число между min (включительно) и max (не включая max)
  function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
  }
  
  // Возвращает случайное целое число между min (включительно) и max (не включая max)
  // Использование метода Math.round() даст вам неравномерное распределение!
  function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min)) + min;
  }
  </code></pre>
  <p>Метод Math.random() возвращает псевдослучайное число с плавающей запятой из диапазона [0, 1), то есть, от 0 (включительно) до 1 (но не включая 1), которое затем можно отмасштабировать до нужного диапазона. Реализация сама выбирает начальное зерно для алгоритма генерации случайных чисел; оно не может быть выбрано или сброшено пользователем. Метод Math.floor() возвращает наибольшее целое число, меньшее, либо равное указанному числу.</p>
  <p>JavaScript имеет функции "верхнего уровня", встроенные в язык. В частности, <b>eval</b>, <b>parseInt</b>, <b>parseFloat</b>.
  <br>Аргумент встроенной функции <i>eval</i> - строка. Аргументом может быть любая строка, представляющая выражение JavaScript-утверждение, или последовательность утверждений. Выражение может включать переменные и свойства существующих объектов. Если аргумент представляет выражение, <i>eval</i> вычисляет выражение. Если аргумент представляет один или большее количество JavaScript утверждений, <i>eval</i> вычисляет утверждения. Эта функция полезна для оценки строки, представляющей арифметическое выражение.
  <p>Функции <i>parseInt</i> и <i>parseFloat</i> возвращают числовое значение когда дана строка как аргумент.
  <br>Функция <i>parseFloat</i> анализирует строковый аргумент, и возвращает число с плавающей точкой, если первый символ переданной строки - знак "плюс", знак "минус", десятичная точка, число "е" (основание натурального логарифма) или цифра. Если <i>parseFloat</i> сталкивается с недопустимым символом, то метод возвращает значение, основанное на подстроке, следующей до этого символа, игнорируя все последующие. Если первый же символ недопустим, <i>parseFloat</i> возвращает одно из двух значений, в зависимости от платформы:  0 - на платформах Windows; "NaN" - на любой другой платформе, указывая, что значение - не номер. Для арифметических целей, значение "NaN" - не число в любом основании системы счисления. Вы можете вызывать функцию isNaN, чтобы определить,является ли результат parseFloat "NaN".
  <br>Функция <i>parseInt</i> анализирует строковый аргумент, и возвращает целое число, основанное на указанном основании системы счисления. Например, при параметре radix, равном 10, string преобразовывается в десятичное число, при 8 - преобразовывается в восьмеричное и при 16 - в шестнадцатеричное. Значения, большие 10, для оснований, превышающих 10, представляются символами от А до F вместо чисел. Использование radix, равного 2, служит для преобразований в двоичные числа. Числа с плавающей запятой будут преобразованы в целые числа. Правила обработки строки идентичны правилам для parseFloat. Если <i>parseInt</i> сталкивается с сиволом, который - не символ в указанном основании системы счисления, то игнорирует его и возвращает значение целого числа, анализируемую до того пункта. Если первый символ не может быть преобразован к символу в указанном основании системы счисления, то возвращает NaN. <i>parseInt</i> усекает числа до значения целого числа.</p>
  </div>
  <br>
  
  <br>
  <a href="index.html">Вернуться на главную страницу</a>
</body>
</html>