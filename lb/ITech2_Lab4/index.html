<!DOCTYPE HTML>
<html>
<head>
	<title>Лабораторная работа №4</title>
	<meta charset="utf-8">
	<meta name="description " content="Версия 2019.05.02. Методические указания для выполнения лабораторной работы по курсу ИТех2 для потока КИ.">
	<link rel="stylesheet" type="text/css" href="styles.css">
</head>
<body>
	<div id="container">
		<div id="chapters">
			<h1 id="start">Лабораторная работа №4 (2018-2019)</h1>
			<div id="lab_theme">Полнодуплексный обмен данными между браузером и веб-сервером на основе протокола передачи данных WebSocket
			</div>
			<ul>
				<li><a href="#lab_goal">Цель работы</a></li>
				<li><a href="#lab_manual">Методические указания</a></li>
				<li><a href="#lab_software">Описание лабораторной установки</a></li>
				<li><a href="#lab_execution">Порядок выполнения работы</a></li>
				<li><a href="#lab_variants">Варианты заданий</a></li>
				<li><a href="#lab_report">Содержание отчета</a></li>
				<li><a href="#lab_questions">Контрольные вопросы</a></li>
				<li><a href="#lab_literature">Дополнительные источники</a></li>
			</ul>
		</div>
			
		<div class="chapter" id="lab_goal">
			<span class="chapter_name">4.1 Цель работы</span>
			<p>Исследование программных средств для обмена сообщениями между браузером и веб-сервером в режиме реального времени.</p>
		</div>
		
		<div class="chapter" id="lab_manual">
			<span class="chapter_name">4.2 Методические указания</span>
			<p>При подготовке к выполнению лабораторной работы следует ознакомиться с механизмом обмена сообщениями по протоколу WebSocket, а также событиями и методами библиотеки socket.iо для коллективного обмена сообщениями.</p>
			<p>Протокол HTTP ограничен моделью запрос-ответ: клиент посылает HTTP-запрос и ожидает на него HTTP-ответ от сервера. По сути, сервер не может сообщить что-либо клиенту до тех пор, пока клиент «у него не спросит».</p>
			<p>WebSocket – протокол полнодуплексной связи поверх TCP-соединения, предназначенный для обмена сообщениями между браузером и веб-сервером в режиме реального времени. Благодаря возможности отправки сервером данных клиенту без предварительного запроса в привычной схеме запрос-ответ, между браузером и сервером может происходить равноправный двусторонний (двунаправленный) обмен сообщениями, пока соединение открыто. Протокол WebSocket предоставляет значительно меньшие накладные расходы за счет постоянно открытого канала по сравнению с повторяющимися обращениями к серверу для отслеживания изменений. </p>
			<p>Организация такого взаимодействия между браузером и веб-сервером дает возможность создавать интернет-приложения с интенсивным обменом данными, требовательные к скорости обмена, например, игры.</p>
			<p>Прежде чем начать использовать протокол WebSocket, требуется создать веб-сервер, поддерживающий этот протокол - например, на основе серверного JavaScript-фреймворка Node.js. Для упрощения работы с WebSocket используется библиотека Socket.io, которая скрывает от разработчика низкоуровневую работу с передачей сообщений. Опция transports, настраиваемая на стороне сервера, позволяет ограничить используемые способы передачи - WebSocket, htmlfile, xhr-polling, jsonppolling. По умолчанию используется WebSocket, если он поддерживается участниками обмена сообщениями.</p>	
			<p>Транспорты выбираются в следующей последовательности:<ul>
				<li>WebSocket;</li>
				<li>Adobe Flash Socket;</li>
				<li>AJAX multipart streaming;</li>
				<li>AJAX long polling;</li>
				<li>Iframe(только в IE);</li>
				<li>JSONP Polling.</li>
			</ul></p>
			<p>Ниже приведены примеры выбора на стороне сервера в качестве транспорта протокола WebSocket или нескольких протоколов с использованием метода socket.set(key, value).</p>
			<pre>
	// подключаем модуль для создания сервера
	// и ставим на прослушивание 80-порта
	var io = require('socket.io').listen(80); 
	
	//Способ 1
	/// отключаем вывод полного лога
	io.set('log level', 1);
	//ограничиваем транспорт только протоколом WebSocket
	io.set('transports', ['websocket']); 
	
	//Способ 2
	io.configure(function () {
	io.set('transports', ['websocket', 'flashsocket', 'xhr-polling']);
	});
	
	//Способ 3
	io.configure('development', function () {
	io.set('transports', ['websocket', 'xhr-polling']);
	});
			</pre>
			<p>Подключение WebSocket на веб-сервере осуществляется посредством следующей функции:</p>				
			<pre>
var port = 8080;
	//открываем соединение
	//с установленной опцией разрешенных методов транспорта
	var io = require('socket.io').listen(port, {'transports': ['websocket']});
	io.sockets.on('connection', function (socket) {
	socket.emit('news', { hello: 'world' });
	socket.on('my other event', function messageReceived(data) { console.log(data); });
	});
			</pre>
			<p>Подключение WebSocket на клиенте осуществляется посредством функции connect. Пример использования библиотеки socket.io на стороне клиента:</p>				
			<pre>
&lt;!DOCTYPE html&gt;
	&lt;html&gt;&lt;head&gt;
	&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
	&lt;!-- Подключаем библиотеку, именно таким способом: запрашиваем ее со стороны сервера, где она динамически генерируется. --&gt;
	&lt;script src="http://localhost:8080/socket.io/socket.io.js"&gt;&lt;/script&gt;
	&lt;script&gt;
	//адрес сервера
	var serverURL = 'http://localhost:8080';
	var socket = io.connect(serverURL, { 'connect timeout': 5000 });
	socket.on('news', function (data) {
	console.log(data);
	socket.emit('my other event', { my: 'data' });
	});
	&lt;/script&gt;
	&lt;/head&gt;
	&lt;/html&gt;
			</pre>
			<p>События на стороне клиента и сервера, которые посылаются в случае установления подключения, переподключения и закрытия соединения. На стороне сервера,  предполагая, <pre> var io = require('socket.io'):</pre></p>
			<p><ul>
		<li><pre>io.sockets.on('connection', function(socket) {})</pre>  - начальное соединение от клиента.
Аргумент socket должен быть использован в дальнейшей коммуникации с клиентом.</li>
		<li><pre>socket.on('disconnect', function() {}) </pre> - событие разъединения срабатывает во всех случаях, когда соединение клиент-сервер закрыто. Срабатывает в случаях желательного, нежелательного, мобильного, не мобильного, клиентского и серверного отключения. Не существует события восстановления связи. Вы должны использовать событие "connection " для восстановления управляемости.</li>
	</ul></p>
			<p>События на стороне клиента и сервера, которые посылаются в случае установления подключения, переподключения и закрытия соединения. На стороне клиента, предполагая, <pre>socket = io.connect (host, options):</pre></p>
			<p><ul>
		<li>В случае первого подключения:</li>
		<ul>
			<li><span class = "code_snippet">socket.on('connect', function () {})</span> – событие "connect" посылается, когда сокет
успешно подключен;</li>
			<li><span class = "code_snippet">socket.on('connecting', function () {})</span> - событие "connecting" посылается, когда сокет пытается подключиться к серверу;</li>
		</ul>
		<li>При моментальной потере соединения:</li>
		<ul>
			<li><span class = "code_snippet">socket.on('disconnect', function () {})</span> - событие "disconnect" посылается, когда сокеты отключены;</li>
			<li><span class = "code_snippet">socket.on('reconnecting', function () {})</span> - событие "reconnecting" посылается при попытке сокета восстановить связь с сервером;</li>
			<li><span class = "code_snippet">socket.on('connect_failed', function () {}) </span> - событие "connect_failed" посылается, когда socket.io не может установить соединение с сервером и не имеет других вариантов транспорта;</li>
			<li><span class = "code_snippet">socket.on('reconnect_failed', function () {})</span> - событие "reconnect_failed" посылается, когда socket.io не удается восстановить рабочую связь после того как подключение было прекращено;</li>
			<li><span class = "code_snippet">socket.on('reconnect', function () {})</span> - событие "reconnect" посылается, когда socket.io успешно повторно подключился к серверу;</li>
		</ul>
		<li>При полной потере соединения:</li>
		<ul>
			<li><span class = "code_snippet">socket.on('disconnect', function () {})</span> - событие "disconnect" посылается, когда сокеты отключены;</li>
			<li><span class = "code_snippet">socket.on('reconnecting', function () {})</span> - событие "reconnecting" посылается, когда сокет пытается восстановить связь с сервером.
		</ul>
	</ul></p>
			<p>Закрыть соединение имеется возможность у любой из сторон, как сервера и/или браузера, поскольку в итоге существует только одно соединение. При возникновении ошибки можно воспользоваться событием на стороне клиента: <span class = "code_snippet"> socket.on('error', function () {}) </span> - событие "error" посылается, когда возникает ошибка, которая не может быть обработана другими типами событий.</p>		
<p>Отправка данных к клиенту. Метод socket.send выполняет передачу сообщения text на основе базового события "message": <span class = "code_snippet"> socket.send(text).</span>	Передача клиентам сообщения в формате JSON позволяет генерировать на клиенте легко изменяемые данные меньшего обьема, представление которых не зависит от сервера.</p>
<p>На сервере существует возможность выбора «текущего» клиента с помощью socket, так и выбора всех подключенных клиентов с помощью io.sockets. Таким образом, если вы хотите отправить сообщение любому вы можете ссылаться на io.sockets:<span class = "code_snippet">io.sockets.send('сообщение');</span><span class = "code_snippet">io.sockets.emit('событие');</span></p>
			<p>Получение событий. При возникновении события event метода socket.on(event, callback) выполняется вызов функции callback. На клиенте, предполагая, socket = io.connect (host, options):</p>
		<p><ul>
			<li>socket.on('message', function (message, callback) {}) - событие "message"
выполняется в случае, когда получено сообщение, посланное с socket.send. Сообщение
«message» означает, что отправлено сообщение, и функция обратного вызова является
дополнительной функцией подтверждения;</li>
			<li>socket.on('anything', function(data, callback) {}) - событие "anything" может быть
любым пользовательским событием, кроме резервных .Аргумент data и функция
обратного вызова может быть использованы для отправки ответа.</li>
		</ul></p>
		
		<p>На стороне сервера, предполагая, var io = require('socket.io'): </p>
		<p><ul>
			<li>socket.on('message', function(message, callback) {}) - событие "message"
выполняется в случае, когда получено сообщение, посланное с socket.send. Сообщение
"message" означает, что отправлено сообщение, и функция обратного вызова является
дополнительной функцией подтверждения;</li>
			<li>socket.on('anything', function(data) {}) - событие "anything" может быть любым
событием, кроме резервных.</li>
		</ul></p>
		
		<p>Пример получения события: socket.on('whereami', function(loc){ console.log('I\'m in ' + loc + '!'); }))</p>

		<p>Широковещательная передача сообщений. В socket.io имеется возможность отправить сообщение из отдельного сокета к остальной части сокетов, используя флаг broadcast:</p>		
		<pre>
		socket.broadcast.send('сообщение');
		socket.broadcast.emit('событие'[, arguments]);
		</pre>		
		<p>Пример отправка сообщения всем клиентам, кроме текущего:</p>
		<pre>socket.broadcast.emit('message', "this is a test");</pre>
		<p>Отправка и передача сообщений отдельному сокету</p>		
		<p>Кроме того, имеется в наличии средства выбора конкретно взятого клиента с
заданным идентификатором ID:</p>
		<pre>
		io.sockets.socket(< id>).send('мое сообщение')
		io.sockets.socket(< id>).emit('имя события'[, arguments])
		</pre>		
		<p>На клиентской стороне socketid получают с помощью:</p>		
		<pre>
		var io = io.connect('localhost');
		io.on('connect', function () {
			console.log(this.socket.id);
		});
		</pre>
		</div>
		
		<div class="chapter" id="lab_software">
			<span class="chapter_name">4.3 Описание лабораторной установки</span>
			<p>Для выполнения лабораторной работы рекомендуется использовать:</p>
			<ul>
				<li>текстовый редактор, имеющий подсветку синтаксиса: Notepad++ или Visual Studio Code;</li>
				<li>браузер: Mozilla Firefox или Google Chrome;</li>
				<li>серверная платформа NODE.js;</li>
				<li>пакет socket.io;</li>
				<li>сборка веб-сервера: XAMPP или OpenServer.</li>
			</ul>
			<p>Рекомендуемые средства являются свободным программным обеспечением.</p>
			<p>Для выполнения лабораторной работы не требуется доступ к сети Интернет.</p>
		</div>
		
		<div class="chapter" id="lab_execution">
			<span class="chapter_name">4.4 Порядок выполнения работы</span>
			<ol>
				<li>Создать,  выполнить  и  убедиться  в  работоспособности  клиентской  и  серверной частей приложения «Чат», реализованного с использованием пакета socket.io.</li>
				<li>Реализовать  систему  реального  времени,  состоящую  из  клиентской  и  серверной частей.
				</li>
			</ol>
			<!-- <p>Результат работы демонстрируется в электронном виде.</p> -->
		</div>
		
		<div class="chapter" id="lab_variants">
			<span class="chapter_name">4.5 Варианты заданий</span>
			<ol>
				<li>Диспетчер такси. Клиентская  часть  предоставляет  возможность  выбора  машины  и  частоты обновления  данных,  а  также  получает  от  сервера  данные  о перемещении  такси, благодаря  расположенному  в  нем GPS-трекеру  (идентификатор  машины,  водитель,измерения  широты  и  долготы промежуточных точек маршрута, скорость  движения, текущие  измерения  широты  и  долготы)  и  отображает  их  пользователю.  Сервер генерирует данные выбранной машины с заданным интервалом.</li>
				<li>Система производственно-экологического мониторинга. Клиентская часть предоставляет возможность выбора санитарно-защитной зоны и частоты обновления данных, а также получает от сервера данные замеров 		стационарных и  мобильных  постов  экологического  мониторинга  (метеорологического  контроля, химического  контроля,  пылемеров,  анализаторов  воды  и  почвы).  Сервер  генерирует данные дистанционного зондирования выбранной санитарно-защитной зоны с заданным интервалом.</li>
				<li></li>
				<li>Мониторинг погоды. Клиентская  часть  предоставляет  возможность  выбора  населенного  пункта  и частоты обновления данных, 
			а также получает от сервера данные о погодных условиях (текущая  температура,осадки, уровень  давления,  скорость  ветра)  и  отображает  их 
			пользователю.  Сервер  генерирует  данные  о  погодных  условиях  выбранного  города  с заданным интервалом.</li>
				<li>Биржа. Клиентская часть предоставляет возможность выбора биржевого товара и частоты обновления данных, а также получает от сервера данные о предложенных контрактах, формируемых  в  течение дня  (компания,  цена  на  единицу  товара,  количество  товара, покупка  или  продажа). Сервер  генерирует  данные о предложенных  контрактах  с заданным интервалом.</li>
				<li>Система поддержания жизнедеятельности. Клиентская часть предоставляет возможность выбора объекта для исследования и частоты  обновления данных,  
			а  также  получает  от  сервера  данные от  датчиков среды (химический состав, температура, влажность, излучение) и отображает их пользователю. 
			Сервер генерирует данные датчиков с заданным интервалом, а также выводит сообщение об угрозе жизни для объекта.</li>
				<li>Обучающая система «Организм человека». Клиентская часть предоставляет возможность выбора органа человека и его состояния , а также получает от сервера данные об общих физиологических показателях организма (общее количество лейкоцитов, тромбоцитов, эритроцитов, скорость оседания эритроцитов, количество белков, выделяемые гормоны) и отображает их пользователю. Сервер генерирует  данные о физиологических показателях  организма с  заданным интервалом.</li>
			</ol>
			<!-- <p>Результат работы демонстрируется в электронном виде.</p> -->
		</div>
		
		<div class="chapter" id="lab_report">
			<span class="chapter_name">4.6 Содержание отчета</span>
			<ul>
				<li>титульный лист с указанием темы лабораторной, фамилии, инициалов и группы выполнивших студентов (до 3-х человек)</li> 
				<li>цель работы</li> 
				<li>вариант задания</li>
				<li>исходные коды серверного и клиентского JS-скриптов</li>
				<li>результаты выполнения в виде снимков экрана браузера</li>
				<li>выводы по работе</li>
			</ul>
			<p>Допускается сдача отчета в электронном виде. Для защиты наличие распечатанного отчета не является необходимым.</p>
		</div>
		
		<div class="chapter" id="lab_questions">
			<span class="chapter_name">4.7 Контрольные вопросы</span>
			<ol>
				<li>Сравните работу соединения посредством HTTP Long polling с протоколом WebSocket.</li>
				<li>Опишите процесс создания соединения WebSocket на стороне клиента и сервера, а также его закрытия</li>
				<li>Перечислите клиентские и серверные события, выполняемые при создании соединения или его переподключении.</li>
				<li>Каким образом осуществляется обмен данными между клиентом и сервером с применением методов пакета socket.io? Приведите примеры.</li>
				<li>Каким образом существует возможность отправки ответа всем клиентам кроме отправителя?</li>
				<li>Перечислите методы для отправки и получения данных формата JSON.</li>
				<li>Поясните механизм создания комнат.</li>
			</ol>
			<p>Знание ответов на приведенные вопросы является необходимым, но не достаточным условием для получения высокой оценки за защиту лабораторной работы. Помните про темы, рассмотренные на лекциях!</p>
		</div>
		
		<div class="chapter" id="lab_literature">
			<span class="chapter_name">СПИСОК ЛИТЕРАТУРЫ</span>
			<ol>  
				<li><a href="https://docs.angularjs.org/api" target="_blank">AngularJS API Docs</a></li>
				<li><a href="https://metanit.com/web/angular/" target="_blank">Онлайн-руководство по AngularJS</a></li>
				<li><a href="https://blog.csssr.ru/2015/11/24/ng-options" target="_blank">Описание использования выпадающих списков</a></li>
				<li><a href="https://habr.com/ru/post/172975/" target="_blank">AngularJS для привыкших к jQuery</a></li>
				<li><a href="https://habr.com/ru/post/167793/" target="_blank">Валидация форм в AngularJS</a></li>
				<!-- <li>Джордж Шлосснейгл "Профессиональное программирование на PHP".</li>
				<li>Кевин Янк "PHP и MySQL. От новичка к профессионалу".</li> -->
			</ol>
		</div>		
		<br><a href="#start">Вернуться к началу</a>
		<!-- Удачной отработки! --> 
	</div>	
</body>
</html>