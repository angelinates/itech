<!Doctype html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PHP на русском: Учебник по PHP (HandBook)</title>
<meta name="keywords" content='manual, handbook, book, php,php, php5, apache, mysql, session, скрипты, скачать, download, программирование, web технологии, php6, php4, функции php' />
<meta name="description" content=' Сайт посвящен документации по PHP. Руссифицированное руководство с примерами на PHP. Фреймворки, шаблонизаторы, набор часто употребляемых функций.' />
<meta name="language" content="russian"><meta http-equiv="Content-language" content="ru">
<link href="/default.css" rel="stylesheet" type="text/css" />
<link href='/Manual.css' rel="stylesheet" type="text/css" />
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
<script src="/core.js" type="text/javascript"></script>
</head>
<body>
<div id="header" class="clear">
 <div id="logo">
  <h1><a href="/" name="top">PHP5</a></h1>
  <h2><a href="/">Для web разработчика</a></h2>
 </div>
 <div id="adv728"><a title="Рекламная площадка 728x90"><!-- UBN 728 START --><script>//<!--
ubn_user = "57336";
ubn_page = "1";
ubn_pid = Math.round((Math.random() * (10000000 - 1)));
document.write("<iframe src='http://banner.kiev.ua/cgi-bin/bi.cgi?h" +
ubn_user + "&amp;"+ ubn_pid + "&amp;" + ubn_page + 
"&amp;12' frameborder=0 vspace=0 hspace=0 " +
" width=728 height=90 marginwidth=0 marginheight=0 scrolling=no>");
document.write("<a href='http://banner.kiev.ua/cgi-bin/bg.cgi?" +
ubn_user + "&amp;"+ ubn_pid + "&amp;" + ubn_page + "' target=_blank>");
document.write("<img border=0 src='http://banner.kiev.ua/" +
"cgi-bin/bi.cgi?i" + ubn_user + "&amp;" + ubn_pid + "&amp;" + ubn_page +
"&amp;12' width=728 height=90 alt='UBN'></a>");
document.write("</iframe>");
//-->
</script></a></div>
</div>
<div id="navigator" class="clear">
 <div id="current">
   <h3><div class="post-date"><span class="post-month">May</span>
 <span class="post-day">07</span></div>Учебник по PHP (HandBook)</h3>
 </div>
 <div id="menu">
  <ul>
   <li class="first"><a href="/" accesskey="1" title="Главная страница PHP портала">Главная</a></li>
   <li class="active"><a href="/manual/ru/" accesskey="2" title="Руководство по PHP 5.3">Руководство PHP</a></li>
   <li><a href="/smarty/" accesskey="3" title="Smarty Framework">Smarty</a></li>
   <li><a href="/pear/" accesskey="4" title="Pear Framework">Pear</a></li>
   <li><a href="/zend/" accesskey="5" title="Zend Framework">Zend</a></li>
   <li><a href="/phpdoc/" accesskey="6" title="phpDocumentor">phpDoc</a></li>
   <li><a href="/mysql/40/" accesskey="7" title="СУБД MySQL">Mysql</a></li>
   <li><a href="/pgsql/" accesskey="8" title="СУБД PostgreSQL">Pgsql</a></li>
   <li><a href="/contacts.html" accesskey="9" title="Контактная информация">Контакты</a></li>
  </ul>
 </div>
</div>

<!-- RotaBan -->
<script type="text/javascript">
(function(){
    var rb = document.createElement('script');
        d = new Date();
    d.setHours(0);
    d.setMinutes(0);
    d.setSeconds(0);
    d.setMilliseconds(0);
    rb.type = 'text/javascript';
    rb.async = true;
    rb.src = '//s1.rotaban.ru/rotaban.js?v=' + d.getTime();
    (document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(rb);
})();
</script>

<div id="content">


<p><a name=introduction><b>Глава 1. Введение</b></a>

<h3>Содержание</h3>
<ul>
 <li><a href='#intro-whatis'>Что такое PHP?</a></li>
 <li><a href='#intro-whatcando'>Возможности PHP</a></li>
</ul>

<h3><a name=intro-whatis>Что такое PHP?</a></h3>
<dl compact>
 <dt><dfn>PHP</dfn></dt>
 <dd> (рекурсивный акроним словосочетания &quot;PHP: Hypertext
 Preprocessor&quot;) - это широко используемый язык программирования общего
 назначения с открытым исходным кодом. PHP сконструирован
 специально для ведения Web-разработок и может внедряться в HTML-код.</dd>
</dl>

<p>Простой ответ, но что он может означать? Вот пример:</p>

<p><a name=AEN94></a><b>Пример 1-1. Пример программирования на PHP</b></p>
<div class="cdata">&lt;html&gt;<br>
    &nbsp; &nbsp; &lt;head&gt;<br>
    &nbsp; &nbsp; &nbsp; &nbsp; &lt;title&gt;Пример &lt;/title&gt;<br>
    &nbsp; &nbsp; &lt;/head&gt;<br>
    &nbsp; &nbsp; &lt;body&gt;<br>
    <br>
    &nbsp; &nbsp; &nbsp; &lt;?php <br>
    &nbsp; &nbsp; &nbsp; echo &quot;Привет, я - скрипт PHP!&quot;; <br>
    &nbsp; &nbsp; &nbsp; ?&gt;<br>
    <br>
    &nbsp; &nbsp; &lt;/body&gt;<br>
    &lt;/html&gt;
</div>

<p>Обратите внимание на отличие этого скрипта от скриптов,
написанных на других языках, например, на Perl или C - вместо того, чтобы
создавать программу, которая занимается формированием HTML-кода и содержит
бесчисленное множество предназначенных для этого команд, вы создаете HTML-код с
несколькими внедренными командами PHP (в приведенном случае, предназначенными
для вывода текста). Код PHP отделяется специальными начальным и конечным тегами,
которые позволяют процессору PHP определять начало и конец участка HTML-кода,
содержащего PHP-скрипт.</p>

<p>Значительным отличием PHP от какого-либо кода,
выполняющегося на стороне клиента, например, JavaScript, является то, что
PHP-скрипты выполняются на сервере. Если бы у вас на сервере был размещен
скрипт, подобный вышеприведенному, клиент получил бы
только результат выполнения скрипта, причем он не смог бы выяснить, какой
именно код выполняется. Вы даже можете сконфигурировать свой сервер таким
образом, чтобы HTML-файлы обрабатывались процессором PHP, так что клиенты даже
не смогут узнать, получают ли они обычный HTML-файл или результат выполнения
скрипта.</p>

<p>PHP крайне прост для освоения, но вместе с тем способен
удовлетворить запросы профессиональных программистов. После того, как вы
впервые услышали о PHP, и открыли это руководство, в течение нескольких часов
вы уже сможете создавать простые PHP-скрипты.</p>

<p>Хотя PHP, главным образом, предназначен для работы в среде
web-серверов, область его применения не ограничивается только этим. Читайте
дальше и не пропустите главу Возможности PHP.</p>

<p><a name=intro-whatcando></a><b>Возможности PHP</b></p>

<p>PHP может все. Главным образом, область применения PHP
сфокусирована на написание скриптов, работающих на стороне сервера; таким
образом, PHP способен выполнять всё то, что выполняет
любая другая программа CGI, например, обрабатывать данных форм, генерировать
динамические страницы или отсылать и принимать cookies. Но PHP способен выполнять и множество других задач.</p>

<p>Существуют три основных области, где используется PHP.</p>

<ul type=disc>
 <li>Создание скриптов для
     выполнения на стороне сервера. PHP наиболее широко используется именно
     таким образом. Все, что вам понадобится, это парсер PHP (в виде программы
     CGI или серверного модуля), вебсервер и броузер. Чтобы вы могли
     просматривать результаты выполнения PHP-скриптов в броузере, вам нужен
     работающий вебсервер и установленный PHP. За более подробными сведениями
     обратитесь к главе Советы по установке. </li>
 <li>Создание скриптов для
     выполнения в командной строке. Вы можете создать PHP-скрипт, способный
     запускаться вне зависимости от вебсервера и броузера. Все, что вам
     потребуется - парсер PHP. Такой способ использования PHP идеально подходит
     для скриптов, которые должны выполняться регулярно, например, с помощью
     cron (на платформах *nix или Linux) или с помощью планировщика задач (Task
     Scheduler) на платформах Windows. Эти скрипты также могут быть
     использованы в задачах простой обработки текстов. За дополнительной
     информацией обращайтесь к главе Использование PHP
     в среде командной строки. </li>
 <li>Создание приложений
     GUI, выполняющихся на стороне клиента. Возможно, PHP
     является не самым лучшим языком для создания подобных приложений, но, если
     вы очень хорошо знаете PHP и хотели бы использовать некоторые его
     возможности в своих клиент-приложениях, вы можете использовать PHP-GTK для
     создания таких приложений. Подобным образом вы можете создавать и кросс-платформенные приложения. PHP-GTK является
     расширением PHP и не поставляется вместе с дистрибутивом PHP. Если вы
     заинтересованы, посетите сайт PHP-GTK. </li>
</ul>

<p>PHP доступен для большинства
операционных систем, включая Linux, многие модификации Unix (такие, как HP-UX,
Solaris и OpenBSD), Microsoft Windows, Mac OS X, RISC OS, и многих других. 
(Совершенно точно, что существует версия PHP для OS/2.
Неизвестно, правда, насколько соответствующая нынешним реалиям - Прим.перев.) Также в PHP включена поддержка большинства
современных вебсерверов, таких, как Apache, Microsoft Internet Information
Server, Personal Web Server, серверов Netscape и iPlanet, сервера Oreilly
Website Pro, Caudium, Xitami, OmniHTTPd и многих других. Для большинства
серверов PHP поставляется в качестве модуля, для других, поддерживающих
стандарт CGI, PHP может функционировать в качестве процессора CGI.</p>

<p>Таким образом, выбирая PHP, вы получаете свободу выбора
операционной системы и вебсервера. Кроме того, у вас появляется выбор между
использованием процедурного или объектно-ориентированного программирования или
же их сочетания. Несмотря на то, что текущая версия PHP поддерживает не все
особенности ООП, многие библиотеки кода и большие приложения (включая
библиотеку PEAR) написаны только с использованием ООП.</p>

<p>PHP способен не только выдавать HTML. Возможности PHP
включают формирование изображений, файлов PDF и даже роликов Flash (с
использованием libswf и Ming), создаваемых &quot;на лету&quot;. PHP также способен выдавать любые текстовые данные, такие, как XHTML и
другие XML-файлы. PHP способен осуществлять
автоматическую генерацию таких файлов и сохранять их в файловой системе вашего
сервера вместо того, чтобы отдавать клиенту, организуя, таким образом, кеш
динамического содержания, расположенный на стороне сервера.</p>

<p>Одним из значительных преимуществ PHP является поддержка
широкого круга баз данных. Создание скрипта, использующего
базы данных, - невероятно просто. В настоящее время PHP поддерживает следующие
базы данных: <a name=AEN121></a></p>

<ul>
  <li>Adabas D</li>
  <li>Ingres</li>
  <li>Oracle (OCI7 и OCI8)</li>
  <li>dBase</li>
  <li>InterBase</li>
  <li>Ovrimos</li>
  <li>Empress</li>
  <li>FrontBase</li>
  <li>PostgreSQL</li>
  <li>FilePro (только чтение)</li>
  <li>mSQL</li>
  <li>Solid</li>
  <li>Hyperwave</li>
  <li>Direct MS-SQL</li>
  <li>Sybase</li>
  <li>IBM DB2</li>
  <li>MySQL</li>
  <li>Velocis</li>
  <li>Informix</li>
  <li>ODBC</li>
  <li>Unix dbm</li>
</ul>

<p>Также в PHP включена поддержка DBX
для работы на абстрактном уровне, так что вы можете работать с любой базой
данных, использующих DBX. Кроме того, PHP поддерживает ODBC (Open Database
Connection standard), таким образом, вы можете работать с любой базой данных,
поддерживающей этот всемирно признанный стандарт.</p>

<p>PHP также поддерживает &quot;общение&quot; с другими
сервисами с использованием таких протоколов, как LDAP, IMAP, SNMP, NNTP, POP3,
HTTP, COM (на платформах Windows) и многих других. Кроме того, вы получаете
возможность работать с сетевыми сокетами &quot;напрямую&quot;. PHP поддерживает
стандарт обмена сложными структурами данных WDDX. Обращая внимание на
взаимодействие между различными языками, следует упомянуть о поддержке объектов
Java и возможности их использования в качестве объектов PHP. Для доступа к
удаленным объектам вы можете использовать расширение CORBA.</p>

<p>PHP включает средства обработки текстовой информации,
начиная с регулярных выражений Perl или POSIX Extended и заканчивая парсером
документов XML. Для парсинга XML используются стандарты SAX и DOM. Для
преобразования документов XML вы можете использовать расширение XSLT.</p>

<p>Используя PHP в области электронной коммерции, вы обратите
внимание на функции осуществления платежей Cybercash, CyberMUT, VeriSign
Payflow Pro и CCVS.</p>

<p>Последним по порядку, но не по значению, является поддержка
многих других расширений, таких, как функции поисковой машины mnoGoSearch,
функции IRC Gateway, функции для работы со сжатыми файлами (gzip, bz2), функции
календарных вычислений, функции перевода...</p>

<p>Как вы видите, этой страницы не хватит для того, чтобы
перечислить все, что может предложить вам PHP. Читайте следующую главу, Установка PHP и
обратитесь к главе Справочник по функциям за более подробными сведениями о перечисленных выше
расширениях.</p>

<p><a name=tutorial><b>Глава 2. Краткое руководство</b></a></p>

<p><b>Содержание</b></p>

<p>Что потребуется?</p>

<p>Первая страница на PHP</p>

<p>Делаем что-нибудь полезное</p>

<p>Работа с формами</p>

<p>Использование старых программ с
новыми версиями PHP</p>

<p>Что дальше?</p>

<p>В данном кратком руководстве на примерах объясняются основы
PHP. Это руководство включает в себя только создание динамических Web-страниц с
помощью PHP, однако реальная область применения PHP гораздо шире. В разделе
&quot;Что может PHP&quot; приведена дополнительная информация.</p>

<p>Созданные с использованием PHP Web-страницы обрабатываются, как
обычные HTML-страницы. Их можно создавать и изменять точно таким же образом,
как и обычные страницы на HTML.</p>

<p><a name=tutorial.requirements></a><b>Что потребуется?</b></p>

<p>В данном руководстве мы предполагаем, что ваш сервер имеет
поддержку PHP и что все файлы, заканчивающиеся на .php, обрабатываются PHP. В
большинстве серверов это расширение используется для PHP по умолчанию, но
все-таки не лишним будет уточнить это у вашего администратора сервера. Если ваш
сервер поддерживает PHP, то у вас есть все, что требуется. Просто создавайте
ваши файлы .php и
размещайте их в вашем каталоге Web-сервера - они будут обрабатываться
автоматически. Не нужно ничего компилировать, не нужно никаких дополнительных
программ. Считайте файлы PHP обычными файлами HTML с набором новых
&quot;волшебных&quot; тегов, которые позволяют вам делать все, что угодно.</p>

<p><a name=tutorial.firstpage></a><b>Первая страница на PHP</b></p>

<p>Создайте файл с именем hello.php в корневом каталоге ваших документов Web-сервера и
запишите в него следующее:</p>

<p><a name=AEN166></a><b>Пример 2-1. Первый скрипт на PHP:</b> <b>hello.php</b></p>
<div class="cdata">&lt;html&gt;<br>
    &lt;head&gt;<br>
    &nbsp; &lt;title&gt;Тестируем PHP&lt;/title&gt;<br>
    &lt;/head&gt;<br>
    &lt;body&gt;<br>
    &lt;?php echo &quot;Привет!&lt;p&gt;&quot;; ?&gt;<br>
    &lt;/body&gt;<br>
    &lt;/html&gt;</div>
  <p>Эта программа выведет следующее:</p>
    <div class="cdata">
    &lt;html&gt;<br>
     &lt;head&gt;<br>
     
    &lt;title&gt;Тестируем PHP&lt;/title&gt;<br>
     &lt;/head&gt;<br>
     &lt;body&gt;<br>
     Привет!&lt;p&gt;<br>
     &lt;/body&gt;<br>
    &lt;/html&gt;
</div>

<p>Заметим, что сходства со скриптами на CGI нет. Файл не
обязан быть выполнимым или отмеченным любым другим образом. Это просто обычный
файл HTML, в котором есть набор специальных тегов, делающих много интересного.</p>

<p>Эта программа чрезвычайно проста, и для создания настолько
простой странички даже необязательно использовать PHP. Все что она делает - это
выводит &quot;Привет!
с использованием функции PHP <b>echo()</b>.</p>

<p>Если у вас этот пример не отображает ничего или выводит
окно загрузки, или если вы видите весь этот файл в текстовом виде, то весьма
вероятно, что ваш Web-сервер не имеет поддержки PHP. Попросите вашего
администратора сервера включить такую поддержку. Предложите ему инструкцию по
установке - раздел &quot;Установка&quot; данной документации. Если же вы хотите разрабатывать
скрипты на PHP дома, то вам в раздел необходимые файлы. Дома
можно разрабатывать скрипты с использованием любой операционной системы, но вам
понадобится установить соответствующий Web-сервер.</p>

<p>Цель примера - показать формат специальных тегов PHP. В
этом примере мы использовали &lt;?php в качестве открывающего тега, затем шли команды PHP,
завершающиеся закрывающим тегом ?&gt;. Таким образом
можно сколько угодно раз переходить к коду PHP в файле HTML.</p>

<p><b>Пара слов о текстовых редакторах: </b>Существует множество текстовых редакторов и интегрированных
сред разработки (IDE), в которых вы можете создавать и редактировать файлы PHP.
Список некоторых редакторов содержится в разделе &quot;Список редакторов PHP&quot;.
Если вы хотите порекомендовать какой-либо редактор, посетите данную страницу и
попросите добавить данный редактор в список.</p>

<p><b>Пара слов о текстовых процессорах: </b>Текстовые процессоры (StarOffice Writer, Microsoft Word,
Abiword и др.) в большинстве случаев не подходят для редактирования файлов PHP.
</p>

<p>Если вы используете текстовый процессор для создания
скриптов на PHP, вы должны быть уверены, что сохраняете файл, как ЧИСТО
ТЕКСТОВЫЙ. В противном случае PHP не сможет обработать и выполнить вашу
программу.</p>

<p><b>Пара слов о &quot;Блокноте&quot; Windows: </b>При написании скриптов PHP с использованием встроенного
&quot;Блокнота&quot; Windows необходимо сохранять файлы с расширением .php.
&quot;Блокнот&quot; автоматически добавляет расширение .txt. Для обхода этой
проблемы существует несколько методов.</p>

<p>Можно поместить название файла в кавычки (пример:&quot;hello.php&quot;).</p>

<p>Кроме того, можно выбрать &quot;Все файлы&quot; вместо &quot;Текстовые
документы&quot; из ниспадающего списка с типами файлов в окне сохранения. После
этого можно вводить имя файла без кавычек.</p>

<p><a name=tutorial.useful></a><b>Делаем что-нибудь полезное</b></p>

<p>Давайте сделаем что-нибудь полезное. К примеру, определим,
какой браузер использует тот, кто смотрит в данный момент нашу страницу. Для
этого мы проверим строку с именем браузера, посылаемую нам в HTTP-запросе. Эта
информация хранится в переменной. Переменные в PHP всегда предваряются знаком доллара.
Интересующая нас в данный момент переменная называется $_SERVER[&quot;HTTP_USER_AGENT&quot;].</p>

<p><b>Пару слов об автоматической
глобализации переменных в PHP: </b>$_SERVER - специальная зарезервированная переменная PHP, которая
содержит всю информацию, полученную от Web-сервера. Она является
автоглобализованной (или суперглобальной). Для более подробной информации
смотрите раздел &quot;Суперглобальные
переменные&quot;. Эти специальные переменные
появились в PHP, начиная с версии 4.1.0. До этого использовались массивы $HTTP_*_VARS, такие, как $HTTP_SERVER_VARS. Эти массивы,
несмотря на то, что они уже устарели, до сих пор существуют (см. замечания по старым программам).</p>

<p>Для вывода данной переменной мы сделаем так:</p>

  <p><a name=AEN211></a><b>Пример 2-2. Вывод значения переменной (элемента массива)</b></p>
  <div class="cdata">&lt;?php
    echo $_SERVER[&quot;HTTP_USER_AGENT&quot;]; ?&gt;</div>
  <p>Пример вывода данной программы:</p>
    <div class="cdata">Mozilla/4.0 (compatible; MSIE 5.01; Windows NT
    5.0)</div>

<p>В PHP есть огромное количество типов переменных. В
предыдущем примере мы печатали элемент массива. Массивы в PHP являются очень мощным средством.</p>

<p>$_SERVER - просто переменная,
которая предоставлена вам языком PHP. Список таких переменных можно посмотреть
в разделе &quot;Зарезервированные переменные&quot;. А можно получить их полный список с помощью такой
программы:</p>

<p><a name=AEN223></a><b>Пример 2-3. Показываем все
  стандартные переменные с помощью функции phpinfo()</b></p>
<div class="cdata">&lt;?php phpinfo(); ?&gt;</div>

<p>Если открыть данный файл в браузере, вы увидите страничку с
информацией о PHP, а также список всех доступных вам переменных.</p>

<p>Внутрь тегов PHP можно помещать множество команд и
создавать кусочки кода, делающие гораздо большее, чем просто вывод на экран. К
примеру, если мы хотим сделать проверку на Internet Explorer, мы можем
поступить так:</p>

<p><a name=AEN230></a><b>Пример 2-4. Пример использования управляющих структур и функций</b></p>
  <div class="cdata">&lt;?php<br>
    if (strstr($_SERVER[&quot;HTTP_USER_AGENT&quot;], &quot;MSIE&quot;)) {<br>
    &nbsp; &nbsp; echo
    &quot;Вы используете Internet Explorer&lt;br /&gt;&quot;;<br>
    }<br>
    ?&gt;</div>
  <p>Пример вывода данной программы:</p>
  <div class="cdata">You are using Internet Explorer&lt;br /&gt;</div>

<p>Здесь мы показали несколько новых элементов. Во-первых, здесь есть команда if. Если вам знаком
основной синтаксис языка C, то вы уже заметили что-то схожее. Если же вы не
знаете C или подобного по синтаксису языка, то лучший вариант - взять
какую-либо книжку по PHP и прочитать ее. Другой вариант - почитать раздел
&quot;Описание языка&quot; данного руководства.</p>

<p>Во-вторых, здесь есть вызов функции <b>strstr()</b>. <b>strstr()</b> - встроенная в
PHP функция, которая ищет одну строку в другой. В данном случае мы ищем строку &quot;MSIE&quot; в $_SERVER[&quot;HTTP_USER_AGENT&quot;]. Если строка не найдена, эта функция возвращает <b>FALSE</b>, если найдена - <b>TRUE</b>. Если она вернет <b>TRUE</b>, то условие в if окажется истинным, и код
в командных скобках ({ }) выполнится. В противном
случае данный код не выполняется. Попробуйте создать аналогичные примеры с
использованием команд if, else, и других функций,
таких, как <b>strtoupper()</b> и <b>strlen()</b>. Также примеры содержатся во многих описаниях функций в
данном руководстве.</p>

<p>Продемонстрируем, как можно входить в режим кода PHP и
выходить из него прямо внутри кода:</p>

<p><a name=AEN256></a><b>Пример 2-5. Смешение режимов HTML и PHP</b></p>
<div class="cdata">&lt;?php<br>
    if (strstr($_SERVER[&quot;HTTP_USER_AGENT&quot;], &quot;MSIE&quot;)) {<br>
    ?&gt;<br>
    &lt;h3&gt;strstr
    вернул true&lt;/h3&gt;<br>
    &lt;center&gt;&lt;b&gt;Вы используете Internet Explorer&lt;/b&gt;&lt;/center&gt;<br>
    &lt;?php<br>
    } else {<br>
    ?&gt;<br>
    &lt;h3&gt;strstr
    вернул false&lt;/h3&gt;<br>
    &lt;center&gt;&lt;b&gt;Вы не используете Internet Explorer&lt;/b&gt;&lt;/center&gt;<br>
    &lt;?php<br>
    }<br>
    ?&gt;</div>
<p>Пример вывода данной программы:</p>
<div class="cdata">&lt;h3&gt;strstr вернул true&lt;/h3&gt;</p>
    <p>&lt;center&gt;&lt;b&gt;Вы используете Internet
    Explorer&lt;/b&gt;&lt;/center&gt;</div>

<p>Вместо использования команды PHP echo для вывода, мы вышли
из режима кода и послали содержимое HTML. Важный момент здесь - то, что
логическая структура кода PHP при этом не теряется. Только одна HTML-часть
будет послана клиенту в зависимости от результата функции <b>strstr()</b> (другими
словами, в зависимости от того, найдена строка &quot;MSIE&quot; или нет).</p>

<p><a name=tutorial.forms></a><b>Работа с формами</b></p>

<p>Одно из главнейших достоинств PHP - то, как он работает с
формами HTML. Здесь основным является то, что каждый элемент формы
автоматически станет доступен вашим программам на PHP.
Для подробной информации об использовании форм в PHP читайте раздел &quot; Переменные из внешних источников&quot;. Вот пример формы HTML:</p>


<p><a name=AEN268></a><b>Пример 2-6. Простейшая форма HTML</b></p>
<div class="cdata">
    &lt;form action=&quot;action.php&quot;    method=&quot;POST&quot;&gt;<br>
     Ваше имя: &lt;input type=&quot;text&quot;    name=&quot;name&quot; /&gt;<br>
     Ваш возраст: &lt;input
    type=&quot;text&quot; name=&quot;age&quot; /&gt;<br>
     &lt;input
    type=&quot;submit&quot;&gt;<br>
    &lt;/form&gt;</div>

<p>В этой форме нет ничего особенного. Это обычная форма HTML
без каких-либо специальных тегов. Когда пользователь заполнит форму и нажмет
кнопку отправки, будет вызвана страница action.php. В этом файле может быть что-то вроде:</p>


<p><a  name=AEN274></a><b>Пример 2-7. Выводим данные нашей формы</b></p>
<div class="cdata">
 Здравствуйте, &lt;?php echo $_POST[&quot;name&quot;]; ?&gt;.<br>
 Вам &lt;?php echo $_POST[&quot;age&quot;]; ?&gt; лет.</div>
<p>Пример вывода данной программы:</p>
<div class="cdata">
 Здравствуйте, Сергей.<br>
 Вам 30 лет.</div>

<p>Принцип работы данного кода прост и понятен. Переменные The
$_POST[&quot;name&quot;] и $_POST[&quot;age&quot;] автоматически установлены для вас средствами PHP. Ранее мы
использовали переменную $_SERVER, здесь же мы точно также используем суперглобальную
переменную $_POST, которая содержит все POST-данные. Заметим, что <i>метод отправки</i>
нашей формы - POST. Если бы мы использовали метод <i>GET</i>, то информация
нашей формы была бы в суперглобальной переменной $_GET. Также можно использовать переменную
$_REQUEST,
если источник данных не имеет значения. Эта переменная содержит смесь данных
GET, POST, COOKIE и FILE. Также советуем взглянуть на описание функции <b>import_request_variables()</b>.</p>

<p><a name=tutorial.oldcode></a><b>Использование старых программ с
новыми версиями PHP</b></p>

<p>Сейчас PHP является популярным языком сценариев (скриптов).
Становится все больше и больше распространяемых кусочков кода, которые вы
можете использовать в своих скриптах. В большинстве
случаев разработчики PHP старались сохранить совместимость с предыдущими
версиями так, что код, написанный для более старой
версии будет идеально работать и с новыми версиями языка без каких-либо
изменений. Однако случается так, что изменения все-таки необходимы.</p>

<p>Есть два важных изменения, которые влияют на старые программы:</p>

<ul type=disc>
 <li>Объявление массивов $HTTP_*_VARS
     устаревшими. Эти массивы требовали глобализации в
     функциях и процедурах. Новые суперглобальные
     массивы были введены, начиная с PHP 4.1.0.
     Это: $_GET, $_POST, $_COOKIE,
     $_SERVER,
     $_ENV,
     $_REQUEST,
     и $_SESSION. Более старые массивы $HTTP_*_VARS,
     такие, как $HTTP_POST_VARS, существуют со времен PHP 3 и, вероятно, будут
     еще долго существовать для сохранения совместимости. </li>
 <li>Внешние переменные
     больше не глобализуются по умолчанию. Другими словами, директива register_globals в php.ini по
     умолчанию отключена (&quot;off&quot;), начиная с PHP 4.2.0. Рекомендуемый метод доступа к таким
     переменным - суперглобальные массивы, описанные выше. Более старые
     программы, книги и руководства могут считать, что данная директива
     включена (&quot;on&quot;). К примеру, переменная $id
     может поступать из строки URL http://www.example.com/foo.php?id=42.
     Когда указанная директива выключена, $id доступна
     лишь как $_GET['id']. </li>
</ul>

<p>Для дополнительной информации
касательно изменений, связанных с переменными, смотрите раздел &quot;Предопределенные переменные&quot;и ссылки этого раздела.</p>



<h1><a name=tutorial.whatsnext></a>Что дальше?</h1>

<p>То, что вы узнали, поможет вам понять большую часть руководства и
разобраться в большинстве приведенных примеров программ. Другие примеры находятся
на различных сайтах, ссылки на которые можно найти на
php.net: http://www.php.net/links.php.
</p>

<p><a name=language.basic-syntax><b>Глава 3. Основы синтаксиса</b></a><b></b></p>

<p><b>Содержание</b></p>

<p>Вставка в HTML</p>

<p>Разделение инструкций</p>

<p>Комментарии</p>

<p><a name=language.basic-syntax.phpmode></a><b>Вставка в HTML</b></p>

<p>Когда PHP обрабатывает файл, он просто передаёт его текст,
пока не встретит один из специальных тегов, который сообщает ему о
необходимости начать интерпретацию текста как кода PHP. Затем он выполняет весь
найденный код до закрывающего тега, говорящего интерпретатору, что далее снова
идет просто текст. Этот механизм позволяет вам внедрять PHP-код в HTML - все за
пределами тегов PHP остается неизменным, тогда как внутри - интерпретируется
как код.</p>

<p>Существует четыре набора тегов, которые могут быть
использованы для обозначения PHP-кода. Из них только два (&lt;?php. . .?&gt; и
&lt;script language=&quot;php&quot;&gt;. . .&lt;/script&gt;) всегда доступны;другие могут быть включены или выключены в конфигурационном файле php.ini. Хотя короткие теги и
теги в стиле ASP могут быть удобны, они не так переносимы, как длинные версии.
Кроме того, если вы намереваетесь вставлять PHP-код в XML или XHTML, чтобы
соответствовать XML, вам следует использовать форму &lt;?php. . .?&gt;.</p>

<p>Теги, поддерживаемые PHP:</p>


  <p><a
  name=AEN3115></a><b>Пример 5-1. Способы вставки в
  HTML</b></p>
<div class="cdata">
    <p>1.&nbsp; &lt;?php echo(&quot;если вы хотите работать с документами XHTML или XML,
    делайте так\n&quot;); ?&gt;<br>
    <br>
    2.&nbsp; &lt;?
    echo (&quot;это
    простейшая инструкция обработки SGML\n&quot;);    ?&gt;<br>
    &nbsp; &nbsp; &lt;?= выражение ?&gt; Это
    синоним для &quot;&lt;? echo выражение
    ?&gt;&quot;<br>
    &nbsp; &nbsp; <br>
    3.&nbsp; &lt;script
    language=&quot;php&quot;&gt;<br>
    &nbsp; &nbsp; &nbsp; &nbsp; echo (&quot;некоторые редакторы
    (например, FrontPage) не<br>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; любят
    инструкции обработки&quot;);<br>
    &nbsp; &nbsp; &lt;/script&gt;<br>
    <br>
    4.&nbsp; &lt;% echo (&quot;Вы можете по
    выбору использовать теги в стиле ASP&quot;); %&gt;<br>
    &nbsp; &nbsp; &lt;%= $variable; # Это
    синоним для &quot;&lt;% echo . . .&quot; %&gt;</div>

<p>Первый способ, &lt;?php. . .?&gt;, наиболее
предпочтительный, так как он позволяет использовать PHP в коде, соответствующем
правилам XML, таком как XHTML.</p>

<p>Второй способ не всегда доступен. Короткие теги доступны только когда они включены. Это можно сделать,
используя функцию <b>short_tags()</b> (только в PHP 3), включив установку short_open_tag в
конфигурационном файле PHP, либо скомпилировав PHP с параметром
--enable-short-tags для <b>configure</b>. Даже если оно включено по умолчанию в
php.ini-dist, использование коротких тегов не рекомендуется.</p>

<p>Четвертый способ доступен только
если теги в стиле ASP были включены, используя конфигурационную установку asp_tags.</p>

<p><b>Замечание: </b>Поддержка
тегов в стиле ASP была добавлена в версии 3.0.4.</p>

<p><b>Замечание: </b>Следует
избегать использования коротких тегов при разработке приложений или библиотек,
предназначенных для распространения или размещения на PHP-серверах, не
находящихся под вашим контролем, так как короткие теги могут не поддерживаться
на целевом сервере. Для создания переносимого, совместимого кода, не
используйте короткие теги.</p>

<p>Закрывающий тег блока PHP-кода включает сразу следующий за
ним перевод строки, если он имеется. Кроме того, закрывающий тег автоматически
подразумевает точку с запятой; вам не нужно заканчивать последнюю строку кода в
блоке точкой с запятой. Закрывающий тег PHP-блока в конце файла не является
обязательным.</p>

<p>PHP позволяет использовать такие структуры:</p>


  <p><a
  name=AEN3132></a><b>Пример 5-2. Профессиональная
  вставка</b></p>
<div class="cdata">
    <p>&lt;?php<br>
    if ($expression) { <br>
    &nbsp; &nbsp; ?&gt;<br>
    &nbsp; &nbsp; &lt;strong&gt;Это истина.&lt;/strong&gt;<br>
    &nbsp; &nbsp; &lt;?php <br>
    } else { <br>
    &nbsp; &nbsp; ?&gt;<br>
    &nbsp; &nbsp; &lt;strong&gt;Это
    ложь.&lt;/strong&gt;<br>
    &nbsp; &nbsp; &lt;?php <br>
    }<br>
    ?&gt;</div>

<p>Этот код работает так, как ожидается, потому что когда PHP
встречает закрывающие теги ?&gt;, он просто выводит
все, что он находит до следующего открывающего тега. Приведенный здесь пример конечно придуманный, но для вывода больших блоков
текста выход из режима интерпретации PHP обычно более эффективен, чем отправка
всего текста через <b>echo()</b>, <b>print()</b> или что-либо подобное.</p>



<p><a name=language.basic-syntax.instruction-separa></a><b>Разделение
инструкций</b></p>

<p>Инструкции разделяются также как и в C или Perl - каждое
выражение заканчивается точкой с запятой.</p>

<p>Закрывающий тег (?&gt;) также подразумевает конец
инструкции, поэтому два следующих фрагмента кода эквиваленты:</p>

  <div class="cdata"><a name=AEN3141></a>&lt;?php<br>
  &nbsp; &nbsp; echo &quot;Это тест&quot;;<br>
  ?&gt;<br>
  <br>
  &lt;?php echo &quot;Это тест&quot; ?&gt;</div>

<p><a name=language.basic-syntax.comments></a><b>Комментарии</b></p>

<p>PHP поддерживает комметарии в стиле 'C', 'C++' и оболочки
Unix. Например:</p>

  <div class="cdata"><a name=AEN3146></a>&lt;?php<br>
  &nbsp; &nbsp; echo &quot;Это тест&quot;; // Это однострочный
  комментарий в стиле c++<br>
  &nbsp; &nbsp; /* Это многострочный комментарий<br>
  &nbsp; &nbsp; &nbsp; &nbsp;еще
  одна строка комментария */<br>
  &nbsp; &nbsp; echo &quot;Это еще один тест&quot;;<br>
  &nbsp; &nbsp; echo &quot;Последний тест&quot;; # Это комментарий в стиле оболочки Unix<br>
  ?&gt;</div>

<p>Однострочные комментарии идут только до конца строки или
текущего блока PHP-кода, в зависимости от того, что
идет перед ними.</p>

  <div class="cdata"><a name=AEN3150></a>&lt;h1&gt;Это
  &lt;?php # echo
  &quot;простой&quot;;?&gt; пример.&lt;/h1&gt;<br>
  &lt;p&gt;Заголовок вверху выведет 'Это пример'.</div>

<p>Будьте внимательны, следите за отсутствием вложенных
'C'-комментариев, они могут появиться во время комментирования больших блоков.</p>

  <div class="cdata"><a name=AEN3154></a>&lt;?php<br>
  /* <br>
  &nbsp; &nbsp; echo &quot;Это
  тест&quot;; /* Этот комментарий вызовет проблему */<br>
  */<br>
  ?&gt;</div>

<p>Однострочные комментарии идут только до конца строки или
текущего блока PHP-кода, в зависимости от того, что
идет перед ними. Это означает, что HTML-код после // ?&gt;БУДЕТ напечатан: ?&gt; выводит из режима PHP и
возвращает в режим HTML, но //
не позволяет этого сделать. Если включена конфигурационная директива asp_tags, то же
самое происходит и при //
%&gt;.</p>

<p><a name=language.types><b>Глава 4. Типы</b></a><b></b></p>

<p><b>Содержание</b></p>

<p>Введение</p>

<p>Булев</p>

<p>Целые</p>

<p>Числа с плавающей точкой</p>

<p>Строки</p>

<p>Массивы</p>

<p>Объекты</p>

<p>Ресурс</p>

<p>NULL
</p>

<p>Псевдо-типы, используемые в этой
документации</p>

<p>Манипуляции с типами</p>

<p><a name=language.types.intro></a><b>Введение</b></p>

<p>PHP поддерживает восемь простых типов.</p>

<p>Четыре скалярных типа:</p>

<ul type=disc>
 <li><b>boolean</b> </li>
 <li><b>integer</b> </li>
 <li><b>float</b> (число с плавающей точкой или '<b>double</b>') </li>
 <li><b>string</b> </li>
</ul>

<p>Два смешанных типа:</p>

<ul type=disc>
 <li><b>array</b> </li>
 <li><b>object</b> </li>
</ul>

<p>И, наконец, два специальных типа:</p>

<ul type=disc>
 <li><b>resource</b> </li>
 <li><b>NULL</b> </li>
</ul>

<p>Для удобства понимания в этом
руководстве используется также несколько псевдо-типов:</p>

<ul type=disc>
 <li>mixed </li>
 <li>number </li>
 <li>callback </li>
</ul>

<p>Вы также можете найти несколько
упоминаний типа двойной точности. Рассматривайте его как число с плавающей
точкой, два имени существуют только по историческим причинам.</p>

<p>Как правило, программист не устанавливает тип переменной;предпочтительнее, чтобы это делал PHP во время выполнения программы в
зависимости от контекста, в котором используется переменная.</p>

<p><b>Замечание: </b>Если вы
желаете проверить тип и значение определенного выражения, используйте <b>var_dump()</b>.</p>

<p><b>Замечание: </b>Если же вам
для отладки необходимо просто удобочитаемое представление типа, используйте <b>gettype()</b>. Чтобы
проверить на определенный тип, <i>не</i> используйте <b>gettype()</b>, применяйте
для этого is_<i>type</i> функции. Вот несколько примеров:</p>

  <div class="cdata"><a name=AEN3217></a>&lt;?php<br>
  $bool = TRUE;&nbsp; &nbsp;// логический<br>
  $str&nbsp; = &quot;foo&quot;;&nbsp; // строковый<br>
  $int&nbsp; = 12;&nbsp; &nbsp; &nbsp;// целочисленный<br>
  <br>
  echo gettype($bool); // выводит &quot;boolean&quot;<br>
  echo gettype($str);&nbsp; // выводит &quot;string&quot;<br>
  <br>
  // Если это целое, увеличить на четыре<br>
  if (is_int($int))
  {<br>
  &nbsp; &nbsp; $int += 4;<br>
  }<br>
  <br>
  // Если $bool - это строка, вывести ее<br>
  // (ничего не выводит)<br>
  if (is_string($bool))
  {<br>
  &nbsp; &nbsp; echo &quot;Строка: $bool&quot;;<br>
  }<br>
  ?&gt;</div>

<p>Если вы хотите принудительно изменить тип переменной, вы
можете либо привести переменную, либо использовать функцию <b>settype()</b>.</p>

<p>Обратите внимание, что переменная, в зависимости от ее типа
в данный момент, в определенных ситуациях может иметь разные значения. Более
подробную информацию смотрите в разделе Манипуляции
с типами. Также вам, возможно, будет интересно
посмотреть таблицы сравнения типов, поскольку в них приведены примеры связанных сравнений
различных типов.</p>

<h1><a name=language.types.boolean></a>Булев</h1>

<p>Это простейший тип. Он выражает истинность значения - это может быть либо <tt><b>TRUE</b></tt>, либо <tt><b>FALSE</b></tt>.</p>

<p><b>Замечание: </b>Булев тип был введен в PHP 4.</p>

<h2><a name=language.types.boolean.syntax></a>Синтаксис</h2>

<p>Чтобы определить булев тип, используйте ключевое слово <tt><b>TRUE</b></tt> или <tt><b>FALSE</b></tt>. Оба регистро-независимы.</p>

  <div class="cdata"><a name=AEN3237></a><code>&lt;?php</code><br>
  <code>$foo </code><code>=
  </code><code>True</code><code>; </code><code>// присвоить $foo значение TRUE</code><br>
  <code>?&gt;</code><code> </code></div>

<p>Обычно вы используете некий оператор, который возвращает логическое
выражение, а затем предает его управляющей конструкции.</p>

  <div class="cdata"><a name=AEN3242></a><code>&lt;?php</code><br>
  <code>// == это оператор,
  который проверяет</code><br>
  <code>// эквивалентность и возвращает булево значение</code><br>
  <code>if (</code><code>$action </code><code>== </code><code>&quot;показать_версию&quot;</code><code>) {</code><br>
  <code>&nbsp; &nbsp; echo </code><code>&quot;Версия 1.23&quot;</code><code>;</code><br>
  <code>}</code><br>
  <br>
  <code>// это не обязательно...</code><br>
  <code>if (</code><code>$show_separators </code><code>== </code><code>TRUE</code><code>) {</code><br>
  <code>&nbsp; &nbsp; echo </code><code>&quot;&lt;hr&gt;\n&quot;</code><code>;</code><br>
  <code>}</code><br>
  <br>
  <code>// ...потому что вы
  можете просто написать</code><br>
  <code>if (</code><code>$show_separators</code><code>) {</code><br>
  <code>&nbsp; &nbsp; echo </code><code>&quot;&lt;hr&gt;\n&quot;</code><code>;</code><br>
  <code>}</code><br>
  <code>?&gt;</code><code> </code></div>

<h2><a name=language.types.boolean.casting></a>Преобразование в булев тип</h2>

<p>Для несомненного преобразования значения в булев тип используйте приведение типа
<tt>(bool)</tt> или <tt>(boolean)</tt>. Однако в большинстве случаев
вам нет необходимости использовать приведение типа, поскольку значение будет
автоматически преобразовано, если оператор, функция или управляющая конструкция
требует булев аргумент.</p>

<p>Смотрите также Манипуляции с типами.</p>

<p>При преобразовании в логический тип, следующие значения рассматриваются как <tt><b>FALSE</b></tt>:</p>
<ul>
<li>Сам булев <tt><b>FALSE</b></tt></li>
<li>целое 0 (ноль)</li>
<li>число с плавающей точкой 0.0 (ноль)</li>
<li>пустая строка и строка &quot;0&quot;</li>
<li>массив с нулевыми элементами</li>
<li>объект с нулевыми переменными-членами</li>
<li>специальный тип NULL (включая неустановленные
переменные)</li>
</ul>

<p>Все остальные значения рассматриваются как <tt><b>TRUE</b></tt> (включая любой ресурс).</p>

  <p align=center><b>Внимание</b></p>
  <p><tt>-1</tt> считается <tt><b>TRUE</b></tt>, как и любое ненулевое
  (отрицательное или положительное) число!</p>
  <div class="cdata"><a name=AEN3283></a><code>&lt;?php</code><br>
  <code>echo </code><code>gettype</code><code>((bool)
  </code><code>&quot;&quot;</code><code>);&nbsp; &nbsp; &nbsp; &nbsp; </code><code>//
  bool(false)</code><br>
  <code>echo </code><code>gettype</code><code>((bool)
  </code><code>1</code><code>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code><code>//
  bool(true)</code><br>
  <code>echo </code><code>gettype</code><code>((bool)
  -</code><code>2</code><code>);&nbsp; &nbsp; &nbsp; &nbsp; </code><code>//
  bool(true)</code><br>
  <code>echo </code><code>gettype</code><code>((bool)
  </code><code>&quot;foo&quot;</code><code>);&nbsp; &nbsp; &nbsp;</code><code>//
  bool(true)</code><br>
  <code>echo </code><code>gettype</code><code>((bool)
  </code><code>2.3e5</code><code>);&nbsp; &nbsp; &nbsp;</code><code>//
  bool(true)</code><br>
  <code>echo </code><code>gettype</code><code>((bool)
  array(</code><code>12</code><code>));  </code><code>// bool(true)</code><br>
  <code>echo </code><code>gettype</code><code>((bool)
  array());&nbsp; &nbsp;</code><code>// bool(false)</code><br>
  <code>?&gt;</code><code> </code></div>
  </td>
 </tr>
</table>


<h1><a name=language.types.integer></a>Целые</h1>

<p>Целое это число из множества Z = {..., -2, -1, 0, 1, 2, ...}.</p>

<p>Смотрите также: Целые произвольной длины / GMP, Числа с плавающей точкой и Произвольная
точность / BCMath</p>

<h2><a name=language.types.integer.syntax></a>Синтаксис</h2>

<p>Целые могут быть указаны в десятичной, шестнадцатеричной или восьмеричной
системе счисления, по желанию с предшествующим знаком (- или
+).</p>

<p>Если вы используете восьмеричную систему счисления, вы должны предварить
число <tt>0</tt> (нулем), для
использования шестнадцатеричной системы нужно поставить перед числом <tt>0x</tt>.</p>

<table border=0 cellspacing=0 cellpadding=0 width="100%">
 <tr>
  <td>
  <div>
  <p><a name=AEN3298></a><b>Пример 6-1. Целые</b></p>
<div class="cdata">
    <p><code>&lt;?php</code><br>
    <code>$a </code><code>=
    </code><code>1234</code><code>; </code><code># десятичное число</code><br>
    <code>$a </code><code>= -</code><code>123</code><code>; </code><code># отрицательное число</code><br>
    <code>$a </code><code>= </code><code>0123</code><code>; </code><code># восьмеричное число (эквивалентно
    83 в десятичной системе)</code><br>
    <code>$a </code><code>= </code><code>0x1A</code><code>; </code><code># шестнадцатеричное число
    (эквивалентно 26 в десятичной системе)</code><br>
    <code>?&gt;</code><code> </code></div>

<p>Формально возможная структура целых такова:</p>

<pre><a name=AEN3301></a>десятичные        : [1-9][0-9]*</pre><pre>                  | 0</pre><pre> </pre><pre>шестнадцатеричные : 0[xX][0-9a-fA-F]+</pre><pre> </pre><pre>восьмеричные      : 0[0-7]+</pre><pre> </pre><pre>целые             : [+-]?десятичные</pre><pre>                  | [+-]?шестнадцатеричные</pre><pre>                  | [+-]?восьмеричные</pre>

<p>Размер целого зависит от платформы, хотя, как правило,
максимальное значение около двух миллиардов (это 32-битное знаковое). PHP не
поддерживает беззнаковые целые.</p>

<h2><a name=language.types.integer.overflow></a>Превышение размера целого</h2>

<p>Если вы определите число, превышающее пределы целого типа, оно будет
интерпретировано как число с плавающей точкой. Также, если вы используете
оператор, результатом работы которого будет число, превышающее пределы целого,
вместо него будет возвращено число с плавающей точкой.</p>

  <div class="cdata"><a name=AEN3306></a><code>&lt;?php</code><br>
  <code>$large_number </code><code>=&nbsp; </code><code>2147483647</code><code>;</code><br>
  <code>var_dump</code><code>(</code><code>$large_number</code><code>);</code><br>
  <code>// вывод:  int(2147483647)</code><br>
  <br>
  <code>$large_number </code><code>=&nbsp; </code><code>2147483648</code><code>;</code><br>
  <code>var_dump</code><code>(</code><code>$large_number</code><code>);</code><br>
  <code>// вывод:  float(2147483648)</code><br>
  <br>
  <code>// это справедливо и для шестнадцатеричных целых:</code><br>
  <code>var_dump</code><code>( </code><code>0x80000000 </code><code>);</code><br>
  <code>// вывод:  float(2147483648)</code><br>
  <br>
  <code>$million </code><code>= </code><code>1000000</code><code>;</code><br>
  <code>$large_number </code><code>=&nbsp; </code><code>50000 </code><code>* </code><code>$million</code><code>;</code><br>
  <code>var_dump</code><code>(</code><code>$large_number</code><code>);</code><br>
  <code>// вывод:  float(50000000000)</code><br>
  <code>?&gt;</code><code> </code></div>

  <p align=center><b>Внимание</b></p>
  <p>К сожалению, в PHP была ошибка, так что это не всегда верно работает,
  когда используются отрицательные числа. Например: когда вы умножаете <tt>-50000 * $million</tt>, результатом будет <tt>-429496728</tt>. Однако, если оба операнда
  положительны, проблем не возникает.</p>
  <p>Эта ошибка устранена в PHP 4.1.0.</p>

<p>в PHP не существует оператора деления целых. Результатом <tt>1/2</tt> будет число с плавающей точкой <tt>0.5</tt>. Вы можете привести значение к целому,
что всегда округляет его в меньшую сторону, либо использовать функцию <b>round()</b>.
</p>

<div class="cdata"><a name=AEN3317></a><code>&lt;?php</code><br>
  <code>var_dump</code><code>(</code><code>25</code><code>/</code><code>7</code><code>);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code><code>//
  float(3.5714285714286) </code><br>
  <code>var_dump</code><code>((int) (</code><code>25</code><code>/</code><code>7</code><code>));  </code><code>// int(3)</code><br>
  <code>var_dump</code><code>(</code><code>round</code><code>(</code><code>25</code><code>/</code><code>7</code><code>));&nbsp; </code><code>//
  float(4)</code><br>
  <code>?&gt;</code></div>

<h2><a name=language.types.integer.casting></a>Преобразование в целое</h2>

<p>Для несомненного преобразования значения в целое используйте приведение типа
<tt>(int)</tt> или <tt>(integer)</tt>. Однако в большинстве случаев
вам нет необходимости использовать приведение типа, поскольку значение будет
автоматически преобразовано, если оператор, функция или управляющая конструкция
требует целый аргумент. Вы также можете преобразовать значение в целое при
помощи функции <b>intval()</b>.</p>

<p>Смотрите также Манипуляции с типами.</p>

<h3><a name=language.types.integer.casting.from-bool></a>Из булева
типа</h3>

<p><tt><b>FALSE</b></tt> преобразуется в <tt>0</tt> (ноль), а <tt><b>TRUE</b></tt> - в <tt>1</tt>
(единицу).</p>

<h3><a name=language.types.integer.casting.from-floa></a>Из чисел с плавающей
точкой</h3>

<p>При преобразовании из числа с плавающей точкой в целое, число будет
округлено <i>в сторону нуля</i>.</p>

<p>Если число с плавающей точкой превышает пределы целого (как правило, это <tt>+/- 2.15e+9 = 2^31</tt>), результат будет
неопределенным, так как целое не имеет достаточной точности, чтобы вернуть
верный результат. В этом случае не будет выведено ни предупреждения, ни даже
замечания!</p>

  <p align=center><b>Внимание</b></p>
  <p>Никогда не приводите неизвестную дробь к целому, так как это может иногда
  дать неожиданные результаты.</p>
  <div class="cdata"><a name=AEN3344></a><code>&lt;?php</code><br>
    <code>echo (int) ( (</code><code>0.1</code><code>+</code><code>0.7</code><code>) * </code><code>10 </code><code>); </code><code>// выводит 7!</code><br>
    <code>?&gt;</code><code> </code></p>
  <p>Смотрите более подробно: предупреждение о точности чисел с
  плавающей точкой.</div>

<h3><a name=language.types.integer.casting.from-stri></a>Из строк</h3>

<p>Смотрите Преобразование строк в числа</p>

<h3><a name=language.types.integer.casting.from-othe></a>Из других типов</h3>

  <p align=center><b>Предостережение</b></p>
  <p>Для других типов поведение преобразования в целое не определено. В
  настоящее время поведение такое же, как если бы значение сперва
  было преобразовано в булев тип. Однако <i>не</i>
  полагайтесь на это поведение, так как он может измениться без предупреждения.
 </p>

<h1><a name=language.types.float></a>Числа с плавающей точкой</h1>

<p>Числа с плавающей точкой (они же числа двойной точности или действительные
числа) могут быть определены при помощи любого из следующих синтаксисов:</p>

<div class="cdata"><a name=AEN3361></a><code>&lt;?php</code><br>
  <code>$a </code><code>= </code><code>1.234</code><code>;</code><br>
  <code>$b </code><code>= </code><code>1.2e3</code><code>;</code><br>
  <code>$c </code><code>= </code><code>7E-10</code><code>;</code><br>
  <code>?&gt;</code><code> </code></div>

<p>Формально:</p>

<div class="cdata"><a name=AEN3363></a><code>LNUM&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [0-9]+</code><br>
  <code>DNUM&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ([0-9]*[\.]{LNUM})
  | ({LNUM}[\.][0-9]*)</code><br>
  <code>EXPONENT_DNUM ( ({LNUM} | {DNUM}) [eE][+-]?
  {LNUM}) </code></div>

<p>Размер целого зависит от платформы, хотя максимум, как
правило, ~1.8e308 с точностью около 14 десятичных цифр (это 64-битный
IEEE-формат).</p>

  <p align=center><a
  name=warn.float-precision></a><b>Точность числа с плавающей точкой</b></p>
  <p>Довольно часто простые десятичные дроби вроде <tt>0.1</tt> или <tt>0.7</tt>
  не могут быть преобразованы в свои внутренние двоичные аналоги без небольшой
  потери точности. Это может привести к неожиданным результатам: например, <tt>floor((0.1+0.7)*10)</tt> скорее всего возвратит <tt>7</tt>
  вместо ожидаемой <tt>8</tt> как
  результат внутреннего представления числа, являющегося в действительности
  чем-то вроде <tt>7.9999999999...</tt>.</p>
  <p>Это связано с невозможностью точно выразить
  некоторые дроби в десятичной системе счисления конечным числом цифр.
  Например, <tt>1/3</tt> в десятичной
  форме принимает вид <tt>0.3333333. . .</tt>.
 </p>
  <p>Так что никогда не доверяйте точности последних цифр в результатах с
  числами с плавающей точкой и никогда не проверяйте их на равенство. Если вам
  действительно необходима высокая точность, вам следует использовать математические
  функции произвольной точности или gmp-функции.</p>

<h2><a name=language.types.float.casting></a>Преобразование в число с плавающей
точкой</h2>

<p>О том, когда и как строки преобразуются в числа с
плавающей точкой читайте в разделе Преобразование строк в числа. Для
значений других типов преобразование будет таким же, как если бы значение
сначала было преобразовано в целое, а затем в число с плавающей точкой.
Дополнительную информацию смотрите в разделе Преобразование в целое.</p>

<h1><a name=language.types.string></a>Строки</h1>

<p>Строка - это набор символов. В PHP символ это то же самое, что и байт, это
значит, что возможно ровно 256 различных символов. Это также означает, что PHP
не имеет встроенной поддержки Unicode'а. Некоторую поддержку Unicode'а
обеспечивают функции <b>utf8_encode()</b> и <b>utf8_decode()</b>.</p>

<p><b>Замечание: </b>Нет никаких проблем, если строка очень велика. Практически
не существует ограничений на размер строк, налагаемых PHP, так что нет
абсолютно никаких причин беспокоиться об их длине.</p>

<h2><a name=language.types.string.syntax></a>Синтаксис</h2>

<p>Строка может быть определена тремя различными способами.</p>
<ul>
<li>одинарными кавычками</li>
<li>двойными кавычками</li>
<li>heredoc-синтаксисом</li>
</ul>

<h3><a name=language.types.string.syntax.single></a>Одинарные кавычки</h3>

<p>Простейший способ определить строку - это заключить ее в одинарные кавычки
(символ <tt>'</tt>).</p>

<p>Чтобы использовать одинарную кавычку внутри строки, как и во многих других
языках, ее необходимо предварить символом обратной косой черты (<tt>\</tt>), т. е.
экранировать ее. Если обратная косая черта должна идти перед одинарной кавычкой
либо быть в конце строки, вам необходимо продублировать ее. Обратите внимание,
что если вы попытаетесь экранировать любой другой символ, обратная косая черта
также будет напечатана! Так что, как правило, нет необходимости экранировать
саму обратную косую черту.</p>

<p><b>Замечание: </b>В PHP 3 в данном случае будет выдано сообщение уровня <tt>E_NOTICE</tt>.</p>

<p><b>Замечание: </b>В отличие от двух других синтаксисов, переменные и экранирующие
последовательности для специальных символов, встречающиеся в строках,
заключенных в одинарные кавычки, <i>не</i>
обрабатываются.</p>

<div class="cdata"><a name=AEN3418></a><code>&lt;?php</code><br>
  <code>echo </code><code>'это простая строка'</code><code>;</code><br>
  <br>
  <code>echo </code><code>'Также
  вы можете вставлять в строки</code><br>
  <code>символ новой строки таким образом,</code><br>
  <code>поскольку это нормально'</code><code>;</code><br>
  <br>
  <code>// Выведет: Однажды
  Арнольд сказал: &quot;I'll be back&quot;</code><br>
  <code>echo </code><code>'Однажды Арнольд сказал: &quot;I\'ll
  be back&quot;'</code><code>;</code><br>
  <br>
  <code>// Выведет: Вы
  удалили C:\*.*?</code><br>
  <code>echo </code><code>'Вы удалили C:\\*.*?'</code><code>;</code><br>
  <br>
  <code>// Выведет: Вы
  удалили C:\*.*?</code><br>
  <code>echo </code><code>'Вы удалили C:\*.*?'</code><code>;</code><br>
  <br>
  <code>// Выведет: Это не
  вставит: \n новую строку</code><br>
  <code>echo </code><code>'Это не вставит: \n новую строку'</code><code>;</code><br>
  <br>
  <code>// Выведет:  Переменные $expand также $either не подставляются</code><br>
  <code>echo </code><code>'Переменные $expand также $either не
  подставляются';<br>
  ?&gt;  </code></div>

 <a name=language.types.string.syntax.double></a><b>Двойные кавычки</b>
 <p>Если строка заключена в двойные кавычки (&quot;), PHP распознает большее
 количество управляющих последовательностей для специальных символов:</p>
 <p><a name=AEN3423></a><b>Таблица 6-1. Управляющие последовательности</b></p>
 <table border=1 cellpadding=0>
  <thead>
   <tr>
    <td>
    <p><b>последовательность</b></p>
    </td>
    <td>
    <p><b>значение</b></p>
    </td>
   </tr>
  </thead>
  <tr>
   <td>
   <p><tt>\n</tt></p>
   </td>
   <td>
   <p>новая строка (LF или 0x0A (10) в ASCII)</p>
   </td>
  </tr>
  <tr>
   <td>
   <p><tt>\r</tt></p>
   </td>
   <td>
   <p>возврат каретки (CR или 0x0D (13) в ASCII)</p>
   </td>
  </tr>
  <tr>
   <td>
   <p><tt>\t</tt></p>
   </td>
   <td>
   <p>горизонтальная табуляция (HT или 0x09 (9) в ASCII)</p>
   </td>
  </tr>
  <tr>
   <td>
   <p><tt>\\</tt></p>
   </td>
   <td>
   <p>обратная косая черта</p>
   </td>
  </tr>
  <tr>
   <td>
   <p><tt>\$</tt></p>
   </td>
   <td>
   <p>знак доллара</p>
   </td>
  </tr>
  <tr>
   <td>
   <p><tt>\&quot;</tt></p>
   </td>
   <td>
   <p>двойная кавычка</p>
   </td>
  </tr>
  <tr>
   <td>
   <p><tt>\[0-7]{1,3}</tt></p>
   </td>
   <td>
   <p>последовательность символов, соответствующая регулярному
   выражению, символ в восьмеричной системе счисления</p>
   </td>
  </tr>
  <tr>
   <td>
   <p><tt>\x[0-9A-Fa-f]{1,2}</tt></p>
   </td>
   <td>
   <p>последовательность символов, соответствующая регулярному
   выражению, символ в шестнадцатеричной системе счисления</p>
   </td>
  </tr>
 </table>
 <p>Повторяем, если вы захотите мнемнонизировать любой другой символ, обратная
 косая черта также будет напечатана!</p>
 <p>Но самым важным свойством строк в двойных кавычках является обработка
 переменных. Смотрите более подробно: обработка строк.</p>
 <h3><a name=language.types.string.syntax.heredoc></a>Heredoc</h3>
 <p>Другой способ определения строк - это использование heredoc-синтаксиса (&quot;&lt;&lt;&lt;&quot;). После <tt>&lt;&lt;&lt;</tt> необходимо указать
 идентификатор, затем идет строка, а потом этот же идентификатор, закрывающий
 вставку.</p>
 <p>Закрывающий идентификатор <i>должен</i>
 начинаться в первом столбце строки. Кроме того, идентификатор должен
 соответствовать тем же правилам именования, что и все остальные метки в PHP: содержать только буквенно-цифровые символы и знак подчеркивания, и должен
 начинаться с нецифры или знака подчеркивания.</p>

   <p align=center><b>Внимание</b></p>
   <p>Очень важно отметить, что строка с закрывающим идентификатором не
   содержит других символов, за исключением, <i>возможно</i>,
   точки с запятой (<tt>;</tt>).
   Это означает, что идентификатор <i>не должен
   вводиться с отступом</i> и что не может быть никаких пробелов или
   знаков табуляции до или после точки с запятой. Важно также понимать, что
   первым символом перед закрывающим идентификатором должен быть символ новой
   строки, определенный в вашей операционной системе. Например, на Macintosh
   это <tt>\r</tt>.</p>
   <p>Если это правило нарушено и закрывающий идентификатор
   не является &quot;чистым&quot;, считается, что закрывающий идентификатор
   отсутствует и PHP продолжит его поиск дальше. Если в этом случае верный
   закрывающий идентификатор так и не будет найден, то это вызовет ошибку в
   обработке с номером строки в конце скрипта.</p>

 <p>Heredoc-текст ведет себя так же, как и строка в двойных кавычках, при этом
 их не имея. Это означает, что вам нет необходимости экранировать кавычки в
 heredoc, но вы по-прежнему можете использовать вышеперечисленные управляющие
 последовательности. Переменные обрабатываются, но с применением сложных
 переменных внутри heredoc нужно быть также внимательным, как и при работе со
 строками.</p>

<p><a name=AEN3480></a><b>Пример 6-2. Пример определения heredoc-строки</b></p>
<div class="cdata"><code>&lt;?php</code><br>
     <code>$str </code><code>=
     &lt;&lt;&lt;EOD</code><br>
     <code>Пример строки,</code><br>
     <code>охватывающей несколько строчек,</code><br>
     <code>с использованием heredoc-синтаксиса.</code><br>
     <code>EOD;</code><br>
     <code>/* Более сложный
     пример с переменными. */</code><br>
     <code>class </code><code>foo</code><br>
     <code>{</code><br>
     <code>&nbsp; &nbsp; var </code><code>$foo</code><code>;</code><br>
     <code>&nbsp; &nbsp; var </code><code>$bar</code><code>;</code><br>
     <br>
     <code>&nbsp; &nbsp; function </code><code>foo</code><code>()</code><br>
     <code>&nbsp; &nbsp; {</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; </code><code>$this</code><code>-&gt;</code><code>foo </code><code>= </code><code>'Foo'</code><code>;</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; </code><code>$this</code><code>-&gt;</code><code>bar </code><code>= array(</code><code>'Bar1'</code><code>, </code><code>'Bar2'</code><code>, </code><code>'Bar3'</code><code>);</code><br>
     <code>&nbsp; &nbsp; }</code><br>
     <code>}</code><br>
     <br>
     <code>$foo </code><code>= new </code><code>foo</code><code>();</code><br>
     <code>$name </code><code>= </code><code>'МоеИмя'</code><code>;</code><br>
     <br>
     <code>echo &lt;&lt;&lt;EOT</code><br>
     <code>Меня зовут
     &quot;$name&quot;. Я печатаю $foo</code><code>-&gt;</code><code>foo.</code><br>
     <code>Теперь я вывожу </code><code>{</code><code>$foo</code><code>-&gt;</code><code>bar</code><code>[</code><code>1</code><code>]}</code><code>.</code><br>
     <code>Это должно вывести заглавную букву 'A': </code><code>\x41</code><br>
     <code>EOT;</code><code>?&gt;</code><code> </code></div>

 <p><b>Замечание: </b>Поддержка heredoc была добавлена в PHP 4.</p>
 <h3><a name=language.types.string.parsing></a>Обработка переменных</h3>
 <p>Если строка определяется в двойных кавычках, либо при помощи heredoc, переменные
 внутри нее обрабатываются.</p>
 <p>Существует два типа синтаксиса: простой и сложный. Простой синтаксис более
 легок и удобен. Он дает возможность обработки переменной, значения массива (<b>array</b>)
 или свойства объекта (<b>object</b>).</p>
 <p>Сложный синтаксис был введен в PHP 4 и может быть распознан по фигурным
 скобкам, окружающих выражение.</p>
 <h4><a name=language.types.string.parsing.simple></a>Простой синтаксис</h4>
 <p>Если интерпретатор встречает знак доллара (<tt>$</tt>), он захватывает так много
 символов, сколько возможно, чтобы сформировать правильное имя переменной. Если
 вы хотите точно определить конец имени, заключайте имя переменной в фигурные
 скобки.</p>

<div class="cdata"><a name=AEN3499></a><code>&lt;?php</code><br>
   <code>$beer </code><code>=
   </code><code>'Heineken'</code><code>;</code><br>
   <code>echo </code><code>&quot;$beer's
   taste is great&quot;</code><code>; </code><code>// работает, &quot;'&quot; это неверный символ для имени
   переменной</code><br>
   <code>echo </code><code>&quot;He drank some $beers&quot;</code><code>;&nbsp; &nbsp;</code><code>// не работает, 's' это верный символ
   для имени переменной</code><br>
   <code>echo </code><code>&quot;He drank some ${beer}s&quot;</code><code>; </code><code>// работает</code><br>
   <code>echo </code><code>&quot;He drank some {$beer}s&quot;</code><code>; </code><code>// работает</code><br>
   <code>?&gt;</code><code> </code></div>

 <p>Точно также могут быть обработаны элемент массива
 (<b>array</b>) или свойство объекта (<b>object</b>). В
 индексах массива закрывающая квадратная скобка (<tt>]</tt>) обозначает конец определения индекса. Для
 свойств объекта применяются те же правила, что и для простых переменных, хотя
 с ними невозможен трюк, как с переменными.</p>

<div class="cdata"><a name=AEN3505></a><code>&lt;?php</code><br>
   <code>// Э</code><code>ти примеры специфически об
   использовании массивов внутри</code><br>
   <code>// строк. Вне строк всегда заключайте строковые ключи вашего</code><br>
   <code>// массива в кавычки и не используйте вне строк {скобки}.</code><br>
   <br>
   <code>// Давайте покажем все ошибки<br>
   error_reporting(E_ALL);<br>
   <br>
   $fruits =
   array('strawberry' =&gt; 'red', 'banana' =&gt; 'yellow');<br>
   <br>
   // Работает, но заметьте, что вне кавычек строки это работает
   по-другому<br>
   echo &quot;A
   banana is $fruits[banana].&quot;;<br>
   <br>
   //Работает<br>
   echo &quot;A banana
   is {$fruits['banana']}.&quot;;<br>
   <br>
   // Работает, но PHP, как описано ниже, сначала ищет<br>
   // константу banana.<br>
   echo &quot;A
   banana is {$fruits[banana]}.&quot;;</code><br>
   <br>
   <code>// Не работает,
   используйте фигурные скобки. Это</code><code> </code><code>вызовет</code><code> </code><code>ошибку</code><code> </code><code>обработки</code><code>.</code><br>
   <code>echo </code><code>&quot;A
   banana is $fruits['banana'].&quot;</code><code>;</code><br>
   <br>
   <code>// </code><code>Работает</code><br>
   <code>echo </code><code>&quot;A
   banana is &quot; </code><code>. </code><code>$fruits</code><code>[</code><code>'banana'</code><code>]
   . </code><code>&quot;.&quot;</code><code>;</code><br>
   <br>
   <code>// </code><code>Работает</code><br>
   <code>echo </code><code>&quot;This
   square is $square-&gt;width meters broad.&quot;</code><code>;</code><br>
   <br>
   <code>// </code><code>Не</code><code> </code><code>работает</code><code>. </code><code>Для</code><code> </code><code>решения</code><code> </code><code>см</code><code>. </code><code>сложный</code><code> </code><code>синтаксис</code><code>.</code><br>
   <code>echo </code><code>&quot;This
   square is $square-&gt;width00 centimeters broad.&quot;</code><code>;</code><br>
   <code>?&gt;</code><code> </code></div>

 <p>Для чего-либо более сложного вы должны использовать сложный синтаксис.</p>
 <h4><a name=language.types.string.parsing.complex></a>Сложный (фигурный)
 синтаксис</h4>
 <p>Он называется сложным не потому, что труден в понимании, а потому что
 позволяет использовать сложные выражения.</p>
 <p>Фактически, вы можете включить любое значение, находящееся в пространстве
 имени в строке с этим синтаксисом. Вы просто записываете выражение таким же
 образом, как и вне строки, а затем заключаете его в { и
 }. Поскольку вы не можете экранировать '{', этот синтаксис
 будет распознаваться только когда $ следует непосредственно за {. (Используйте
 &quot;{\$&quot; или &quot;\{$&quot; чтобы отобразить &quot;{$&quot;).
 Несколько поясняющих примеров:</p>

<div class="cdata"><a name=AEN3512></a><code>&lt;?php</code><br>
   <code>// Д</code><code>авайте покажем все ошибки</code><br>
   <code>error_reporting</code><code>(</code><code>E_ALL</code><code>);</code><br>
   <br>
   <code>$great </code><code>= </code><code>'fantastic'</code><code>;</code><br>
   <br>
   <code>// Не работает,
   выведет: This is { fantastic}</code><br>
   <code>echo </code><code>&quot;This is { $great}&quot;</code><code>;</code><br>
   <br>
   <code>// Работает,
   выведет: This is fantastic</code><br>
   <code>echo </code><code>&quot;This is {$great}&quot;</code><code>;</code><br>
   <code>echo </code><code>&quot;This
   is ${great}&quot;</code><code>;</code><br>
   <br>
   <code>// Работает</code><br>
   <code>echo </code><code>&quot;Этот квадрат шириной
   {$square-&gt;width}00 сантиметров.&quot;;<br>
   <br>
   // </code><code>Работает</code><br>
   <code>echo </code><code>&quot;Это работает:   {$arr[4][3]}&quot;</code><code>;</code><br>
   <br>
   <code>// Это неверно по
   той же причине, что и $foo[bar] неверно вне</code><br>
   <code>// строки. Другими словами, это по-прежнему будет работать,</code><br>
   <code>// но поскольку PHP сначала ищет константу foo, это вызовет</code><br>
   <code>// ошибку уровня E_NOTICE (неопределенная константа).</code><br>
   <code>echo </code><code>&quot;Это неправильно:   {$arr[foo][3]}&quot;</code><code>;</code><br>
   <br>
   <code>// Работает. При
   использовании многомерных массивов, внутри</code><br>
   <code>// строк всегда используйте фигурные скобки</code><br>
   <code>echo </code><code>&quot;Это работает:   {$arr['foo'][3]}&quot;</code><code>;</code><br>
   <br>
   <code>// Работает.</code><br>
   <code>echo </code><code>&quot;Это работает: &quot; </code><code>. </code><code>$arr</code><code>[</code><code>'foo'</code><code>][</code><code>3</code><code>];</code><br>
   <br>
   <code>echo </code><code>&quot;Вы
   даже можете записать {$obj-&gt;values[3]-&gt;name}&quot;</code><code>;</code><br>
   <br>
   <code>echo </code><code>&quot;Это
   значение переменной по имени $name: {${$name}}&quot;</code><code>;</code><br>
   <code>?&gt;</code><code> </code></div>

 <h3><a name=language.types.string.substr></a>Доступ к символу в строке и его
 изменение</h3>
 <p>Символы в строках можно использовать и модифицировать, определив их смещение относительно начала строки, начиная с нуля, в
 фигурных скобках после строки.</p>
 <p><b>Замечание: </b>Для обеспечения обратной совместимости, вы по-прежнему
 имеете возможность использовать в тех же целях скобки массива. Однако, начиная
 с PHP 4, этот синтаксис нежелателен к использованию.</p>

   <p><a name=AEN3520></a><b>Пример 6-3. Несколько примеров строк</b></p>
<div class="cdata"><code>&lt;?php</code><br>
     <code>// Получение
     первого символа строки</code><br>
     <code>$str </code><code>= </code><code>'Это тест.';<br>
     $</code><code>first </code><code>= </code><code>$str</code><code>{</code><code>0</code><code>};</code><br>
     <br>
     <code>// Получение
     третьего символа строки</code><br>
     <code>$third </code><code>= </code><code>$str</code><code>{</code><code>2</code><code>};</code><br>
     <br>
     <code>// Получение
     последнего символа строки</code><br>
     <code>$str </code><code>= </code><code>'Это все еще тест.'</code><code>;</code><br>
     <code>$last </code><code>= </code><code>$str</code><code>{</code><code>strlen</code><code>(</code><code>$str</code><code>)-</code><code>1</code><code>};</code><br>
     <br>
     <code>// Изменение
     последнего символа строки</code><br>
     <code>$str </code><code>= </code><code>'Посмотри на море'</code><code>;</code><br>
     <code>$str</code><code>{</code><code>strlen</code><code>(</code><code>$str</code><code>)-</code><code>1</code><code>} = </code><code>'я'</code><code>;</code><br>
     <br>
     <code>?&gt;</code><code> </code></div>

 <h2><a name=language.types.string.useful-funcs></a>Полезные функции и
 операторы</h2>
 <p>Строки могут быть объединены при помощи оператора '.' (точка). Обратите внимание, оператор сложения '+' здесь не работает.
 Дополнительную информацию смотрите в разделе Строковые операторы.</p>
 <p>Для модификации строк существует множество полезных функций.</p>
 <p>Основные функции описаны в разделе строковых функций,
 функции регулярных выражений для расширенного поиска и замены (в двух частях: Perl и POSIX расширенный).</p>
 <p>Также существуют функции для URL-строк, и функции для
 шифрования/дешифрования строк (mcrypt и mhash).</p>
 <p>Наконец, если вы все еще не нашли, что искали, смотрите также функции для
 символьного типа.</p>
 <h2><a name=language.types.string.casting></a>Преобразование в строку</h2>
 <p>Вы можете преобразовать значение в строку, используя приведение <tt>(string)</tt>, либо функцию <b>strval()</b>. В
 выражениях, где необходима строка, преобразование происходит автоматически.
 Это происходит, когда вы используете функции <b>echo()</b> или <b>print()</b>,
 либо когда вы сравниваете значение переменной со строкой. Прочтение разделов
 руководства Типы и Манипуляции с типами сделает следующее более понятным.
 Смотрите также <b>settype()</b>.</p>
 <p>Булево (<b>boolean</b>) значение <tt><b>TRUE</b></tt>
 преобразуется в строку <tt>&quot;1&quot;</tt>,
 а значение <tt><b>FALSE</b></tt>
 представляется как <tt>&quot;&quot;</tt>
 (пустая строка). Этим способом вы можете преобразовывать значения в обе
 стороны - из булева типа в строковый и наоборот.</p>
 <p>Целое (<b>integer</b>) или число с плавающей точкой (<b>float</b>)
 преобразуется в строку, представленную числом, состоящим из его цифр (включая
 показатель степени для чисел с плавающей точкой).</p>
 <p>Массивы всегда преобразуются в строку <tt>&quot;Array&quot;</tt>,
 так что вы не можете отобразить содержимое массива (<b>array</b>), используя <b>echo()</b>
 или <b>print()</b>, чтобы узнать, что он содержит. Чтобы просмотреть один
 элемент, вам нужно сделать что-то вроде <tt>echo
 $arr['foo']</tt>. Смотрите ниже советы о том, как
 отобразить/просмотреть все содержимое.</p>
 <p>Объекты всегда преобразуются в строку <tt>&quot;Object&quot;</tt>.
 Если вы хотите вывести значение переменной-члена объекта (<b>object</b>) с
 целью отладки, прочтите следующие абзацы. Если вы хотите получить имя класса
 требуемого объекта, используйте <b>get_class()</b>.</p>
 <p>Ресурсы всегда преобразуются в строки со структурой <tt>&quot;Resource id #1&quot;</tt>, где <tt>1</tt> - это уникальный номер ресурса (<b>resource</b>),
 присвоенный ему PHP во время выполнения. Если вы хотите получить тип ресурса,
 используйте <b>get_resource_type()</b>.</p>
 <p><tt><b>NULL</b></tt> всегда
 преобразуется в пустую строку.</p>
 <p>Как вы могли видеть выше, вывод массивов, объектов или ресурсов не
 предоставляет вам никакой полезной информации о самих значениях. Более
 подходящий способ вывода значений для отладки - использовать функции <b>print_r()</b>
 и <b>var_dump()</b>.</p>
 <p>Вы также можете преобразовать значения PHP в строки для постоянного
 хранения. Этот метод называется сериализацией и может быть выполнен при помощи
 функции <b>serialize()</b>. Кроме того, если в вашей установке PHP есть
 поддержка WDDX, вы можете сериализовать значения PHP в структуры XML.</p>
 <h2><a name=language.types.string.conversion></a>Преобразование строк в числа</h2>
 <p>Если строка распознается как числовое значение, результирующее значение и
 тип определяется так как показано далее.</p>
 <p>Строка будет распознана как <b>float</b>, если она содержит любой из
 символов '.', 'e', или 'E'. Иначе она будет определена как целое.</p>
 <p>Значение определяется по начальной части строки. Если строка начинается с
 верного числового значения, будет использовано это значение. Иначе значением
 будет 0 (ноль). Верное числовое значение - это одна или более цифр (могущих
 содержать десятичную точку), по желанию предваренных знаком, с последующим
 необязательным показателем степени. Показатель степени - это 'e' или 'E' с
 последующими одной или более цифрами.</p>

<div class="cdata"><a name=AEN3586></a><code>&lt;?php</code><br>
   <code>$foo </code><code>=
   </code><code>1 </code><code>+ </code><code>&quot;10.5&quot;</code><code>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>// $foo это float (11.5)</code><br>
   <code>$foo </code><code>= </code><code>1 </code><code>+ </code><code>&quot;-1.3e3&quot;</code><code>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>// $foo это float (-1299)</code><br>
   <code>$foo </code><code>= </code><code>1 </code><code>+ </code><code>&quot;bob-1.3e3&quot;</code><code>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code><code>// $foo это integer (1)</code><br>
   <code>$foo </code><code>= </code><code>1 </code><code>+ </code><code>&quot;bob3&quot;</code><code>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>// $foo это integer (1)</code><br>
   <code>$foo </code><code>= </code><code>1 </code><code>+ </code><code>&quot;10 Small Pigs&quot;</code><code>;&nbsp; &nbsp; &nbsp; &nbsp;</code><code>// $foo это integer (11)</code><br>
   <code>$foo </code><code>= </code><code>4 </code><code>+ </code><code>&quot;10.2 Little Piggies&quot;</code><code>; </code><code>// $foo это float (14.2)</code><br>
   <code>$foo </code><code>= </code><code>&quot;10.0 pigs &quot; </code><code>+ </code><code>1</code><code>;</code><code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>// $foo это float (11)</code><br>
   <code>$foo </code><code>= </code><code>&quot;10.0 pigs &quot; </code><code>+ </code><code>1.0</code><code>;&nbsp; &nbsp; &nbsp; &nbsp; </code><code>// $foo это float
   (11)&nbsp; &nbsp; &nbsp;</code><br>
   <code>?&gt;</code><code> </code></div>

 <p>Более подробную информацию об этом преобразовании смотрите в разделе о
 strtod(3) документации Unix.</p>
 <p>Если вы хотите протестировать любой из примеров этого раздела, вы можете
 скопировать и вставить его и следующую строку, чтобы увидеть, что происходит:</p>

<div class="cdata"><a name=AEN3590></a><code>&lt;?php</code><br>
   <code>echo </code><code>&quot;\$foo==$foo;   </code><code>тип</code><code>:   &quot; </code><code>. </code><code>gettype
   </code><code>(</code><code>$foo</code><code>)
   . </code><code>&quot;&lt;br
   /&gt;\n&quot;</code><code>;</code><br>
   <code>?&gt;</code><code> </code></div>

 <p>Не ожидайте получить код символа, преобразовав его в целое (как вы могли бы
 сделать, например, в C). Для преобразования символов в их коды и обратно
 используйте функции <b>ord()</b> и <b>chr()</b>.</p>
 
 <h1><a name=language.types.array></a>Массивы</h1>
 <p>На самом деле массив в PHP - это упорядоченная карта. Карта - это тип,
 который вносит <i>значения</i> в <i>ключи</i>. Этот тип оптимизирован в нескольких
 направлениях, поэтому вы можете использовать его как собственно массив, список
 (вектор), хэш-таблицу (являющуюся реализацией карты), словарь, коллекцию,
 стэк, очередь или, возможно, как что-то еще. Поскольку вы можете иметь в
 качестве значения другой массив PHP, вы можете также легко эмулировать деревья.
</p>
 <p>Объяснение этих структур данных выходит за рамки данного справочного
 руководства, но вы найдете как минимум один пример каждой из них. За
 дополнительной информацией вы можете обратиться к соответствующей литературе
 по этой обширной теме.</p>
 <h2><a name=language.types.array.syntax></a>Синтаксис</h2>
 <h3><a name=language.types.array.syntax.array-func></a>Определение при помощи array()</h3>
 <p>Массив может быть создан языковой конструкцией <b>array()</b>. В качестве
 параметров она принимает определенное количество разделенных запятыми пар <tt><i>key</i></tt><tt>
 =&gt; <i>value</i></tt> (ключ =&gt; значение).</p>

<div class="cdata"><pre>array( [<tt><i>key</i></tt> =&gt;] <tt><i>value</i></tt></pre><pre>     , ...</pre><pre>     )</pre><pre>// <tt><i>key</i></tt> может быть <b>integer</b> или <b>string</b></pre><pre>// <tt><i>value</i></tt> может быть любым значением</pre></div>

 <p><a name=AEN3621></a></p>
<div class="cdata"><code>&lt;?php</code><br>
   <code>$arr </code><code>= array(</code><code>&quot;foo&quot;   </code><code>=&gt; </code><code>&quot;bar&quot;</code><code>, </code><code>12
   </code><code>=&gt; </code><code>true</code><code>);</code><br>
   <br>
   <code>echo </code><code>$arr</code><code>[</code><code>&quot;foo&quot;</code><code>];   </code><code>// bar</code><br>
   <code>echo </code><code>$arr</code><code>[</code><code>12</code><code>];&nbsp; &nbsp; </code><code>//
   1</code><br>
   <code>?&gt;</code><code> </code></div>

 <p><tt>key</tt> может быть либо <b>integer</b>,
 либо <b>string</b>. Если ключ - это стандартное представление <b>integer</b>,
 он так и будет интерпретироваться (т.е. <tt>&quot;8&quot;</tt>
 будет восприниматься как <tt>8</tt>,
 тогда как <tt>&quot;08&quot;</tt> будет
 интерпретироваться как <tt>&quot;08&quot;</tt>).
 В PHP нет разницы между индексными и ассоциативными массивами; существует
 только один тип массива, который может содержать и числовые, и строковые
 индексы.</p>
 <p>Значение может быть любого имеющегося в PHP типа.</p>
<div class="cdata"><a name=AEN3633></a><code>&lt;?php</code><br>
   <code>$arr </code><code>= array(</code><code>&quot;somearray&quot;   </code><code>=&gt; array(</code><code>6 </code><code>=&gt;   </code><code>5</code><code>, </code><code>13
   </code><code>=&gt; </code><code>9</code><code>, </code><code>&quot;a&quot;   </code><code>=&gt; </code><code>42</code><code>));</code><br>
   <br>
   <code>echo </code><code>$arr</code><code>[</code><code>&quot;somearray&quot;</code><code>][</code><code>6</code><code>];&nbsp; &nbsp; </code><code>//
   5</code><br>
   <code>echo </code><code>$arr</code><code>[</code><code>&quot;somearray&quot;</code><code>][</code><code>13</code><code>];&nbsp; &nbsp;</code><code>//
   9</code><br>
   <code>echo </code><code>$arr</code><code>[</code><code>&quot;somearray&quot;</code><code>][</code><code>&quot;a&quot;</code><code>];&nbsp; </code><code>//
   42</code><br>
   <code>?&gt;</code><code> </code></div>

 <p>Если вы не указываете ключ для приведенного значения, то берется
 максимальный числовой индекс и новый ключ будет равен этому максимуму + 1.
 Если вы укажите ключ, которому уже присвоено значение, оно будет перезаписано.
</p>
<div class="cdata"><a name=AEN3636></a><code>&lt;?php</code><br>
   <code>// Э</code><code>тот массив эквивалентен ...</code><br>
   <code>array(</code><code>5 </code><code>=&gt; </code><code>43</code><code>, </code><code>32</code><code>, </code><code>56</code><code>, </code><code>&quot;b&quot; </code><code>=&gt; </code><code>12</code><code>);</code><br>
   <br>
   <code>// ...этому
   массиву</code><br>
   <code>array(</code><code>5 </code><code>=&gt; </code><code>43</code><code>, </code><code>6 </code><code>=&gt; </code><code>32</code><code>, </code><code>7 </code><code>=&gt; </code><code>56</code><code>, </code><code>&quot;b&quot; </code><code>=&gt; </code><code>12</code><code>);</code><br>
   <code>?&gt;</code><code> </code></div>

   <p align=center><b>Внимание</b></p>
   <p>Начиная с PHP 4.3.0, вышеописанное поведение генерации индекса изменено.
   Теперь, если вы будете использовать массив, в котором максимальным в
   настоящий момент является отрицательный ключ, то следующий созданный ключ
   будет нулевым (<tt>0</tt>). Раньше
   новым индексом становился самый большой существующий ключ + 1, так же как и
   у положительных индексов.</p>

 <p>Используя в качестве ключа <tt><b>TRUE</b></tt> вы получите ключ <tt>1</tt> типа <b>integer</b>. Используя
 в качестве ключа <tt><b>FALSE</b></tt>
 вы получите ключ <tt>0</tt> типа <b>integer</b>.
 Используя в качестве ключа <tt>NULL</tt>,
 вы получите пустую строку. Использование в качестве
 ключа пустой строки создаст (или перезапишет) ключ с пустой строкой и его значение; это не то же самое, что использование пустых квадратных скобок.</p>
 <p>Вы не можете использовать в качестве ключей массивы или объекты. Это
 вызовет предупреждение: <tt>Illegal offset type</tt>
 ('Недопустимый тип смещения').</p>
 <h3><a name=language.types.array.syntax.modifying></a>Создание/модификация с
 помощью синтаксиса квадратных скобок</h3>
 <p>Также вы можете изменять существующий массив, явно устанавливая значения в
 нем.</p>
 <p>Это выполняется присвоением значений массиву при указании в скобках ключа.
 Кроме того, вы можете опустить ключ, в этом случае добавьте к имени переменной
 пустую пару скобок (&quot;<tt>[]</tt>&quot;).
</p>

<div class="cdata"><pre>$arr[<tt><i>key</i></tt>] = <tt><i>value</i></tt>;</pre><pre>$arr[] = <tt><i>value</i></tt>;</pre><pre>// <tt><i>key</i></tt> может быть <b>integer</b> или <b>string</b></pre><pre>// <tt><i>value</i></tt> может быть любым значением</pre></div>

 <p>Если массив <tt>$arr</tt> еще не
 существует, он будет создан. Таким образом, это еще один способ определить
 массив. Для изменения определенного значения просто присвойте элементу с его
 ключом новое значение. Если вы хотите удалить пару ключ/значение, вам нужно
 использовать функцию <b>unset()</b>.</p>
<div class="cdata"><a name=AEN3666></a><code>&lt;?php</code><br>
   <code>$arr </code><code>=
   array(</code><code>5 </code><code>=&gt; </code><code>1</code><code>, </code><code>12 </code><code>=&gt; </code><code>2</code><code>);</code><br>
   <br>
   <code>$arr</code><code>[] = </code><code>56</code><code>;&nbsp; &nbsp; </code><code>// В этом месте скрипта это</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //
   эквивалентно $arr[13] = 56;</code><br>
   <br>
   <code>$arr</code><code>[</code><code>&quot;x&quot;</code><code>] = </code><code>42</code><code>; </code><code>// Это добавляет к массиву новый</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //
   элемент с ключом &quot;x&quot;</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><br>
   <code>unset(</code><code>$arr</code><code>[</code><code>5</code><code>]); </code><code>// Это удаляет элемент из массива</code><br>
   <br>
   <code>unset(</code><code>$arr</code><code>);&nbsp; &nbsp; </code><code>// Это удаляет массив полностью</code><br>
   <code>?&gt;</code><code> </code></div>

 <p><b>Замечание: </b>Как уже говорилось выше, если вы не укажите в скобках
 ключа, то будет взят максимальный из существующих целочисленных индексов, и
 новым ключом будет это максимальное значение + 1. Если целочисленных индексов
 еще нет, то ключом будет <tt>0</tt>
 (ноль). Если вы укажите ключ, которому уже присвоено значение, оно будет
 перезаписано.</p>
<p align=center><b>Внимание</b></p>   <p>Начиная с PHP 4.3.0, вышеописанное поведение генерации индекса изменено.
   Теперь, если вы будете использовать массив, в котором максимальным в
   настоящий момент является отрицательный ключ, то следующий созданный ключ
   будет нулевым (<tt>0</tt>). Раньше
   новым индексом становился самый большой существующий ключ + 1, так же как и
   у положительных индексов.</div>
 <p>Обратите внимание, что максимальный числовой ключ, используемый для этого <i>не обязательно должен существовать в массиве в настоящий
 момент</i>. Он просто должен был существовать с момента последнего
 переиндексирования массива. Это иллюстрирует следующий пример:</p>
<div class="cdata"><a name=AEN3677></a><code>&lt;?php</code><br>
   <code>// С</code><code>оздаем простой массив.</code><br>
   <code>$array </code><code>= array(</code><code>1</code><code>, </code><code>2</code><code>, </code><code>3</code><code>, </code><code>4</code><code>, </code><code>5</code><code>);</code><br>
   <code>print_r</code><code>(</code><code>$array</code><code>);</code><br>
   <br>
   <code>// Теперь удаляем
   каждый элемент, но сам массив оставляем нетронутым:</code><br>
   <code>foreach (</code><code>$array </code><code>as </code><code>$i </code><code>=&gt; </code><code>$value</code><code>) {</code><br>
   <code>&nbsp; &nbsp; unset(</code><code>$array</code><code>[</code><code>$i</code><code>]);</code><br>
   <code>}</code><br>
   <code>print_r</code><code>(</code><code>$array</code><code>);</code><br>
   <br>
   <code>// Создаем элемент
   (обратите внимание, что новым ключом будет 5,</code><br>
   <code>// а не 0, как вы возможно ожидали).</code><br>
   <code>$array</code><code>[] = </code><code>6</code><code>;</code><br>
   <code>print_r</code><code>(</code><code>$array</code><code>);</code><br>
   <br>
   <code>// </code><code>Переиндексация</code><code>:</code><br>
   <code>$array </code><code>= </code><code>array_values</code><code>(</code><code>$array</code><code>);</code><br>
   <code>$array</code><code>[] = </code><code>7</code><code>;</code><br>
   <code>print_r</code><code>(</code><code>$array</code><code>);</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Вышеприведенный пример выведет следующее:</p>
<div class="cdata"><pre>Array</pre><pre>(</pre><pre>    [0] =&gt; 1</pre><pre>    [1] =&gt; 2</pre><pre>    [2] =&gt; 3</pre><pre>    [3] =&gt; 4</pre><pre>    [4] =&gt; 5</pre><pre>)</pre><pre>Array</pre><pre>(</pre><pre>)</pre><pre>Array</pre><pre>(</pre><pre>    [5] =&gt; 6</pre><pre>)</pre><pre>Array</pre><pre>(</pre><pre>    [0] =&gt; 6</pre><pre>    [1] =&gt; 7</pre><pre>)</pre></div>
 <h2><a name=language.types.array.useful-funcs></a>Полезные функции</h2>
 <p>Для работы с массивами существует достаточное количество полезных функций.
 Смотрите раздел функции для работы с массивами.</p>
 <p><b>Замечание: </b>Функция <b>unset()</b> позволяет удалять ключи массива.
 Обратите внимание, что массив НЕ будет переиндексирован. Если вы использовали
 только &quot;обычные числовые индексы&quot; (увеличивающиеся на единицу,
 начиная с нуля), вы можете переиндексировать массив
 используя <b>array_values()</b>.</p>
<div class="cdata"><a name=AEN3689></a><code>&lt;?php</code><br>
   <code>$a </code><code>=
   array(</code><code>1 </code><code>=&gt; </code><code>'один'</code><code>, </code><code>2 </code><code>=&gt; </code><code>'два'</code><code>, </code><code>3 </code><code>=&gt; </code><code>'три'</code><code>);</code><br>
   <code>unset(</code><code>$a</code><code>[</code><code>2</code><code>]);</code><br>
   <code>/* даст массив,
   представленный так:</code><br>
   <code>&nbsp; &nbsp;$a = array(1 =&gt; 'один', 3 =&gt; 'три');</code><br>
   <code>&nbsp; &nbsp;а НЕ так:</code><br>
   <code>&nbsp; &nbsp;$a = array(1 =&gt; 'один', 2 =&gt;'три');</code><br>
   <code>*/</code><br>
   <br>
   <code>$b </code><code>= </code><code>array_values</code><code>(</code><code>$a</code><code>);</code><br>
   <code>// Теперь $b это
   array(0 =&gt; 'один', 1 =&gt;'три')</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Управляющая конструкция foreach существует специально для массивов. Она
 предоставляет возможность легко пройтись по массиву.</p>
 <h2><a name=language.types.array.donts></a>Массив делает и не делает</h2>
 <h3><a name=language.types.array.foo-bar></a>Почему <tt>$foo[bar]</tt> это неверно?</h3>
 <p>Вы всегда должны заключать индекс ассоциативного массива в кавычки. К
 примеру, пишите $foo['bar'], а не $foo[bar]. Но почему $foo[bar] это неверно?
 Возможно, вы встречали в старых скриптах следующий
 синтаксис:</p>
<div class="cdata"><a name=AEN3699></a><code>&lt;?php</code><br>
   <code>$foo</code><code>[</code><code>bar</code><code>]
   = </code><code>'</code><code>враг</code><code>'</code><code>;</code><br>
   <code>echo </code><code>$foo</code><code>[</code><code>bar</code><code>];</code><br>
   <code>// </code><code>и</code><code> </code><code>т</code><code>. </code><code>д</code><code>.</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Это неверно, хотя и работает. Тогда почему же это неверно?
 Причина в том, что этот код содержит неопределенную константу (bar), а не
 строку ('bar' - обратите внимание на кавычки), и PHP в будущем может
 определить константу, которая к несчастью для вашего кода будет иметь то же
 самое имя. Это работает, потому что PHP автоматически преобразует <i>голую строку</i> (не заключенную в кавычки строку,
 которая не соответствует ни одному из известных символов) в строку, которая
 содержит голую строку. Например, если константа с именем <tt><b>bar</b></tt> не определена, то PHP заменит bar
 на строку <tt>'bar'</tt> и использует
 ее.</p>
 <p><b>Замечание: </b>Это не означает, что нужно <i>всегда</i>
 заключать ключ в кавычки. Нет необходимости заключать в кавычки константы или переменные,
 поскольку это помешает PHP обрабатывать их.</p>
<div class="cdata"><a name=AEN3709></a><code>&lt;?php</code><br>
   <code>error_reporting</code><code>(</code><code>E_ALL</code><code>);</code><br>
   <code>ini_set</code><code>(</code><code>'display_errors'</code><code>, </code><code>true</code><code>);</code><br>
   <code>ini_set</code><code>(</code><code>'html_errors'</code><code>, </code><code>false</code><code>);</code><br>
   <code>// </code><code>Простой</code><code> </code><code>массив</code><code>:</code><br>
   <code>$array </code><code>= array(</code><code>1</code><code>, </code><code>2</code><code>);</code><br>
   <code>$count </code><code>= </code><code>count</code><code>(</code><code>$array</code><code>);</code><br>
   <code>for (</code><code>$i </code><code>= </code><code>0</code><code>; </code><code>$i
   </code><code>&lt; </code><code>$count</code><code>; </code><code>$i</code><code>++)
   {</code><br>
   <code>&nbsp; &nbsp; echo </code><code>&quot;\n</code><code>Проверяем</code><code>
   $i: \n&quot;</code><code>;</code><br>
   <code>&nbsp; &nbsp; echo </code><code>&quot;</code><code>Плохо</code><code>:   &quot; </code><code>. </code><code>$array</code><code>[</code><code>'$i'</code><code>]
   . </code><code>&quot;\n&quot;</code><code>;</code><br>
   <code>&nbsp; &nbsp; echo </code><code>&quot;</code><code>Хорошо</code><code>:   &quot; </code><code>. </code><code>$array</code><code>[</code><code>$i</code><code>]
   . </code><code>&quot;\n&quot;</code><code>;</code><br>
   <code>&nbsp; &nbsp; echo </code><code>&quot;</code><code>Плохо</code><code>:   {$array['$i']}\n&quot;</code><code>;</code><br>
   <code>&nbsp; &nbsp; echo </code><code>&quot;</code><code>Хорошо</code><code>:   {$array[$i]}\n&quot;</code><code>;</code><br>
   <code>}</code><br>
   <code>?&gt;</code><code> </code></div>
 <p><b>Замечание: </b>Вышеприведенный код выведет следующее:</p>
<div class="cdata"><pre>Проверяем 0: </pre><pre>Notice: Undefined index:  $i in /path/to/script.html on line 9</pre><pre>Плохо: </pre><pre>Хорошо: 1</pre><pre>Notice: Undefined index:  $i in /path/to/script.html on line 11</pre><pre>Плохо: </pre><pre>Хорошо: 1</pre><pre> </pre><pre>Проверяем 1: </pre><pre>Notice: Undefined index:  $i in /path/to/script.html on line 9</pre><pre>Плохо: </pre><pre>Хорошо: 2</pre><pre>Notice: Undefined index:  $i in /path/to/script.html on line 11</pre><pre>Плохо: </pre><pre>Хорошо: 2</pre></div>
 <p>Дополнительные примеры, демонстрирующие этот факт:</p>
<div class="cdata"><a name=AEN3714></a><code>&lt;?php</code><br>
   <code>// </code><code>Давайте</code><code> </code><code>покажем</code><code> </code><code>все</code><code> </code><code>ошибки</code><br>
   <code>error_reporting</code><code>(</code><code>E_ALL</code><code>);</code><br>
   <br>
   <code>$arr </code><code>= array(</code><code>'fruit'   </code><code>=&gt; </code><code>'apple'</code><code>, </code><code>'veggie'   </code><code>=&gt; </code><code>'carrot'</code><code>);</code><br>
   <br>
   <code>// </code><code>Верно</code><br>
   <code>print </code><code>$arr</code><code>[</code><code>'fruit'</code><code>];&nbsp; </code><code>//
   apple</code><br>
   <code>print </code><code>$arr</code><code>[</code><code>'veggie'</code><code>];   </code><code>// carrot</code><br>
   <br>
   <code>// </code><code>Неверно</code><code>. </code><code>Это</code><code> </code><code>работает</code><code>, </code><code>но</code><code> </code><code>из</code><code>-</code><code>за</code><code> </code><code>неопределенной</code><code> </code><code>константы</code><code> </code><code>с</code><br>
   <code>// </code><code>именем</code><code>
   fruit </code><code>также</code><code> </code><code>вызывает</code><code> </code><code>ошибку</code><code>
   PHP </code><code>уровня</code><code>
   E_NOTICE</code><br>
   <code>// </code><br>
   <code>// Notice: Use of undefined constant fruit - assumed 'fruit' in...</code><br>
   <code>print </code><code>$arr</code><code>[</code><code>fruit</code><code>];&nbsp; &nbsp; </code><code>//
   apple</code><br>
   <br>
   <code>// </code><code>Давайте</code><code> </code><code>определим</code><code> </code><code>константу</code><code>, </code><code>чтобы</code><code> </code><code>продемонстрировать</code><code>, </code><code>что</code><br>
   <code>// </code><code>происходит</code><code>. </code><code>Мы</code><code> </code><code>присвоим</code><code> </code><code>константе</code><code> </code><code>с</code><code> </code><code>именем</code><code>
   fruit </code><code>значение</code><code>
   'veggie'.</code><br>
   <code>define</code><code>(</code><code>'fruit'</code><code>, </code><code>'veggie'</code><code>);</code><br>
   <br>
   <code>// </code><code>Теперь</code><code> </code><code>обратите</code><code> </code><code>внимание</code><code> </code><code>на</code><code> </code><code>разницу</code><br>
   <code>print </code><code>$arr</code><code>[</code><code>'fruit'</code><code>];&nbsp; </code><code>//
   apple</code><br>
   <code>print </code><code>$arr</code><code>[</code><code>fruit</code><code>];&nbsp; &nbsp; </code><code>//
   carrot</code><br>
   <br>
   <code>// </code><code>В</code><code>нутри</code><code> </code><code>строки</code><code> </code><code>это</code><code> </code><code>нормально</code><code>. </code><code>Внутри</code><code> </code><code>строк</code><code> </code><code>константы</code><code> </code><code>не</code><br>
   <code>// </code><code>рассматриваются</code><code>, </code><code>так</code><code> </code><code>что</code><code> </code><code>ошибки</code><code>
   E_NOTICE </code><code>здесь</code><code> </code><code>не</code><code> </code><code>произойдет</code><br>
   <code>print </code><code>&quot;Hello
   $arr[fruit]&quot;</code><code>;&nbsp; &nbsp; &nbsp; </code><code>//
   Hello apple</code><br>
   <br>
   <code>// </code><code>С</code><code> </code><code>одним</code><code> </code><code>исключением</code><code>: </code><code>фигурные</code><code> </code><code>скобки</code><code> </code><code>вокруг</code><code> </code><code>массивов</code><code> </code><code>внутри</code><br>
   <code>// </code><code>строк</code><code> </code><code>позволяют</code><code> </code><code>константам</code><code> </code><code>находится</code><code> </code><code>там</code><br>
   <code>print </code><code>&quot;Hello
   {$arr[fruit]}&quot;</code><code>;&nbsp; &nbsp; </code><code>//
   Hello carrot</code><br>
   <code>print </code><code>&quot;Hello
   {$arr['fruit']}&quot;</code><code>;&nbsp; </code><code>//
   Hello apple</code><br>
   <br>
   <code>// </code><code>Это</code><code> </code><code>не</code><code> </code><code>будет</code><code> </code><code>работать</code><code> </code><code>и</code><code> </code><code>вызовет</code><code> </code><code>ошибку</code><code> </code><code>обработки</code><code>, </code><code>такую</code><code> </code><code>как</code><code>:</code><br>
   <code>// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or
   T_NUM_STRING'</code><br>
   <code>// </code><code>Это</code><code>, </code><code>конечно</code><code>, </code><code>также</code><code> </code><code>приложимо</code><code> </code><code>и</code><code> </code><code>к</code><code> </code><code>использованию</code><code> </code><code>в</code><code> </code><code>строках</code><code> </code><code>автоглобальных</code><code> </code><code>переменных</code><br>
   <code>print </code><code>&quot;Hello
   $arr['fruit']&quot;</code><code>;</code><br>
   <code>print </code><code>&quot;Hello $_GET['foo']&quot;</code><code>;</code><br>
   <br>
   <code>// </code><code>Еще</code><code> </code><code>одна</code><code> </code><code>возможность</code><code> -
   </code><code>конкатенация</code><br>
   <code>print </code><code>&quot;Hello
   &quot; </code><code>. </code><code>$arr</code><code>[</code><code>'fruit'</code><code>]; </code><code>// Hello apple</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Когда вы переведете <b>error_reporting()</b> в режим отображения ошибок
 уровня <tt><b>E_NOTICE</b></tt> (такой
 как <tt><b>E_ALL</b></tt>), вы увидите
 эти ошибки. По умолчанию error_reporting установлена
 их не отображать.</p>
 <p>Как указано в разделе синтаксис, внутри квадратных скобок ('<tt>[</tt>' и '<tt>]</tt>')
 должно быть выражение. Это означает, что вы можете писать подобно этому:</p>
<div class="cdata"><a name=AEN3725></a><code>&lt;?php</code><br>
   <code>echo </code><code>$arr</code><code>[</code><code>somefunc</code><code>(</code><code>$bar</code><code>)];</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Это пример использования
 возвращаемого функцией значения в качестве индекса массива. PHP известны также
 и константы, как вы, возможно, видели упоминание <tt>E_*</tt> раньше.</p>
<div class="cdata"><a name=AEN3728></a><code>&lt;?php</code><br>
   <code>$error_descriptions</code><code>[</code><code>E_ERROR</code><code>]&nbsp; &nbsp;= </code><code>&quot;Произошла фатальная
   ошибка&quot;</code><code>;</code><br>
   <code>$error_descriptions</code><code>[</code><code>E_WARNING</code><code>] = </code><code>&quot;PHP сообщает
   предупреждение&quot;</code><code>;</code><br>
   <code>$error_descriptions</code><code>[</code><code>E_NOTICE</code><code>]&nbsp; = </code><code>&quot;Это лишь неофициальное
   замечание&quot;;<br>
   ?&gt;   </code></div>
 <p>Обратите внимание, что <tt>E_ERROR</tt>
 - это такой же верный идентификатор, как и <tt>bar</tt>
 в первом примере. Но последний пример по сути
 эквивалентен такой записи:</p>
<div class="cdata"><a name=AEN3732></a><code>&lt;?php</code><br>
   <code>$error_descriptions</code><code>[</code><code>1</code><code>] = </code><code>&quot;Произошла фатальная ошибка&quot;</code><code>;</code><br>
   <code>$error_descriptions</code><code>[</code><code>2</code><code>] = </code><code>&quot;PHP сообщает предупреждение&quot;</code><code>;</code><br>
   <code>$error_descriptions</code><code>[</code><code>8</code><code>] = </code><code>&quot;Это лишь неофициальное
   замечание&quot;;<br>
   ?&gt;   </code></div>
 <p>поскольку <tt>E_ERROR</tt>
 соответствует <tt>1</tt> и т. д.</p>
 <p>Как мы уже объяснили в вышеприведенных примерах, <tt>$foo[bar]</tt> по-прежнему работает, но это
 неверно. Это работает, поскольку в соответствии со своим синтаксисом <tt>bar</tt> ожидается как константа. Однако, в данном случае константы с именем <tt>bar</tt> не существует. В таком случае PHP
 предполагает, что, написав <tt>bar</tt>,
 вы имели ввиду строку <tt>&quot;bar&quot;</tt>, но забыли указать
 кавычки.</p>
 <h4><a name=AEN3742></a>Так что же в этом плохого?</h4>
 <p>Когда-нибудь в будущем команда разработчиков PHP возможно пожелает добавить
 еще одну константу или ключевое слово, либо вы можете ввести
 в ваше приложение еще одну константу и тогда у вас могут возникнуть
 проблемы. Например, вы уже не можете использовать
 таким образом слова <tt>empty</tt> и <tt>default</tt>, поскольку они являются зарезервированными
 ключевыми словами.</p>
 <p><b>Замечание: </b>Повторим, внутри строки (<b>string</b>), заключенной в
 двойные кавычки правильным является не окружать индексы массива кавычками,
 поэтому <tt>&quot;$foo[bar]&quot;</tt>
 является верным. Более подробно почему - смотрите вышеприведенные примеры, а
 также раздел обработка переменных в строках.</p>
 <h2><a name=language.types.array.casting></a>Преобразование в массив</h2>
 <p>Для любого из типов: <b>integer</b>, <b>float</b>, <b>string</b>, <b>boolean</b>
 и <b>resource</b>, если вы преобразуете значение в массив, вы получите массив
 с одним элементом (с индексом 0), являющимся скалярным значением, с которого
 вы начали.</p>
 <p>Если вы преобразуете в массив объект (<b>object</b>), вы получите в
 качестве элементов массива свойства (переменные-члены) этого объекта. Ключами
 будут имена переменных-членов.</p>
 <p>Если вы преобразуете в массив значение <tt><b>NULL</b></tt>,
 вы получите пустой массив.</p>
 <h2><a name=language.types.array.comparing></a>Сравнение</h2>
 <p>Массивы можно сравнивать при помощи функции <b>array_diff()</b> и Операторов
 массивов.</p>
 <h2><a name=language.types.array.examples></a>Примеры</h2>
 <p>Тип массив в PHP является очень гибким, поэтому мы приведем здесь несколько
 примеров, чтобы продемонстрировать вам все возможности массивов.</p>

   <div class="cdata"><a name=AEN3774></a><code>&lt;?php</code><br>
   <code>// это</code><br>
   <code>$a </code><code>= array( </code><code>'color' </code><code>=&gt; </code><code>'red'</code><code>,</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>'taste' </code><code>=&gt; </code><code>'sweet'</code><code>,</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>'shape' </code><code>=&gt; </code><code>'round'</code><code>,</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>'name'&nbsp; </code><code>=&gt; </code><code>'apple'</code><code>,</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code><code>4&nbsp; &nbsp; &nbsp; &nbsp; </code><code>// ключом будет 0</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>);</code><br>
   <br>
   <code>// полностью
   соответствует</code><br>
   <code>$a</code><code>[</code><code>'color'</code><code>] = </code><code>'red'</code><code>;</code><br>
   <code>$a</code><code>[</code><code>'taste'</code><code>] = </code><code>'sweet'</code><code>;</code><br>
   <code>$a</code><code>[</code><code>'shape'</code><code>] = </code><code>'round'</code><code>;</code><br>
   <code>$a</code><code>[</code><code>'name'</code><code>]&nbsp; = </code><code>'apple'</code><code>;</code><br>
   <code>$a</code><code>[]&nbsp; &nbsp; &nbsp; &nbsp; =
   </code><code>4</code><code>;&nbsp; &nbsp; &nbsp; &nbsp; </code><code>// ключом будет 0</code><br>
   <br>
   <code>$b</code><code>[] = </code><code>'a'</code><code>;</code><br>
   <code>$b</code><code>[] = </code><code>'b'</code><code>;</code><br>
   <code>$b</code><code>[] = </code><code>'c'</code><code>;</code><br>
   <code>// создаст массив
   array(0 =&gt; 'a' , 1 =&gt; 'b' , 2 =&gt; 'c'),</code><br>
   <code>// или просто array('a', 'b', 'c')</code><br>
   <code>?&gt;</code><code> </code></div>

   <p><a name=AEN3776></a><b>Пример 6-4. Использование array()</b></p>
   <div class="cdata"><code>&lt;?php</code><br>
     <code>// Массив как
     карта (свойств)</code><br>
     <code>$map </code><code>= array( </code><code>'version'&nbsp; &nbsp; </code><code>=&gt; </code><code>4</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>'OS'&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code><code>=&gt; </code><code>'Linux'</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>'lang'&nbsp; &nbsp; &nbsp; &nbsp;</code><code>=&gt; </code><code>'english'</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>'short_tags' </code><code>=&gt; </code><code>true</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>);</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><br>
     <code>// исключительно
     числовые ключи</code><br>
     <code>$array </code><code>= array( </code><code>7</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>8</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>0</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>156</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; -</code><code>10</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>);</code><br>
     <code>// это то же
     самое, что и array(0 =&gt; 7, 1 =&gt; 8, ...)</code><br>
     <br>
     <code>$switching </code><code>= array(&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code><code>10</code><code>, </code><code>// ключ = 0</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>5&nbsp; &nbsp; </code><code>=&gt;&nbsp; </code><code>6</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>3&nbsp; &nbsp; </code><code>=&gt;&nbsp; </code><code>7</code><code>, </code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>'a'&nbsp; </code><code>=&gt;&nbsp; </code><code>4</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>11</code><code>, </code><code>// ключ = 6 (максимальным числовым
     индексом был 5)</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>'8'&nbsp; </code><code>=&gt;&nbsp; </code><code>2</code><code>, </code><code>// ключ = 8 (число!)</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>'02' </code><code>=&gt; </code><code>77</code><code>, </code><code>// ключ = '02'</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>0&nbsp; &nbsp; </code><code>=&gt; </code><code>12&nbsp; </code><code>// значение 10 будет перезаписано
     на 12</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>);</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><br>
     <code>// пустой массив</code><br>
     <code>$empty </code><code>= array();</code><br>
     <code>?&gt;</code><code> </code></div>
 
   <p><a name=language.types.array.examples.loop></a><b>Пример 6-5. Коллекция</b></p>
     <div class="cdata"><code>&lt;?php</code><br>
     <code>$colors </code><code>= array(</code><code>'красный'</code><code>, </code><code>'синий'</code><code>, </code><code>'зеленый'</code><code>, </code><code>'желтый'</code><code>);</code><br>
     <br>
     <code>foreach (</code><code>$colors </code><code>as </code><code>$color</code><code>) {</code><br>
     <code>&nbsp; &nbsp; echo </code><code>&quot;Вам нравится $color?\n&quot;</code><code>;</code><br>
     <code>}</code><br>
     <br>
     <code>/* вывод:</code><br>
     <code>Вам нравится красный?</code><br>
     <code>Вам нравится синий?</code><br>
     <code>Вам нравится зеленый?</code><br>
     <code>Вам нравится желтый?</code><br>
     <code>*/</code><br>
     <code>?&gt;</code><code> </code></div>

 <p>Обратите внимание, что в настоящее время невозможно изменять значения
 массива в таком цикле напрямую. Однако можно сделать так:</p>
<div class="cdata"><a name=language.types.array.examples.changeloop></a><b>Пример 6-6.  Коллекция</b></div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>foreach (</code><code>$colors </code><code>as </code><code>$key </code><code>=&gt; </code><code>$color</code><code>) {</code><br>
     <code>&nbsp; &nbsp; </code><code>// не будет работать:</code><br>
     <code>&nbsp; &nbsp; //$color = strtoupper($color);</code><br>
     <code>&nbsp; &nbsp; </code><br>
     <code>&nbsp; &nbsp; // работает:</code><br>
     <code>&nbsp; &nbsp; </code><code>$colors</code><code>[</code><code>$key</code><code>] = </code><code>strtoupper</code><code>(</code><code>$color</code><code>);</code><br>
     <code>}</code><br>
     <code>print_r</code><code>(</code><code>$colors</code><code>);</code><br>
     <br>
     <code>/* вывод:</code><br>
     <code>Array</code><br>
     <code>(</code><br>
     <code>&nbsp; &nbsp; [0] =&gt; КРАСНЫЙ</code><br>
     <code>&nbsp; &nbsp; [1] =&gt; СИНИЙ</code><br>
     <code>&nbsp; &nbsp; [2] =&gt; ЗЕЛЕНЫЙ</code><br>
     <code>&nbsp; &nbsp; [3] =&gt; ЖЕЛТЫЙ</code><br>
     <code>)</code><br>
     <code>*/</code><br>
     <code>?&gt;</code><code> </code></div>
   
 <p>Следующий пример создает начинающийся с единицы массив.</p>
<div class="cdata"><a name=AEN3787></a><b>Пример 6-7. Индекс, начинающийся с единицы</b></p>
   </div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>$firstquarter&nbsp; </code><code>= array(</code><code>1 </code><code>=&gt; </code><code>'Январь'</code><code>, </code><code>'Февраль'</code><code>, </code><code>'Март'</code><code>);</code><br>
     <code>print_r</code><code>(</code><code>$firstquarter</code><code>);</code><br>
     <br>
     <code>/* вывод:</code><br>
     <code>Array </code><br>
     <code>(</code><br>
     <code>&nbsp; &nbsp; [1] =&gt; 'Январь'</code><br>
     <code>&nbsp; &nbsp; [2] =&gt; 'Февраль'</code><br>
     <code>&nbsp; &nbsp; [3] =&gt; 'Март'</code><br>
     <code>)</code><br>
     <code>*/</code><br>
     <code>?&gt;</code><code> </code></div>
 
<div class="cdata"><a name=AEN3790></a><b>Пример 6-8. Заполнение массива</b></p>
   </div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>// заполняет
     массив всеми элементами директории</code><br>
     <code>$handle </code><code>= </code><code>opendir</code><code>(</code><code>'.'</code><code>);</code><br>
     <code>while (</code><code>false !</code><code>== (</code><code>$file </code><code>= </code><code>readdir</code><code>(</code><code>$handle</code><code>))) {</code><br>
     <code>&nbsp; &nbsp; </code><code>$files</code><code>[] = </code><code>$file</code><code>;</code><br>
     <code>}</code><br>
     <code>closedir</code><code>(</code><code>$handle</code><code>);</code><br>
     <code>?&gt;</code><code> </code></div>
   
   </td>
  </tr>
 </table>
 <p>Массивы упорядочены. Вы можете изменять порядок элементов, используя
 различные функции сортировки. Для дополнительной информации смотрите раздел функции
 для работы с массивами. Вы можете подсчитать количество элементов в массиве,
 используя функцию <b>count()</b>.</p>
<div class="cdata"><a name=AEN3796></a><b>Пример 6-9. Сортировка массива</b></p>
   </div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>sort</code><code>(</code><code>$files</code><code>);</code><br>
     <code>print_r</code><code>(</code><code>$files</code><code>);</code><br>
     <code>?&gt;</code><code> </code></div>
   
   </td>
  </tr>
 </table>
 <p>Поскольку значение массива может быть чем угодно, им также может быть
 другой массив. Таким образом вы можете создавать
 рекурсивные и многомерные массивы.</p>
<div class="cdata"><a name=AEN3800></a><b>Пример 6-10. Рекурсивные и многомерные массивы</b></p>
   </div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>$fruits </code><code>= array ( </code><code>&quot;фрукты&quot; </code><code>=&gt; array ( </code><code>&quot;a&quot; </code><code>=&gt; </code><code>&quot;апельсин&quot;</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>&quot;b&quot; </code><code>=&gt; </code><code>&quot;банан&quot;</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>&quot;c&quot; </code><code>=&gt; </code><code>&quot;яблоко&quot;</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>),</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>&quot;числа&quot;&nbsp; </code><code>=&gt; array ( </code><code>1</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>2</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>3</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>4</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>5</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>6</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>),</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>&quot;дырки&quot;&nbsp; </code><code>=&gt; array
     (&nbsp; &nbsp; &nbsp; </code><code>&quot;первая&quot;</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>5 </code><code>=&gt; </code><code>&quot;вторая&quot;</code><code>,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code><code>&quot;третья&quot;</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>)</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; );</code><br>
     <br>
     <code>// Несколько
     примеров доступа к значениям предыдущего массива</code><br>
     <code>echo </code><code>$fruits</code><code>[</code><code>&quot;дырки&quot;</code><code>][</code><code>5</code><code>];&nbsp; &nbsp; </code><code>// напечатает &quot;вторая&quot;</code><br>
     <code>echo </code><code>$fruits</code><code>[</code><code>&quot;фрукты&quot;</code><code>][</code><code>&quot;a&quot;</code><code>]; </code><code>// напечатает &quot;апельсин&quot;</code><br>
     <code>unset(</code><code>$fruits</code><code>[</code><code>&quot;дырки&quot;</code><code>][</code><code>0</code><code>]);&nbsp; </code><code>// удалит &quot;первая&quot;</code><br>
     <br>
     <code>// Создаст новый многомерный массив</code><br>
     <code>$juices</code><code>[</code><code>&quot;яблоко&quot;</code><code>][</code><code>&quot;зеленое&quot;</code><code>] = </code><code>&quot;хорошее&quot;</code><code>;</code><br>
     <code>?&gt;</code><code> </code></div>
   
   </td>
  </tr>
 </table>
 <p>Обратите внимание, что при присваивании массива всегда происходит
 копирование значения. Чтобы копировать массив по ссылке, вам нужно
 использовать оператор ссылки.</p>
<div class="cdata"><a name=AEN3804></a><code>&lt;?php</code><br>
   <code>$arr1 </code><code>=
   array(</code><code>2</code><code>, </code><code>3</code><code>);</code><br>
   <code>$arr2 </code><code>= </code><code>$arr1</code><code>;</code><br>
   <code>$arr2</code><code>[] = </code><code>4</code><code>; </code><code>// $arr2 изменился,</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//
   $arr1 по прежнему array(2,3)</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code><br>
   <code>$arr3 </code><code>= &amp;</code><code>$arr1</code><code>;</code><br>
   <code>$arr3</code><code>[] = </code><code>4</code><code>; </code><code>// теперь $arr1 и $arr3 эквивалентны</code><br>
   <code>?&gt;</code><code> </code></div>
 
 <h1><a name=language.types.object></a>Объекты</h1>
 <h2><a name=language.types.object.init></a>Инициализация объекта</h2>
 <p>Для инициализации объекта используется выражение <tt>new</tt>, создающее в переменной экземпляр
 объекта.</p>
<div class="cdata"><a name=AEN3812></a><code>&lt;?php</code><br>
   <code>class </code><code>foo</code><br>
   <code>{</code><br>
   <code>&nbsp; &nbsp; function </code><code>do_foo</code><code>()</code><br>
   <code>&nbsp; &nbsp; {</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; echo </code><code>&quot;Doing
   foo.&quot;</code><code>; </code><br>
   <code>&nbsp; &nbsp; }</code><br>
   <code>}</code><br>
   <br>
   <code>$bar </code><code>= new </code><code>foo</code><code>;</code><br>
   <code>$bar</code><code>-&gt;</code><code>do_foo</code><code>();</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Полное рассмотрение производится в разделе Классы и Объекты.</p>
 <h2><a name=language.types.object.casting></a>Преобразование в объект</h2>
 <p>Если объект преобразуется в объект, он не изменяется. Если же в объект
 преобразуется значение любого иного типа, создается новый экземпляр
 встроенного класса <tt>stdClass</tt>.
 Если значение было пустым, новый экземпляр также будет пустым. При любом
 другом значении оно будет содержатся в
 переменной-члене <tt>scalar</tt>.</p>
<div class="cdata"><a name=AEN3821></a><code>&lt;?php</code><br>
   <code>$obj </code><code>= (object) </code><code>'ciao'</code><code>;</code><br>
   <code>echo </code><code>$obj</code><code>-&gt;</code><code>scalar</code><code>;&nbsp; </code><code>//
   </code><code>выведет</code><code>
   'ciao'</code><br>
   <code>?&gt;</code><code> </code></div>
 
 
 <h1><a name=language.types.resource></a>Ресурс</h1>
 <p>Ресурс - это специальная переменная, содержащая ссылку на внешний ресурс.
 Ресурсы создаются и используются специальными функциями. Полный перечень этих
 функций и соответствующих типов ресурсов смотрите в приложении.</p>
 <p><b>Замечание: </b>Тип ресурс был введен в PHP 4</p>
 <h2><a name=language.types.resource.casting></a>Преобразование в ресурс</h2>
 <p>Поскольку тип ресурс содержит специальные указатели на открытые файлы,
 соединения с базой данных, область изображения и тому подобное, вы не можете
 преобразовать какое-либо значение в ресурс.</p>
 <h2><a name=language.types.resource.self-destruct></a>Освобождение ресурсов</h2>
 <p>В связи с системой подсчета ссылок, введенной в движке Zend PHP 4
 автоматически определяется, что ресурс больше никуда не ссылается (как в Java).
 Когда это происходит, все ресурсы, которые использовались для данного ресурса,
 освобождаются сборщиком мусора. По этой причине маловероятно, что когда-либо
 будет необходимо освобождать память вручную, используя какую-нибудь
 free_result функцию.</p>
 <p><b>Замечание: </b>Постоянные ссылки базы данных являются особыми, они <i>не</i> уничтожаются сборщиком мусора. Смотрите также
 раздел о постоянных соединениях.</p>
 <h1><a name=language.types.null></a>NULL</h1>
 <p>Специальное значение <tt><b>NULL</b></tt>
 говорит о том, что эта переменная не имеет значения. <tt><b>NULL</b></tt> - это единственно возможное
 значение типа <b>NULL</b>.</p>
 <p><b>Замечание: </b>Пустой тип был введен в PHP 4</p>
 <p>Переменная считается <tt><b>NULL</b></tt>
 если</p>
<ul>
 <li>ей была присвоена константа <tt><b>NULL</b></tt>.</li>
 <li>ей еще не было присвоено какое-либо значение.</li>
 <li>она была удалена с помощью <b>unset()</b>.</li>
</ul>

 <h2><a name=language.types.null.syntax></a>Синтаксис</h2>
 <p>Существует только одно значение типа <tt><b>NULL</b></tt>
 - регистро-независимое ключевое слово <tt><b>NULL</b></tt>.
</p>
<div class="cdata"><a name=AEN3863></a><code>&lt;?php</code><br>
   <code>$var </code><code>=
   </code><code>NULL</code><code>;&nbsp; &nbsp; &nbsp; &nbsp;</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Смотрите также <b>is_null()</b> и <b>unset()</b>.</p>
 <h1><a name=language.pseudo-types></a>Псевдо-типы, используемые в этой
 документации</h1>
 <h2><a name=language.types.mixed></a>mixed</h2>
 <p><tt>mixed</tt> говорит о том, что
 параметр может принимать множество (но не обязательно все) типов.</p>
 <p><b>gettype()</b>, например, принимает все типы PHP, тогда как <b>str_replace()</b>
 принимает строки и массивы.</p>
 <h2><a name=language.types.number></a>number</h2>
 <p><tt>number</tt> говорит о том, что
 параметр может быть либо <b>integer</b>, либо <b>float</b>.</p>
 <h2><a name=language.types.callback></a>callback</h2>
 <p>Некоторые функции, такие как <b>call_user_func()</b> или <b>usort()</b>
 принимают в качестве параметра определенные пользователем callback-функции.
 Callback-функции могут быть не только простыми функциями, но также методами
 объектов, включая статические методы классов.</p>
 <p>PHP-функция передается просто как строка ее имени. Вы можете передать любую
 встроенную или определенную пользователем функцию за исключением <b>array()</b>,
 <b>echo()</b>, <b>empty()</b>, <b>eval()</b>, <b>exit()</b>, <b>isset()</b>, <b>list()</b>,
 <b>print()</b> и <b>unset()</b>.</p>
 <p>Метод созданного объекта передается как массив, содержащий объект в
 элементе с индексом 0 и имя метода в элементе с индексом 1.</p>
 <p>Методы статических классов также могут быть переданы без создания
 экземпляра объекта передачей имени класса вместо имени объекта в элементе с
 индексом 0.</p>
<div class="cdata"><a name=AEN3901></a><b>Пример 6-11. Примеры callback-функций </b></div>
<div class="cdata"><code>&lt;?php
     </code><br>
     <br>
     <code>// простой
     пример callback</code><br>
     <code>function </code><code>my_callback_function</code><code>() {</code><br>
     <code>&nbsp; &nbsp; echo </code><code>'hello world!'</code><code>;</code><br>
     <code>}</code><br>
     <code>call_user_func</code><code>(</code><code>'my_callback_function'</code><code>); </code><br>
     <br>
     <code>// примеры
     callback-метода</code><br>
     <code>class </code><code>MyClass </code><code>{</code><br>
     <code>&nbsp; &nbsp; function </code><code>myCallbackMethod</code><code>() {</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; echo </code><code>'Hello World!'</code><code>;</code><br>
     <code>&nbsp; &nbsp; }</code><br>
     <code>}</code><br>
     <br>
     <code>// вызов метода
     статического класса без создания объекта</code><br>
     <code>call_user_func</code><code>(array(</code><code>'MyClass'</code><code>, </code><code>'myCallbackMethod'</code><code>)); </code><br>
     <br>
     <code>// вызов метода
     объекта</code><br>
     <code>$obj </code><code>= new </code><code>MyClass</code><code>();</code><br>
     <code>call_user_func</code><code>(array(&amp;</code><code>$obj</code><code>, </code><code>'myCallbackMethod'</code><code>));</code><br>
     <code>?&gt;</code><code> </code></div>
   
   </td>
  </tr>
 </table>
 
 <h1><a name=language.types.type-juggling></a>Манипуляции с типами</h1>
 <p>PHP не требует (и не поддерживает) явного определения типа при объявлении
 переменной; тип переменной определяется по контексту, в котором она
 используется. То есть, если вы присвоите строковое значение переменной <tt><i>$var</i></tt>, <tt><i>$var</i></tt> станет строкой. Если вы затем присвоите <tt><i>$var</i></tt> целочисленное значение, она
 станет целым числом.</p>
 <p>Примером автоматического преобразования типа является оператор сложения
 '+'. Если любой из операндов является числом с плавающей точкой, то все
 операнды интерпретируются как числа с плавающей точкой, результатом будет
 также число с плавающей точкой. В противном случае операнды будут
 интерпретироваться как целые числа и результат также
 будет целочисленным. Обратите внимание, что это НЕ меняет типы самих
 операндов; меняется только то, как они вычисляются.</p>
<div class="cdata"><a name=AEN3911></a><code>&lt;?php</code><br>
   <code>$foo </code><code>=
   </code><code>&quot;0&quot;</code><code>;&nbsp; </code><code>// $foo это строка (ASCII 48)</code><br>
   <code>$foo </code><code>+= </code><code>2</code><code>;&nbsp; &nbsp;</code><code>// $foo теперь целое число (2)</code><br>
   <code>$foo </code><code>= </code><code>$foo </code><code>+ </code><code>1.3</code><code>;&nbsp; </code><code>// $foo теперь число с плавающей
   точкой (3.3)</code><br>
   <code>$foo </code><code>= </code><code>5 </code><code>+ </code><code>&quot;10 Little Piggies&quot;</code><code>; </code><code>// $foo это целое число (15)</code><br>
   <code>$foo </code><code>= </code><code>5 </code><code>+ </code><code>&quot;10 Small Pigs&quot;</code><code>;&nbsp; &nbsp; &nbsp;</code><code>// $foo это целое число (15)</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Если последние два примера вам непонятны, смотрите Преобразование строк в
 числа.</p>
 <p>Если вы хотите, чтобы переменная принудительно вычислялась как определенный
 тип, смотрите раздел приведение типов. Если вы хотите
 изменить тип переменной, смотрите <b>settype()</b>.</p>
 <p>Если вы хотите протестировать любой из примеров, приведенных в данном
 разделе, вы можете использовать функцию <b>var_dump()</b>.</p>
 <p><b>Замечание: </b>Поведение автоматического преобразования в массив в
 настоящий момент не определено.</p>
<div class="cdata"><a name=AEN3923></a><code>&lt;?php</code><br>
   <code>$a </code><code>= </code><code>&quot;1&quot;</code><code>;&nbsp; &nbsp; &nbsp;</code><code>// $a это строка</code><br>
   <code>$a</code><code>[</code><code>0</code><code>] = </code><code>&quot;f&quot;</code><code>;&nbsp; </code><code>// А как же смещение строки? Что
   произойдет?</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Поскольку PHP (по историческим причинам) поддерживает индексирование в
 строках с использованием такого же синтаксиса, как и при индексировании
 массива, вышеприведенный пример приводит к проблеме: следует ли $a стать
 массивом, первым элементом которого будет &quot;f&quot; или &quot;f&quot; должна стать первым символом строки $a?</p>
 <p>Текущая версия PHP воспринимает второе присваивание как определение
 смещения строки, поэтому $a станет &quot;f&quot;, результат же этого
 автоматического преобразования следует, однако, рассматривать как неопределенный.
 В PHP 4 для доступа к символам строки был введен новый синтаксис фигурных
 скобок, используйте этот синтаксис вместо
 вышеприведенного:</p>
<div class="cdata"><a name=AEN3927></a><code>&lt;?php</code><br>
   <code>$a&nbsp; &nbsp; </code><code>= </code><code>&quot;abc&quot;</code><code>; </code><code>// $a это строка</code><br>
   <code>$a</code><code>{</code><code>1</code><code>} = </code><code>&quot;f&quot;</code><code>;&nbsp; &nbsp;</code><code>// $a теперь содержит &quot;afc&quot;</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Для дополнительной информации смотрите раздел
 Доступ к символу в строке.</p>
 <h2><a name=language.types.typecasting></a>Приведение типов</h2>
 <p>Приведение типов в PHP работает так же, как и в C: имя требуемого типа
 записывается в круглых скобках перед приводимой переменной.</p>
<div class="cdata"><a name=AEN3933></a><code>&lt;?php</code><br>
   <code>$foo </code><code>=
   </code><code>10</code><code>;&nbsp; &nbsp;</code><code>// $foo это целое число</code><br>
   <code>$bar </code><code>= (boolean) </code><code>$foo</code><code>;&nbsp; &nbsp;</code><code>// $bar это булев тип</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Допускаются следующие приведения типов:</p>
<ul>
 <li>(int), (integer) - приведение к целому числу</li>
 <li>(bool), (boolean) - приведение к булеву типу</li>
 <li>(float), (double), (real) - приведение к числу
 с плавающей точкой (float)</li>
 <li>(string) - приведение к строке</li>
 <li>(array) - приведение к массиву</li>
 <li>(object) - приведение к объекту</li>
</ul>

 <p>Обратите внимание, что внутри скобок допускаются пробелы и символы
 табуляции, поэтому следующее равносильно по своему действию:</p>
<div class="cdata"><a name=AEN3950></a><code>&lt;?php</code><br>
   <code>$foo </code><code>= (int) </code><code>$bar</code><code>;</code><br>
   <code>$foo </code><code>= ( int ) </code><code>$bar</code><code>;</code><br>
   <code>?&gt;</code><code> </code></div>
 <p><b>Замечание: </b>Вместо приведения переменной к строке, вы можете
 заключить ее в двойные кавычки.</p>
<div class="cdata"><a name=AEN3954></a><code>&lt;?php</code><br>
   <code>$foo </code><code>=
   </code><code>10</code><code>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>// $foo это целое число</code><br>
   <code>$str </code><code>= </code><code>&quot;$foo&quot;</code><code>;&nbsp; &nbsp; &nbsp; &nbsp; </code><code>// $str это строка</code><br>
   <code>$fst </code><code>= (string) </code><code>$foo</code><code>; </code><code>// $fst это также строка</code><br>
   <br>
   <code>// Это напечатает &quot;они одинаковы&quot;</code><br>
   <code>if (</code><code>$fst </code><code>=== </code><code>$str</code><code>) {</code><br>
   <code>&nbsp; &nbsp; echo </code><code>&quot;они одинаковы&quot;;<br>
   }<br>
   ?&gt;   </code></div>
 <p>Возможно, вам не совсем ясно, что происходит при приведении между типами.
 Для дополнительной информации смотрите разделы:
<ul>
 <li>Преобразование в булев тип</li>
 <li>Преобразование в целое число</li>
 <li>Преобразование в число с плавающей точкой</li>
 <li>Преобразование в строку</li>
 <li>Преобразование в массив</li>
 <li>Преобразование в объект</li>
 <li>Преобразование в ресурс</li>
 <li>Таблицы сравнения типов</li>
</ul>

 <p><a name=language.variables><b>Глава 5. Переменные</b></a><b></b></p>
 <p><b>Содержание</b></p>
 <p>Основы</p>
 <p>Предопределенные переменные</p>
 <p>Область видимости переменной</p>
 <p>Переменные переменные</p>
 <p>Переменные вне PHP</p>
 <p><a name=language.variables.basics></a><b>Основы</b></p>
 <p>Переменные в PHP представлены знаком доллара с последующим
 именем переменной. Имя переменной чувствительно к регистру.</p>
 <p>Имена переменных соответствуют тем же правилам, что и
 остальные наименования в PHP. Правильное имя переменной должно начинаться с
 буквы или символа подчеркивания с последующими в любом количестве буквами,
 цифрами или символами подчеркивания Это можно
 отобразить регулярным выражением: '[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'</p>
 <p><b>Замечание: </b>Для наших
 целей буквы здесь - это a-z, A-Z, и ASCII-символы со 127 по 255 (0x7f-0xff).</p>
<div class="cdata"><a name=AEN3991></a>&lt;?php<br>
   $var = &quot;Bob&quot;;<br>
   $Var = &quot;Joe&quot;;<br>
   echo &quot;$var,
   $Var&quot;;&nbsp; &nbsp; &nbsp; // выведет &quot;Bob, Joe&quot;<br>
   <br>
   $4site = 'not yet';&nbsp; &nbsp; &nbsp;//
   неверно; начинается с цифры<br>
   $_4site = 'not yet';&nbsp; &nbsp; // верно; начинается с символа подчеркивания<br>
   $tдyte = 'mansikka';&nbsp; &nbsp; // верно; 'д' это (Дополнительный)
   ASCII 228.<br>
   ?&gt;</div>
 <p>В PHP 3 переменные всегда присваивались по значению. То
 есть, когда вы присваиваете выражение переменной, все значение оригинального
 выражения копируется в эту переменную. Это означает, к примеру, что после
 присвоения одной переменной значения другой, изменение одной из них не влияет
 на значение другой. Дополнительную информацию об этом способе присвоения
 смотрите в разделе Выражения.</p>
 <p>PHP 4 предлагает иной способ присвоения значений
 переменным: присвоение по ссылке. Это означает, что новая переменная просто ссылается
 (иначе говоря, &quot;становится псевдонимом&quot; или &quot;указывает&quot;)
 на оригинальную переменную. Изменения в одной переменной отражаются на
 оригинале, и наоборот. Это также означает, что копирования не происходит; таким образом, присвоение осуществляется быстрее. Однако,
 любое увеличение скорости будет хорошо заметно только в сжатых циклах или при
 присвоении больших массивов или объектов.</p>
 <p>Для присвоения по ссылке, просто добавьте амперсанд (&amp;) к началу имени присваиваемой (исходной)
 переменной. Например, следующий фрагмент кода дважды выводит 'My name is Bob':</p>
<div class="cdata"><a name=AEN4000></a>&lt;?php<br>
   $foo = 'Bob';&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Присваивает $foo значение 'Bob'<br>
   $bar = &amp;$foo;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Ссылка на $foo через $bar.<br>
   $bar = &quot;My name is
   $bar&quot;;&nbsp; // Изменение $bar...<br>
   echo $bar;<br>
   echo $foo;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// меняет и
   $foo.<br>
   ?&gt;</div>
 <p>Важно отметить, что по ссылке могут быть присвоены только
 именованные переменные.</p>
<div class="cdata"><a name=AEN4003></a>&lt;?php<br>
   $foo = 25;<br>
   $bar = &amp;$foo;&nbsp; &nbsp; &nbsp; // Это верное присвоение.<br>
   $bar = &amp;(24 * 7);&nbsp; // Неверно; ссылка на неименованное выражение.<br>
   <br>
   function test()<br>
   {<br>
   &nbsp; &nbsp;return 25;<br>
   }<br>
   <br>
   $bar = &amp;test();&nbsp; &nbsp; // Неверно.<br>
   ?&gt;</div>
 
 <p><a name=language.variables.predefined></a><b>Предопределенные
 переменные</b></p>
 <p>Любому запускаемому скрипту PHP предоставляет большое
 количество предопределенных переменных. Однако,
 многие из этих переменных не могут быть полностью задокументированы, поскольку
 они зависят от запущенного сервера, его версии и настроек, а также других
 факторов. Некоторые из этих переменных не доступны, когда PHP запущен из командной строки. Перечень этих переменных смотрите в разделе Зарезервированные предопределенные переменные.</p>
<p align=center><b>Внимание</b></p>   <p>Начиная с PHP 4.2.0, значение директивы register_globals по
   умолчанию установлено в <i>off</i> (отключено). Это большое изменение в PHP.
   Положение register_globals в <i>off</i> делает предопределенные переменные
   доступными в глобальной области видимости. Например, чтобы получить DOCUMENT_ROOT, вам необходимо
   будет использовать $_SERVER['DOCUMENT_ROOT'] вместо $DOCUMENT_ROOT, или $_GET['id'] из URL http://www.example.com/test.php?id=3 вместо $id, или $_ENV['HOME'] вместо $HOME.</p>
   <p>Дополнительную информацию, связанную с этим
   изменением, вы можете получить, прочитав описание register_globals в
   разделе о настройках, главу о безопасности Использование
   Register Globals , а также сообщения о
   выпусках PHP 4.1.0 и 4.2.0.</p>
   <p>Использование доступных зарезервированных
   предопределенных переменных PHP, таких как суперглобальные
   массивы, является предпочтительным.</p>

 <p>Начиная с версии 4.1.0, PHP предоставляет дополнительный
 набор предопределенных массивов, содержащих переменные web-сервера (если они
 доступны), окружения и пользовательского ввода. Эти новые массивы являются
 особыми, поскольку они автоматически глобальны--то есть, автоматически
 доступны в любой области видимости. По этой причине они также известны как
 'автоглобальные' или 'суперглобальные' переменные. (В PHP нет механизма
 определяемых пользователем суперглобальных переменных.) Суперглобальные
 переменные перечислены ниже; однако, перечисление их содержимого и дальнейшее
 обсуждение предопределенных переменных PHP и их сути смотрите в разделе Зарезервированные предопределенные переменные. Также вы заметите, что старые предопределенные
 переменные ($HTTP_*_VARS) все еще существуют. Начиная с PHP 5.0.0, длинные предопределенные переменные
 массивов PHP могут быть отключены директивой register_long_arrays.</p>
 <p><b>Переменные переменных: </b>Суперглобальные
 переменные не могут быть переменными
 переменных.</p>
 <p>Если некоторые из переменных в variables_order не
 установлены, соответствующие им предопределенные массивы также останутся
 пустыми.</p>
 <p><b>Суперглобальные переменные PHP</b></p>
 <p>$GLOBALS</p>
 <p>Содержит ссылку на каждую
 переменную, доступную в данный момент в глобальной области видимости скрипта.
 Ключами этого массива являются имена глобальны
 переменных. $GLOBALS
 существует, начиная с PHP 3.</p>
 <p>$_SERVER</p>
 <p>Переменные, установленные
 web-сервером либо напрямую связанные с окружением выполнения текущего скрипта.
 Аналог старого массива $HTTP_SERVER_VARS (который по-прежнему доступен, но не рекомендуется).</p>
 <p>$_GET</p>
 <p>Переменные, передаваемые скрипту
 через HTTP GET. Аналог старого массива $HTTP_GET_VARS (который по-прежнему доступен, но не рекомендуется).</p>
 <p>$_POST</p>
 <p>Переменные, передаваемые скрипту
 через HTTP POST. Аналог старого массива $HTTP_POST_VARS (который по-прежнему доступен, но не рекомендуется).</p>
 <p>$_COOKIE</p>
 <p>Переменные, передаваемые скрипту
 через HTTP cookies. Аналог старого массива $HTTP_COOKIE_VARS (который по-прежнему доступен, но не рекомендуется).</p>
 <p>$_FILES</p>
 <p>Переменные, передаваемые скрипту
 через HTTP post-загрузку файлов. Аналог старого массива $HTTP_POST_FILES (который
 по-прежнему доступен, но не рекомендуется). Для дополнительной информации
 смотрите Загрузка методом POST.</p>
 <p>$_ENV</p>
 <p>Переменные, передаваемые скрипту
 через окружение. Аналог старого массива $HTTP_ENV_VARS (который по-прежнему доступен, но не рекомендуется).</p>
 <p>$_REQUEST</p>
 <p>Переменные, передаваемые скрипту
 через механизмы ввода GET, POST и COOKIE, и которым, следовательно, нельзя
 доверять. Наличие и порядок включения переменных в этот массив определяется в
 соответствии с директивой конфигурации PHP variables_order. Этот массив не имеет прямых аналогов в версиях PHP до
 4.1.0. Смотрите также <b>import_request_variables()</b>.</p>

   <p align=center><b>Предостережение</b></p>
   <p>Начиная с PHP 4.3.0, информация о файле из $_FILES больше не существует в
   $_REQUEST.</p>
 <p><b>Замечание: </b>При запуске из командной
 строки , этот массив <i>не</i> будет содержать записей argv и argc; они находятся в массиве $_SERVER.</p>
 <p>$_SESSION</p>
 <p>Переменные, зарегистрированные
 на данный момент в сессии скрипта. Аналог старого массива $HTTP_SESSION_VARS (который
 по-прежнему доступен, но не рекомендуется). Дополнительную информацию смотрите
 в разделе Функции обработки сессии.</p>

 <h1><a name=language.variables.scope></a>Область видимости переменной</h1>
 <p>Область видимости переменной - это среда, в которой она определена. В
 большинстве случаев все переменные PHP имеют единую область видимости. Эта
 единая область видимости охватывает также включаемые (include) и требуемые
 (require) файлы. Например:</p>
<div class="cdata"><a name=AEN4114></a><code>&lt;?php</code><br>
   <code>$a </code><code>= </code><code>1</code><code>;</code><br>
   <code>include </code><code>&quot;b.inc&quot;</code><code>;</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Здесь переменная <tt>$a</tt> будет
 доступна внутри включенного скрипта <tt>b.inc</tt>. Однако,
 внутри определенных пользователем функций вводится локальная область видимости
 функции. Любая, используемая внутри функции переменная, по умолчанию
 ограничена локальной областью видимости функции. Например:</p>
<div class="cdata"><a name=AEN4119></a><code>&lt;?php</code><br>
   <code>$a </code><code>= </code><code>1</code><code>; </code><code>/* глобальная область видимости */ </code><br>
   <br>
   <code>function </code><code>Test</code><code>()</code><br>
   <code>{ </code><br>
   <code>&nbsp; &nbsp; echo </code><code>$a</code><code>; </code><code>/* ссылка на переменную локальной
   области видимости */ </code><br>
   <code>} </code><br>
   <br>
   <code>Test</code><code>();</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Этот скрипт не сгенерирует никакого вывода, поскольку выражение echo
 указывает на локальную версию переменной <tt>$a</tt>,
 а в пределах этой области видимости ей не не было
 присвоено значение. Возможно вы заметили, что это
 немного отличается от языка C в том, что глобальные переменные в C
 автоматически доступны функциям, если только они не были перезаписаны
 локальным определением. Это может вызвать некоторые проблемы, поскольку люди
 могут нечаянно изменить глобальную переменную. В PHP, если глобальная
 переменная будет использоваться внутри функции, она должна быть объявлена глобальной
 внутри нее.</p>
 <h2><a name=language.variables.scope.global></a>Ключевое слово global</h2>
 <p>Сначала пример использования <tt>global</tt>:</p>
<div class="cdata"><a name=AEN4128></a><b>Пример 7-1. Использование global</b></p>
   </div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>$a </code><code>= </code><code>1</code><code>;</code><br>
     <code>$b </code><code>= </code><code>2</code><code>;</code><br>
     <br>
     <code>function </code><code>Sum</code><code>()</code><br>
     <code>{</code><br>
     <code>&nbsp; &nbsp; global </code><code>$a</code><code>,
     </code><code>$b</code><code>;</code><br>
     <br>
     <code>&nbsp; &nbsp; </code><code>$b </code><code>=
     </code><code>$a </code><code>+ </code><code>$b</code><code>;</code><br>
     <code>} </code><br>
     <br>
     <code>Sum</code><code>();</code><br>
     <code>echo </code><code>$b</code><code>;</code><br>
     <code>?&gt;</code><code> </code></div>
   
   </td>
  </tr>
 </table>
 <p>Вышеприведенный скрипт выведет &quot;3&quot;. После определения <tt>$a</tt> и <tt>$b</tt>
 внутри функции как global все ссылки на любую из этих переменных будут
 указывать на их глобальную версию. Не существует никаких ограничений на
 количество глобальных переменных, которые могут обрабатываться функцией.</p>
 <p>Второй способ доступа к переменным глобальной области видимости -
 использование специального, определяемого PHP массива <tt>$GLOBALS</tt>. Предыдущий пример может быть
 переписан так:</p>
<div class="cdata"><a name=AEN4137></a><b>Пример 7-2. Использование </b><tt><b>$GLOBALS</b></tt><b> вместо global</b></p>
   </div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>$a </code><code>= </code><code>1</code><code>;</code><br>
     <code>$b </code><code>= </code><code>2</code><code>;</code><br>
     <br>
     <code>function </code><code>Sum</code><code>()</code><br>
     <code>{</code><br>
     <code>&nbsp; &nbsp; </code><code>$GLOBALS</code><code>[</code><code>&quot;b&quot;</code><code>]
     = </code><code>$GLOBALS</code><code>[</code><code>&quot;a&quot;</code><code>]
     + </code><code>$GLOBALS</code><code>[</code><code>&quot;b&quot;</code><code>];</code><br>
     <code>} </code><br>
     <br>
     <code>Sum</code><code>();</code><br>
     <code>echo </code><code>$b</code><code>;</code><br>
     <code>?&gt;</code><code> </code></div>
   
   </td>
  </tr>
 </table>
 <p><tt>$GLOBALS</tt> - это ассоциативный
 массив, ключом которого является имя, а значением - содержимое глобальной
 переменной. Обратите внимание, что <tt>$GLOBALS</tt>
 существует в любой области видимости, это объясняется тем, что этот массив
 является суперглобальным. Ниже приведен пример, демонстрирующий возможности
 суперглобальных переменных:</p>
<div class="cdata"><a name=AEN4146></a><b>Пример 7-3. Суперглобальные переменные и область
   видимости</b></p>
   </div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>function </code><code>test_global</code><code>()</code><br>
     <code>{</code><br>
     <code>&nbsp; &nbsp; </code><code>// Большинство предопределенных переменных не
     являются</code><br>
     <code>&nbsp; &nbsp; // &quot;супер&quot; и чтобы быть доступными
     в локальной области</code><br>
     <code>&nbsp; &nbsp; // видимости функции требуют указания
     'global'.</code><br>
     <code>&nbsp; &nbsp; </code><code>global </code><code>$HTTP_POST_VARS</code><code>;</code><br>
     <code>&nbsp; &nbsp; </code><br>
     <code>&nbsp; &nbsp; echo </code><code>$HTTP_POST_VARS</code><code>[</code><code>'name'</code><code>];</code><br>
     <code>&nbsp; &nbsp; </code><br>
     <code>&nbsp; &nbsp; </code><code>// Суперглобальные переменные доступны в любой
     области</code><br>
     <code>&nbsp; &nbsp; // видимости и не требуют указания 'global'.</code><br>
     <code>&nbsp; &nbsp; // Суперглобальные переменные
     доступны, начиная с PHP 4.1.0<br>
     &nbsp; &nbsp; echo $_POST['name'];<br>
     }<br>
     ?&gt;     </code></div>
   
   </td>
  </tr>
 </table>
 <h2><a name=language.variables.scope.static></a>Использование статических
 переменных</h2>
 <p>Другой важной возможностью области видимости переменной является <i>статическая</i> переменная. Статическая переменная
 существует только в локальной области видимости функции, но не теряет своего
 значения, когда выполнение программы выходит из этой области видимости.
 Рассмотрим следующий пример:</p>
<div class="cdata"><a name=AEN4154></a><b>Пример 7-4. Демонстрация необходимости статических
   переменных</b></p>
   </div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>function </code><code>Test </code><code>()</code><br>
     <code>{</code><br>
     <code>&nbsp; &nbsp; </code><code>$a </code><code>=
     </code><code>0</code><code>;</code><br>
     <code>&nbsp; &nbsp; echo </code><code>$a</code><code>;</code><br>
     <code>&nbsp; &nbsp; </code><code>$a</code><code>++;</code><br>
     <code>}</code><br>
     <code>?&gt;</code><code> </code></div>
   
   </td>
  </tr>
 </table>
 <p>Эта функция абсолютно бесполезна поскольку при
 каждом вызове она устанавливает <tt>$a</tt>
 в <tt>0</tt> и выводит &quot;0&quot;.
 Инкремент переменной <tt>$a</tt>++ здесь
 не играет роли, так как при выходе из функции переменная <tt>$a</tt> исчезает. Чтобы написать полезную
 считающую функцию, которая не будет терять текущего значения счетчика,
 переменная <tt>$a</tt> объявляется как
 static:</p>
<div class="cdata"><a name=AEN4164></a><b>Пример 7-5. Пример использования статических
   переменных</b></p>
   </div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>function </code><code>Test</code><code>()</code><br>
     <code>{</code><br>
     <code>&nbsp; &nbsp; static </code><code>$a </code><code>=
     </code><code>0</code><code>;</code><br>
     <code>&nbsp; &nbsp; echo </code><code>$a</code><code>;</code><br>
     <code>&nbsp; &nbsp; </code><code>$a</code><code>++;</code><br>
     <code>}</code><br>
     <code>?&gt;</code><code> </code></div>
   
   </td>
  </tr>
 </table>
 <p>Теперь при каждом вызове функция Test() будет выводить значение <tt>$a</tt> и
 инкрементировать его.</p>
 <p>Статические переменные также дают возможность работать с рекурсивными
 функциями. Рекурсивной является функция, вызывающая саму себя. При написании
 рекурсивной функции нужно быть внимательным, поскольку есть вероятность
 сделать рекурсию бесконечной. Вы должны убедиться, что существует адекватный
 способ завершения рекурсии. Следующая простая функция рекурсивно считает до
 10, используя для определения момента остановки статическую переменную <tt>$count</tt>:</p>
<div class="cdata"><a name=AEN4172></a><b>Пример 7-6. Статические переменные и рекурсивные
   функции</b></p>
   </div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>function </code><code>Test</code><code>()</code><br>
     <code>{</code><br>
     <code>&nbsp; &nbsp; static </code><code>$count </code><code>=
     </code><code>0</code><code>;</code><br>
     <br>
     <code>&nbsp; &nbsp; </code><code>$count</code><code>++;</code><br>
     <code>&nbsp; &nbsp; echo </code><code>$count</code><code>;</code><br>
     <code>&nbsp; &nbsp; if (</code><code>$count </code><code>&lt;     </code><code>10</code><code>) {</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; </code><code>Test
     </code><code>();</code><br>
     <code>&nbsp; &nbsp; }</code><br>
     <code>&nbsp; &nbsp; </code><code>$count</code><code>--;</code><br>
     <code>}</code><br>
     <code>?&gt;</code><code> </code></div>
   
   </td>
  </tr>
 </table>
 <p><b>Замечание: </b>Статические переменные могут быть объявлены так, как
 показано в предыдущем примере. Попытка присвоить этим переменным значения,
 являющиеся результатом выражений, вызовет ошибку обработки.</p>
<div class="cdata"><a name=AEN4178></a><b>Пример 7-7. Объявление статических переменных</b></p>
   </div>
<div class="cdata"><code>&lt;?php</code><br>
     <code>function </code><code>foo</code><code>(){</code><br>
     <code>&nbsp; &nbsp; static </code><code>$int </code><code>= </code><code>0</code><code>;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code><code>// верно</code><br>
     <code>&nbsp; &nbsp; </code><code>static </code><code>$int </code><code>= </code><code>1</code><code>+</code><code>2</code><code>;&nbsp; &nbsp; &nbsp; &nbsp; </code><code>// неверно&nbsp; (поскольку
     это выражение)</code><br>
     <code>&nbsp; &nbsp; </code><code>static </code><code>$int </code><code>= </code><code>sqrt</code><code>(</code><code>121</code><code>);&nbsp; </code><code>// неверно&nbsp; (поскольку это тоже выражение)</code><br>
     <br>
     <code>&nbsp; &nbsp; </code><code>$int</code><code>++;</code><br>
     <code>&nbsp; &nbsp; echo </code><code>$int</code><code>;</code><br>
     <code>}</code><br>
     <code>?&gt;</code><code> </code></div>
   
   </td>
  </tr>
 </table>
 <h2><a name=language.variables.scope.references></a>Ссылки с глобальными и
 статическими переменными</h2>
 <p>Движок Zend 1, лежащий в основе <tt>PHP 4</tt>,
 оперирует модификаторами переменных static и global как ссылками. Например,
 реальная глобальная переменная, внедренная в область видимости функции
 указанием ключевого слова <tt>global</tt>,
 в действительности создает ссылку на глобальную переменную. Это может привести
 к неожиданному поведению, как это показано в следующем примере:</p>
<div class="cdata"><a name=AEN4189></a><code>&lt;?php</code><br>
   <code>function </code><code>test_global_ref</code><code>()
   {</code><br>
   <code>&nbsp; &nbsp; global </code><code>$obj</code><code>;</code><br>
   <code>&nbsp; &nbsp; </code><code>$obj </code><code>=
   &amp;new </code><code>stdclass</code><code>;</code><br>
   <code>}</code><br>
   <br>
   <code>function </code><code>test_global_noref</code><code>()
   {</code><br>
   <code>&nbsp; &nbsp; global </code><code>$obj</code><code>;</code><br>
   <code>&nbsp; &nbsp; </code><code>$obj </code><code>=
   new </code><code>stdclass</code><code>;</code><br>
   <code>}</code><br>
   <br>
   <code>test_global_ref</code><code>();</code><br>
   <code>var_dump</code><code>(</code><code>$obj</code><code>);</code><br>
   <code>test_global_noref</code><code>();</code><br>
   <code>var_dump</code><code>(</code><code>$obj</code><code>);</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Выполнение этого примера сгенерирует следующий вывод:</p>
<div class="cdata"><pre>NULL</pre><pre>object(stdClass)(0) {</pre><pre>}</pre></div>
 <p>Аналогично ведет себя и выражение <tt>static</tt>.
 Ссылки не хранятся статично:</p>
<div class="cdata"><a name=AEN4195></a><code>&lt;?php</code><br>
   <code>function &amp;</code><code>get_instance_ref</code><code>()
   {</code><br>
   <code>&nbsp; &nbsp; static </code><code>$obj</code><code>;</code><br>
   <br>
   <code>&nbsp; &nbsp; echo </code><code>&quot;Static
   object: &quot;</code><code>;</code><br>
   <code>&nbsp; &nbsp; </code><code>var_dump</code><code>(</code><code>$obj</code><code>);</code><br>
   <code>&nbsp; &nbsp; if (!isset(</code><code>$obj</code><code>))
   {</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; </code><code>//
   </code><code>Присвоить</code><code> </code><code>ссылку</code><code> </code><code>статической</code><code> </code><code>переменной</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; </code><code>$obj
   </code><code>= &amp;new </code><code>stdclass</code><code>;</code><br>
   <code>&nbsp; &nbsp; }</code><br>
   <code>&nbsp; &nbsp; </code><code>$obj</code><code>-&gt;</code><code>property</code><code>++;</code><br>
   <code>&nbsp; &nbsp; return </code><code>$obj</code><code>;</code><br>
   <code>}</code><br>
   <br>
   <code>function &amp;</code><code>get_instance_noref</code><code>()
   {</code><br>
   <code>&nbsp; &nbsp; static </code><code>$obj</code><code>;</code><br>
   <br>
   <code>&nbsp; &nbsp; echo </code><code>&quot;Static
   object: &quot;</code><code>;</code><br>
   <code>&nbsp; &nbsp; </code><code>var_dump</code><code>(</code><code>$obj</code><code>);</code><br>
   <code>&nbsp; &nbsp; if (!isset(</code><code>$obj</code><code>))
   {</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; </code><code>//
   </code><code>Присвоить</code><code> </code><code>объект</code><code> </code><code>статической</code><code> </code><code>переменной</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; </code><code>$obj
   </code><code>= new </code><code>stdclass</code><code>;</code><br>
   <code>&nbsp; &nbsp; }</code><br>
   <code>&nbsp; &nbsp; </code><code>$obj</code><code>-&gt;</code><code>property</code><code>++;</code><br>
   <code>&nbsp; &nbsp; return </code><code>$obj</code><code>;</code><br>
   <code>}</code><br>
   <br>
   <code>$obj1 </code><code>= </code><code>get_instance_ref</code><code>();</code><br>
   <code>$still_obj1 </code><code>= </code><code>get_instance_ref</code><code>();</code><br>
   <code>echo </code><code>&quot;\n&quot;</code><code>;</code><br>
   <code>$obj2 </code><code>= </code><code>get_instance_noref</code><code>();</code><br>
   <code>$still_obj2 </code><code>= </code><code>get_instance_noref</code><code>();</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Выполнение этого примера сгенерирует следующий вывод:</p>
<div class="cdata"><pre>Static object: NULL</pre><pre>Static object: NULL</pre><pre> </pre><pre>Static object: NULL</pre><pre>Static object: object(stdClass)(1) {</pre><pre>  [&quot;property&quot;]=&gt;</pre><pre>  int(1)</pre><pre>}</pre></div>
 <p>Этот пример демонстрирует, что при присвоении ссылки статической переменной
 она не <i>запоминается</i>, когда вы вызываете
 функцию <tt>&amp;get_instance_ref()</tt>
 во второй раз.</p>
 <p><a name=language.variables.variable></a><b>Переменные
 переменные</b></p>
 <p>Иногда бывает удобно иметь переменными имена переменных.
 То есть, имя переменной, которое может быть определено и изменено динамически.
 Обычная переменная определяется примерно таким выражением:</p>
<div class="cdata"><a name=AEN4205></a>&lt;?php<br>
   $a = &quot;hello&quot;;<br>
   ?&gt;</div>
 <p>Переменная переменная берет значение переменной и
 рассматривает его как имя переменной. В вышеприведенном примере <i>hello</i>
 может быть использовано как имя переменной при помощи двух знаков доллара. То
 есть:</p>
<div class="cdata"><a name=AEN4209></a>&lt;?php<br>
   $$a = &quot;world&quot;;<br>
   ?&gt;</div>
 <p>Теперь в дереве символов PHP определены и содержатся две
 переменные: $a, содержащая &quot;hello&quot;, и $hello, содержащая
 &quot;world&quot;. Таким образом, выражение</p>
<div class="cdata"><a name=AEN4214></a>&lt;?php<br>
   echo &quot;$a
   ${$a}&quot;;<br>
   ?&gt;</div>
 <p>выведет то же, что и</p>
<div class="cdata"><a name=AEN4217></a>&lt;?php<br>
   echo &quot;$a
   $hello&quot;;<br>
   ?&gt;</div>
 <p>то есть, они оба выведут: hello
 world.</p>
 <p>Для того чтобы использовать переменные переменные
 с массивами, вы должны решить проблему двусмысленности. То есть, если вы
 напишете $$a[1],
 обработчику необходимо знать, хотите ли вы использовать $a[1] в качестве переменной,
 либо вам нужна как переменная $$a, а затем ее индекс [1]. Синтаксис для разрешения этой
 двусмысленности таков: ${$a[1]} для первого случая и ${$a}[1] для второго.</p>
<p align=center><b>Внимание</b></p>
   <p>Пожалуйста, обратите внимание, что переменные
   переменные не могут использоваться с Суперглобальными массивами
   PHP. Это означает, что вы не можете делать что-то вроде ${$_GET}. Если вы ищете способ
   использовать суперглобальные переменные и старые HTTP_*_VARS, вы можете
   попробовать ссылаться на них.</p>
 
<h1><a name=language.variables.external></a>Переменные вне PHP</h1>
<h2><a name=language.variables.external.form></a>HTML-формы (GET и POST)</h2>

<p>Когда происходит отправка данных формы PHP-скрипту, информация из этой
формы автоматически становится доступной ему. Существует много способов
получения этой информации, например:</p>

<p><a name=AEN4239></a><b>Пример 7-8. Простая HTML-форма</b></p>
<div class="cdata"><pre>&lt;form action=&quot;foo.php&quot; method=&quot;post&quot;&gt;</pre><pre>    Имя:  &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;&lt;br /&gt;</pre><pre>    Email: &lt;input type=&quot;text&quot; name=&quot;email&quot; /&gt;&lt;br /&gt;</pre><pre>    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Отправь меня!&quot; /&gt;</pre><pre>&lt;/form&gt;</pre></div>
   
<p>В зависимости от вашей индивидуальной установки и личных настроек
существует много способов доступа к данным из ваших
HTML-форм. Вот несколько примеров:</p>
<p><a name=AEN4244></a><b>Пример 7-9. Доступ к данным из простой HTML POST-формы</b></p>

<div class="cdata"><pre>&lt;?php </pre><pre>// Доступно, начиная с PHP 4.1.0</pre><pre> </pre><pre>   echo $_POST['username'];</pre><pre>   echo $_REQUEST['username'];</pre><pre> </pre><pre>   import_request_variables('p', 'p_');</pre><pre>   echo $p_username;</pre><pre> </pre><pre>// Доступно, начиная с PHP 3. Начиная с PHP 5.0.0, эти длинные предопределенные</pre><pre>// переменные могут быть отключены директивой register_long_arrays.</pre><pre> </pre><pre>   echo $HTTP_POST_VARS['username'];</pre><pre> </pre><pre>// Доступно, если директива PHP register_globals = on. Начиная</pre><pre>// с PHP 4.2.0, значение по умолчанию register_globals = off.</pre><pre>// Использование/доверие этому методу непредпочтительно.</pre><pre> </pre><pre>   echo $username;</pre><pre>?&gt;</pre></div>

 <p>GET-форма используется аналогично, за исключением того, что вместо POST вам
 нужно будет использовать соответствующую предопределенную переменную GET. GET
 относится также к QUERY_STRING (информация в URL после '?'). Так, например, <tt>http://www.example.com/test.php?id=3</tt>
 содержит GET-данные, доступные как <tt>$_GET['id']</tt>.
 Смотрите также $_REQUEST и <b>import_request_variables()</b>.</p>
 <p><b>Замечание: </b>Суперглобальные массивы, такие как <tt>$_POST</tt> и <tt>$_GET</tt>,
 стали доступны в PHP 4.1.0</p>
 <p>Как уже говорилось, до PHP 4.2.0 значением register_globals по умолчанию
 было <i>on</i> (включено). А в PHP 3 оно всегда
 было включено. Сообщество PHP рекомендует всем не полагаться на эту директиву,
 поскольку предпочтительно присвоить ей значение <i>off</i>
 и писать программы исходя из этого.</p>
 <p><b>Замечание: </b>Конфигурационная директива magic_quotes_gpc влияет на
 значения Get, Post и Cookie. Если она включена, значение (It's
 &quot;PHP!&quot;) автоматически станет (It\'s \&quot;PHP!\&quot;).
 Мнемонизация необходима при добавлении в базу данных.
 Смотрите также <b>addslashes()</b>, <b>stripslashes()</b> и magic_quotes_sybase.
</p>
 <p>PHP также понимает массивы в контексте переменных формы. К примеру, вы
 можете сгруппировать связанные переменные вместе или использовать эту
 возможность для получения значений списка множественного выбора select.
 Например, давайте отправим форму самой себе, а после отправки отобразим
 данные:</p>
<p><a name=AEN4270></a><b>Пример 7-10. Более сложные переменные формы</b></p>

<div class="cdata"><code>&lt;?php</code><br>
     <code>if (isset(</code><code>$_POST</code><code>[</code><code>'action'</code><code>])
     &amp;&amp; </code><code>$_POST</code><code>[</code><code>'action'</code><code>]
     == </code><code>'submitted'</code><code>)
     {</code><br>
     <code>&nbsp; &nbsp; echo </code><code>'&lt;pre&gt;'</code><code>;</code><br>
     <code>&nbsp; &nbsp; </code><code>print_r</code><code>(</code><code>$_POST</code><code>);</code><br>
     <code>&nbsp; &nbsp; echo </code><code>'&lt;a
     href=&quot;'</code><code>. </code><code>$_SERVER</code><code>[</code><code>'PHP_SELF'</code><code>]
     .</code><code>'&quot;&gt;</code><code>Попробуйте</code><code> </code><code>еще</code><code> </code><code>раз</code><code>&lt;/a&gt;'</code><code>;</code><br>
     <br>
     <code>&nbsp; &nbsp; echo </code><code>'&lt;/pre&gt;'</code><code>;</code><br>
     <code>} else {</code><br>
     <code>?&gt;</code><br>
     <code>&lt;form action=&quot;&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;&quot;     method=&quot;post&quot;&gt;</code><br>
     <code>&nbsp; &nbsp; </code><code>Имя</code><code>:&nbsp; &lt;input type=&quot;text&quot;     name=&quot;personal[name]&quot; /&gt;&lt;br /&gt;</code><br>
     <code>&nbsp; &nbsp; Email: &lt;input type=&quot;text&quot;     name=&quot;personal[email]&quot; /&gt;&lt;br /&gt;</code><br>
     <code>&nbsp; &nbsp; </code><code>Пиво</code><code>: &lt;br /&gt;</code><br>
     <code>&nbsp; &nbsp; &lt;select multiple
     name=&quot;beer[]&quot;&gt;</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &lt;option
     value=&quot;warthog&quot;&gt;Warthog&lt;/option&gt;</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &lt;option
     value=&quot;guinness&quot;&gt;Guinness&lt;/option&gt;</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &lt;option
     value=&quot;stuttgarter&quot;&gt;Stuttgarter Schwabenbr</code><code>д</code><code>u&lt;/option&gt;</code><br>
     <code>&nbsp; &nbsp; &lt;/select&gt;&lt;br /&gt;</code><br>
     <code>&nbsp; &nbsp; &lt;input type=&quot;hidden&quot;     name=&quot;action&quot; value=&quot;submitted&quot; /&gt;</code><br>
     <code>&nbsp; &nbsp; &lt;input type=&quot;submit&quot;     name=&quot;submit&quot; value=&quot;</code><code>Отправь</code><code> </code><code>меня</code><code>!&quot; /&gt;</code><br>
     <code>&lt;/form&gt;</code><br>
     <code>&lt;?php</code><br>
     <code>}</code><br>
     <code>?&gt; </code></div>
   
 <p>В PHP 3 использование массивов в переменных формы ограничено одномерными
 массивами. В PHP 4 таких ограничений нет.</p>
 <h3><a name=language.variables.external.form.submit></a>Имена переменных
 кнопки-изображения</h3>
 <p>При отправке формы вместо стандартной кнопки можно использовать изображение
 с помощью тега такого вида:</p>
<div class="cdata"><pre><a name=AEN4277></a>&lt;input type=&quot;image&quot; src=&quot;image.gif&quot; name=&quot;sub&quot; /&gt;</pre></div>
 <p>Когда пользователь щелкнет где-нибудь на изображении, соответствующая форма
 будет передана на сервер с двумя дополнительными переменными - sub_x и sub_y.
 Они содержат координаты нажатия пользователя на изображение. Опытные
 программисты могут заметить, что на самом деле имена переменных, отправленных
 браузером, содержат точку, а не подчеркивание, но PHP автоматически
 конвертирует точку в подчеркивание.</p>
 <h2><a name=language.variables.external.cookies></a>HTTP Cookies</h2>
 <p>PHP явно поддерживает HTTP cookies как определено в спецификации Netscape.
 Cookies - это механизм для хранения данных в удаленном браузере и отслеживания
 и идентификации таким образом вернувшихся
 пользователей. Вы можете установить cookies, используя функцию <b>setcookie()</b>.
 Cookies являются частью HTTP-заголовка, поэтому функция SetCookie должна
 вызываться до того, как браузеру будет отправлен какой бы то
 ни было вывод. Это ограничение аналогично ограничению функции <b>header()</b>.
 Данные, хранящиеся в cookie, доступны в соответствующих массивах данных
 cookie, таких как <tt>$_COOKIE</tt>, <tt>$HTTP_COOKIE_VARS</tt>, а также в <tt>$_REQUEST</tt>. Подробности и примеры смотрите
 на странице <b>setcookie()</b> руководства.</p>
 <p>Если вы хотите присвоить множество значений одной переменной cookie, вы
 можете присвоить их как массив. Например:</p>
<div class="cdata"><a name=AEN4291></a><code>&lt;?php</code><br>
   <code>&nbsp; setcookie</code><code>(</code><code>&quot;MyCookie[foo]&quot;</code><code>, </code><code>&quot;</code><code>Тест</code><code>
   1&quot;</code><code>, </code><code>time</code><code>()+</code><code>3600</code><code>);</code><br>
   <code>&nbsp; </code><code>setcookie</code><code>(</code><code>&quot;MyCookie[bar]&quot;</code><code>, </code><code>&quot;</code><code>Тест</code><code>
   2&quot;</code><code>, </code><code>time</code><code>()+</code><code>3600</code><code>);</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>Это создаст две разные cookie, хотя в вашем
 скрипте MyCookie будет теперь одним массивом. Если вы хотите установить именно
 одну cookie со множеством значений, примите во
 внимание сначала применение к значениям таких функций, как <b>serialize()</b>
 или <b>explode()</b>.</p>
 <p>Обратите внимание, что cookie заменит предыдущую
 cookie с тем же именем в вашем браузере, если только путь или домен не
 отличаются. Так, для приложения корзины покупок вы, возможно, захотите
 сохранить счетчик. То есть:</p>
<p><a name=AEN4297></a><b>Пример 7-11. A setcookie() example</b></p>
   </p>
<div class="cdata"><code>&lt;?php</code><br>
     <code>if (isset(</code><code>$_COOKIE</code><code>[</code><code>'count'</code><code>]))
     {</code><br>
     <code>&nbsp; &nbsp; </code><code>$count </code><code>=
     </code><code>$_COOKIE</code><code>[</code><code>'count'</code><code>]
     + </code><code>1</code><code>;</code><br>
     <code>} else {</code><br>
     <code>&nbsp; &nbsp; </code><code>$count </code><code>=
     </code><code>1</code><code>;</code><br>
     <code>}</code><br>
     <code>setcookie</code><code>(</code><code>&quot;count&quot;</code><code>,
     </code><code>$count</code><code>, </code><code>time</code><code>()+</code><code>3600</code><code>);</code><br>
     <code>setcookie</code><code>(</code><code>&quot;Cart[$count]&quot;</code><code>,
     </code><code>$item</code><code>, </code><code>time</code><code>()+</code><code>3600</code><code>);</code><br>
     <code>?&gt;</code><code> </code></div>
   
 <h2><a name=language.variables.external.dot-in-names></a>Точки в именах
 приходящих переменных</h2>
 <p>Как правило, PHP не меняет передаваемых скрипту имен переменных. Однако
 следует отметить, что точка не является корректным символом в имени переменной
 PHP. Поэтому рассмотрим такую запись:</p>

<div class="cdata"><code>&lt;?php</code><br>
   <code>$varname</code><code>.</code><code>ext</code><code>;&nbsp; </code><code>/* неверное имя переменной */</code><br>
   <code>?&gt;</code><code> </code></div>
 <p>В данном случае интерпретатор видит переменную <tt>$varname</tt>, после которой идет оператор конкатенации, а
 затем голая строка (то есть, не заключенная в кавычки строка, не
 соответствующая ни одному из ключевых или зарезервированных слов) 'ext'.
 Очевидно, что это не даст ожидаемого результата.</p>
 <p>По этой причине важно заметить, что PHP будет автоматически заменять любые
 точки в именах приходящих переменных на символы подчеркивания.</p>
 <h2><a name=language.variables.determining-type-of></a>Определение типов
 переменных</h2>
 <p>Поскольку PHP определяет и конвертирует типы переменных (в большинстве
 случаев) как надо, не всегда очевидно, какой тип имеет данная переменная в
 конкретный момент времени. PHP содержит несколько функций, позволяющих
 определить тип переменной, таких как: <b>gettype()</b>, <b>is_array()</b>, <b>is_float()</b>,
 <b>is_int()</b>, <b>is_object()</b> и <b>is_string()</b>. Смотрите также раздел Типы.</p>
 <p><a name=language.constants><b>Глава 6. Константы</b></a><b></b></p>
 <p><b>Содержание</b></p>
 <p>Синтаксис</p>
 <p>Предопределенные константы</p>
 <p>Константы - это идентификаторы простых значений. Исходя из
 их названия, нетрудно понять, что их значение не может изменяться в ходе
 выполнения скрипта (исключения представляют &quot;волшебные&quot; константы, которые на самом деле не являются константами в полном
 смысле этого слова). Имена констант чувствительны к регистру. По принятому
 соглашению, имена констант всегда пишутся в верхнем регистре.</p>
 <p>Имя константы должно соответствовать тем же правилам,
 которыми руководствуются и другие имена в PHP. Правильное имя начинается с
 буквы или символа подчеркивания и состоит из букв, цифр и подчеркиваний.
 Регулярное выражение для проверки правильности имени константы выглядит так: [a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*</p>
 <p><b>Замечание: </b>Понятие
 &quot;буквы&quot; здесь - это символы a-z, A-Z, и другие символы с
 ASCII-кодами от 127 до 255 (0x7f-0xff).</p>
 <p>Как и суперглобальные
 переменные, константы доступны из любой
 области видимости. Вы можете использовать константы в любом месте вашего
 скрипта, не обращая внимания на текущую область видимости. Подробную
 информацию об областях видимости можно найти здесь.</p>
 <p><a name=language.constants.syntax></a><b>Синтаксис</b></p>
 <p>Вы можете определить константу с помощью функции <b>define()</b>. После того,
 как константа определена, ее значение не может быть изменено или аннулировано.
</p>
 <p>Константы могут содержать только скалярные данные
 (логического, целого, плавающего и строкового типов).</p>
 <p>Получить значение константы можно, указав ее имя. В
 отличие от переменных, вам <i>не потребуется</i> предварять имя константы
 символом $.
 Также вы можете использовать функцию <b>constant()</b> для получения значения константы, если вы формируете имя
 константы динамически. Используйте функцию <b>get_defined_constants()</b> для получения списка всех объявленных констант.</p>
 <p><b>Замечание: </b>Константы
 и (глобальные) переменные находятся в разном пространстве имен. Это означает,
 что, например, <b>TRUE</b> и $TRUE являются совершенно разными вещами.</p>
 <p>Если вы используете неопределенную константу, PHP
 предполагает, что вы имеете ввиду само
 имя константы, как если бы вы указали переменную типа строка (CONSTANT и
 &quot;CONSTANT&quot;). При этом будет сгенерирована ошибка типа E_NOTICE. Смотрите также
 главу руководства, которая разъясняет, почему $foo[bar] - это неправильно (конечно, если вы перед этим не
 объявили bar
 как константу с помощью <b>define()</b>). Если вы просто хотите проверить, определена ли
 константа, используйте функцию <b>defined()</b>.</p>
 <p>Различия между константами и переменными:</p>
 <ul type=disc>
  <li>У констант нет
      приставки в виде знака доллара ($); </li>
  <li>Константы можно
      определить только с помощью функции <b>define()</b>,
      а не присваиванием значения; </li>
  <li>Константы могут
      быть определены и доступны в любом месте без учета области видимости; </li>
  <li>Константы не могут
      быть определены или аннулированы после первоначального объявления; и </li>
  <li>Константы могут
      иметь только скалярные значения. </li>
 </ul>
<p><a name=AEN4368></a><b>Пример 8-1. Определение констант</b></p>

<div class="cdata">&lt;?php<br>
     define(&quot;CONSTANT&quot;, &quot;Здравствуй, мир.&quot;);<br>
     echo CONSTANT; // выводит &quot;Здравствуй, мир.&quot;<br>
     echo Constant; // выводит
     &quot;Constant&quot; и выводит предупреждениее.<br>
     ?&gt;</div>
 
 <p><a name=language.constants.predefined></a><b>Предопределенные
 константы</b></p>
 <p>PHP предоставляет большой список предопределенных констант
 для каждого выполняемого скрипта. Многие из этих констант определяются
 различными модулями и будут присутствовать только в том случае, если
 эти модули доступны в результате динамической загрузки или в результате
 статической сборки.</p>
 <p>Есть пять волшебных констант, которые меняют свое значение
 в зависимости от контекста, в котором они используются. Например, значение <b>__LINE__</b> зависит от строки в
 скрипте, на которой эта константа указана. Специальные константы
 нечувствительны к регистру и их список приведен ниже:</p>
 <p><a
 name=AEN4377></a><b>Таблица 8-1. Некоторые
 &quot;волшебные&quot; константы PHP</b></p>
 <table border=1 cellpadding=0>
  <thead>
   <tr>
    <td>
    <p><b>Имя</b></p>
    </td>
    <td>
    <p><b>Описание</b></p>
    </td>
   </tr>
  </thead>
  <tr>
   <td>
   <p><b>__LINE__</b></p>
   </td>
   <td>
   <p>Текущая строка в файле.</p>
   </td>
  </tr>
  <tr>
   <td>
   <p><b>__FILE__</b></p>
   </td>
   <td>
   <p>Полный путь и имя текущего
   файла.</p>
   </td>
  </tr>
  <tr>
   <td>
   <p><b>__FUNCTION__</b></p>
   </td>
   <td>
   <p>Имя функции. (Добавлена в PHP
   4.3.0.)</p>
   </td>
  </tr>
  <tr>
   <td>
   <p><b>__CLASS__</b></p>
   </td>
   <td>
   <p>Имя класса. (Добавлена в PHP
   4.3.0.)</p>
   </td>
  </tr>
  <tr>
   <td align="top">
   <p><b>__METHOD__</b></p>
   </td>
   <td>
   <p>Имя метода класса. (Добавлена в
   PHP 5.0.0)</div>
 <p>С полным списком предопределенных констант можно
 ознакомиться в соответствующем разделе.</p>
 <p><a name=language.expressions><b>Глава 9. Выражения</b></a><b></b></p>
 <p>Выражения - это краеугольный камень PHP. Почти все, что вы
 пишите в PHP, является выражением. Самое простое и точное определение
 выражения - &quot;все что угодно, имеющее значение&quot;.</p>
 <p>Основными формами выражений являются константы и
 переменные. Если вы записываете &quot;$a = 5&quot;, вы присваиваете '5' переменной $a. '5', очевидно, имеет значение 5 или, другими словами, '5' это
 выражение со значением 5 (в данном случае '5' это целочисленная константа).</p>
 <p>После этого присвоения вы ожидаете, что значением $a также
 является 5, поэтому, если вы написали $b = $a, вы полагаете, что работать это
 будет так же, как если бы вы написали $b = 5. Другими словами, $a это также
 выражение со значением 5. Если все работает верно, то именно так и произойдет.
</p>
 <p>Немного более сложными примерами выражений являются
 функции. Например, рассмотрим следующую функцию:</p>
<div class="cdata"><a name=AEN4413></a>&lt;?php<br>
   function foo ()<br>
   {<br>
   &nbsp; &nbsp; return 5;<br>
   }<br>
   ?&gt;</div>
 <p>Исходя из того, что вы хорошо знакомы с концепцией функций
 (если нет, то прочитайте главу о функциях), вы полагаете, что запись $c =
 foo() абсолютно эквивалента записи $c = 5, и вы правы. Функции -
 это выражения, значением которых является то, что возвращает функция.
 Поскольку foo() возвращает 5, значением выражения 'foo()' является 5. Как
 правило, функции возвращают не просто статическое значение, а что-то
 вычисляют.</p>
 <p>Разумеется, значения в PHP не обязаны быть целочисленными,
 и очень часто ими не являются. PHP поддерживает три типа скалярных значений: целочисленные, с плавающей точкой и строковые значения (скалярными являются
 значения, которые вы не можете 'разбить' на меньшие части, в отличие,
 например, от массивов). PHP поддерживает также два комбинированных (не
 скалярных) типа: массивы и объекты. Каждый из этих типов значений может
 присваиваться переменной или возвращаться функцией.</p>
 <p>До сих пор пользователи PHP/FI 2 не должны были
 почувствовать каких-либо изменений. Однако PHP, как и многие другие языки,
 понимает гораздо больше выражений. PHP - это язык, ориентированный на
 выражения и рассматривающий почти все как выражение. Вернемся к примеру, с
 которым мы уже имели дело: '$a = 5'. Легко заметить, что здесь присутствуют
 два значения - значение целочисленной константы '5' и значение переменной $a,
 также принимающей значение 5. Но на самом деле здесь присутствует и еще одно
 значение - значение самого присвоения. Само присвоение вычисляется в
 присвоенное значение, в данном случае - в 5. На практике это означает, что '$a
 = 5', независимо от того, что оно делает, является
 выражением со значением 5. Таким образом, запись '$b = ($a = 5)' равносильна
 записи '$a = 5; $b = 5;' (точка с запятой обозначает конец выражения).
 Поскольку операции присвоения анализируются справа налево, вы также можете
 написать '$b = $a = 5'.</p>
 <p>Другой хороший пример ориентированности на выражения -
 пре- и постфиксный инкремент и декремент. Пользователи PHP/FI 2 и многих
 других языков возможно уже знакомы с формой записи переменная++ и
 переменная--. Это операторы инкремента и декремента. В PHP/FI 2 операция
 '$a++' не имеет значения (это не выражение), и, таким образом, вы не можете
 присвоить ее или каким-либо образом использовать. PHP увеличивает возможности
 инкремента/декремента, также сделав их выражениями, как в C. Также как и C, PHP
 поддерживает два типа инкремента - префиксный и постфиксный. Они оба
 инкрементируют значение переменной и эффект их действия на нее одинаков.
 Разница состоит в значении выражения инкремента. Префиксный инкремент,
 записываемый как '++$variable', вычисляется в инкрементированное значение (PHP
 инкрементирует переменную перед тем как прочесть ее
 значение, отсюда название 'пре-инкремент'). Постфиксный инкремент,
 записываемый как '$variable++', вычисляется в первоначальное значение
 переменной $variable перед ее приращением (PHP инкрементирует переменную после
 прочтения ее значения, отсюда название 'пост-инкремент').</p>
 <p>Очень распространенным типом выражений являются выражения
 сравнения. Они вычисляются в 0 или 1, означающих соответственно <b>FALSE</b> (ложь) или <b>TRUE</b> (истину). PHP поддерживает &gt; (больше), &gt;= (больше либо равно), ==
 (равно), != (не равно), &lt; (меньше) и &lt;= (меньше либо равно). Он
 также поддерживает операторы строгого равенства: === (равно и одного типа) и !== (не равно или не одного типа). Чаще всего эти выражения
 используются в условиях выполнения операторов, таких как if.</p>
 <p>Последний пример выражений, который мы здесь рассмотрим,
 это смешанные выражения операции и присвоения. Вы уже знаете, что если вы
 хотите увеличить $a на 1, вы можете просто написать '$a++' или '++$a'. Но что,
 если вы хотите прибавить больше, чем единицу, например, 3? Вы могли бы
 написать '$a++' много раз, однако, очевидно это не очень рациональный или
 удобный способ. Гораздо более распространенной практикой является запись вида
 '$a = $a + 3'. '$a + 3' вычисляется в значение $a плюс 3 и снова присваивается
 $a, увеличивая в результате $a на 3. В PHP, как и в некоторых других языках,
 таких как C, вы можете записать это более коротким образом, что увеличит
 очевидность смысла и быстроту понимания кода по прошествии времени. Прибавить
 3 к текущему значению $a можно с помощью записи '$a += 3'. Это означает
 дословно &quot;взять значение $a, прибавить к нему 3 и снова присвоить его
 переменной $a&quot;. Кроме большей понятности и краткости, это быстрее работает.
 Значением '$a += 3', как и обычного присвоения, является присвоенное значение.
 Обратите внимание, что это НЕ 3, а суммированное значение $a плюс 3 (то, что
 было присвоено $a). Таким образом может
 использоваться любой двухместный оператор, например, '$a -= 5' (вычесть 5 из
 значения $a), '$b *= 7' (умножить значение $b на 7) и т.д.</p>
 <p>Существует еще одно выражение, которое может выглядеть
 необычным, если вы не встречали его в других языках - тернарный
 условный оператор:</p>
<div class="cdata"><a name=AEN4429></a>&lt;?php<br>
   $first ? $second : $third<br>
   ?&gt;</div>
 <p>Если значением первого подвыражения является <b>TRUE</b> (не ноль), выполняется
 второе подвыражение, которое и будет результатом условного выражения. В
 противном случае, будет выполнено третье подвыражение и его значение будет
 результатом.</p>
 <p>Следующий пример должен помочь вам немного улучшить
 понимание префиксного и постфиксного инкремента и выражений:</p>
<div class="cdata"><a name=AEN4435></a>&lt;?php<br>
   function double($i)<br>
   {<br>
   &nbsp; &nbsp; return $i*2;<br>
   }<br>
   $b = $a = 5;&nbsp; &nbsp; &nbsp; &nbsp; /* присвоить значение пять переменным $a и $b */<br>
   $c = $a++;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; /* постфиксный инкремент, присвоить значение $a <br>
   &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;(5)
   переменной $c */<br>
   $e = $d = ++$b;&nbsp; &nbsp; &nbsp;/* префиксный инкремент, присвоить увеличенное<br>
   &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;значение
   $b (6) переменным $d и $e */<br>
   <br>
   /* в этой точке и $d, и $e равны 6 */<br>
   <br>
   $f = double($d++);&nbsp; /* присвоить удвоенное
   значение $d перед<br>
   &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;инкрементом
   (2*6 = 12) переменной $f */<br>
   $g = double(++$e);&nbsp; /* присвоить удвоенное значение $e после<br>
   &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;инкремента
   (2*7 = 14) переменной $g */<br>
   $h = $g += 10;&nbsp; &nbsp; &nbsp; /* сначала переменная $g увеличивается на 10,<br>
   &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;приобретая,
   в итоге, значение 24. Затем значение<br>
   &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;присвоения
   (24) присваивается переменной $h,<br>
   &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;которая
   в итоге также становится равной 24. */<br>
   ?&gt;</div>
 <p>Некоторые выражения могут рассматриваться как инструкции.
 В данном случае инструкция имеет вид 'выражение' ';' - выражение с последующей точкой с запятой. В записи '$b=$a=5;', $a=5 - это
 верное выражение, но само по себе не инструкция. Тогда как '$b=$a=5;' является
 верной инструкцией.</p>
 <p>Последнее, что стоит упомянуть, это истинность значения
 выражений. Во многих случаях, как правило, в условных операторах и циклах, вас
 может интересовать не конкретное значение выражения, а только значат ли они <b>TRUE</b> или <b>FALSE</b>. Константы <b>TRUE</b> и <b>FALSE</b> (регистро-независимые)
 - это два возможных булевых значения. При необходимости выражение
 автоматически преобразуется в булев тип. Подробнее о том, как это происходит,
 смотрите в разделе о приведении типов.</p>
 <p>PHP предоставляет полную и мощную реализацию выражений, и
 их полное документирование выходит за рамки этого руководства. Вышеприведенные
 примеры должны дать вам представление о том, что они из себя
 представляют и как вы сами можете создавать полезные выражения. Далее,
 для обозначения любого верного выражения PHP в этой документации мы будем
 использовать сокращение <i>expr</i>.</p>
 <p><a name=security.index><b>Глава 7. Безопасность</b></a><b></b></p>
 <p><b>Содержание</b></p>
 <p>Вступление</p>
 <p>Общие рассуждения</p>
 <p>Если PHP установлен
 как CGI</p>
 <p>Если PHP установлен как модуль
 Apache</p>
 <p>Безопасность файловой системы</p>
 <p>Безопасность баз данных</p>
 <p>Сообщения об ошибках</p>
 <p>Использование глобальных
 переменных (Register_Globals)</p>
 <p>Данные, введенные пользователем</p>
 <p>Сокрытие PHP</p>
 <p>Необходимость обновлений</p>
 <p><a name=security.intro></a><b>Вступление</b></p>
 <p>PHP является мощным языком программирования и
 интерпретатором, взаимодействующим с веб-сервером как модуль либо как
 независимое бинарное CGI приложение. PHP способен
 обращаться к файлам, выполнять различные команды на сервере и открывать
 сетевые соединения. Именно поэтому все скрипты, исполняемые на сервере
 являются потенциально опасными. PHP изначально разрабатывался как более
 защищенный (относительно Perl, C) язык для написания CGI-приложений. При помощи
 ряда настроек во время компиляции, а также настроек во время работы
 приложения, вы всегда сможете найти подходящее сочетание свободы действий и
 безопасности.</p>
 <p>Поскольку существует много различных способов
 использования PHP, имеется и множество опций, управляющих его поведением.
 Широкий выбор опций гарантирует вам возможность использовать PHP в разных
 целях, но также означает, что некоторые комбинации опций делают сервер
 незащищенным.</p>
 <p>Гибкость конфигурирования PHP можно сравнить с гибкостью
 самого языка. PHP можно использовать для создания полноценных серверных
 приложений, использующих доступные для указанного пользователя возможности
 операционной системы, также возможна реализация включения файлов, хранящихся
 на сервере с минимальным риском в жестко контролируемой среде. То, насколько
 безопасен ваш сервер и как настроено окружение, в большей части зависит от
 PHP-разработчика.</p>
 <p>Эта глава начинается с рассмотрения некоторых общих
 вопросов безопасности, различных конфигурационных опций и их комбинаций, а также
 ситуаций, когда их использование является безопасным. Кроме того, приводятся
 некоторые рассуждения касательно безопасного кодирования.</p>
 <h1><a name=security.general></a>Общие рассуждения</h1>
 <p>Так как абсолютно безопасные системы являются не более,
 чем мифом, на практике приходится балансировать между комфортом и
 безопасностью. Если каждая переменная, вводимая пользователем, будет требовать
 две биометрические проверки (например, сканирование сетчатки глаза и отпечатки
 пальцев), то вы получите предельно высокую достоверность данных. Но поскольку
 заполнение сложной формы будет занимать около получаса, у пользователей такой
 системы непременно возникнет желание обойти навязчивую защиту.</p>
 <p>Правильно поставленная защита должна соответствовать основным требованиям
 безопасности, не ухудшая при этом работу пользователя и не усложняя самому
 программисту разработку продукта. Вместе с тем, некоторые атаки могут
 основываться именно на таком подходе к защите, что приводит к ее постепенному
 ослаблению.</p>
 <p>Следует помнить хорошую поговорку: надежность системы определяется ее самым
 слабым звеном. Например, если все транзакции логируются по времени,
 месторасположению, типу транзакции и ряду других параметров, но авторизация
 пользователя происходит всего лишь по куке (cookie), то связь конкретной
 записи в логе с пользователем системы весьма сомнительна.</p>
 <p>При тестировании следует помнить, что вы не можете проверить все возможные
 варианты даже для простейшей страницы. Данные, которые вы ожидаете, могут
 совершенно не соответствовать тому, что введет разъяренный служащий, хакер со
 стажем или домашний кот, разгуливающий по клавиатуре. Поэтому лучше логически
 подумать над вопросом: в каком месте могут быть
 введены неожиданные данные, как их можно модифицировать, усечь либо, наоборот,
 дополнить.</p>
 <p>Интернет наполнен людьми, которые хотят сделать себе имя на том, что
 взломают ваш код, разрушат сайт, опубликуют на нем неуместный контент или
 просто сделают ваши дни интереснее. И не важно, маленький у вас сайт или
 большой, если у вас есть онлайн-сервер - вы уже потенциальная жертва. Многие
 программы-взломщики несомтрят на размер, они просто перебирают массивы
 IP-адресов, выискивая очередную жертву. Постарайтесь не стать одной из них.</p>
 <h1><a name=security.cgi-bin></a>Если PHP установлен
 как CGI</h1>
 <h2><a name=security.cgi-bin.attacks></a>Возможные атаки</h2>
 <p>Использование PHP как бинарного CGI-приложения
 является одним из вариантов, когда по каким-либо причинам нежелательно
 интегрировать PHP в веб-сервер (например Apache) в
 качестве модуля, либо предполагается использование таких утилит, как chroot и
 setuid для организации безопасного окружения во время работы скриптов. Такая
 установка обычно сопровождается копированием исполняемого файла PHP в
 директорию cgi-bin веб-сервера. CERT (организация, следящая за угрозами
 безопасности) CA-96.11 рекомендует не помещать какие-либо интерпретаторы в
 каталог cgi-bin. Даже если PHP используется как самостоятельный интерпрктатор,
 он спроектирован так, чтобы предотвратить возможность следующих атак:</p>
 <li>Доступ к системным файлам: <tt>http://my.host/cgi-bin/php?/etc/passwd</tt></p>
 <p>Данные, введенные в строке запроса (URL) после
 вопросительного знака, передаются интерпретатору как аргументы командной
 строки согласно CGI протоколу. Обычно интерпретаторы открывают и исполняют
 файл, указанный в качестве первого аргумента.</p>
 <p>В случае использования PHP посредством
 CGI-протокола он не станет интерпретировать аргументы командной строки.</p>
 <li>Доступ к произвольному документу на сервере: <tt>http://my.host/cgi-bin/php/secret/doc.html</tt>
</p>
 <p>Согласно общепринятому
 соглашению часть пути в запрошенной странице, которая расположена после имени
 выполняемого модуля PHP, <tt>/secret/doc.html</tt>,
 используется для указания файла, который будет интерпретирован как CGI-программа Обычно, некоторые конфигурационные опции
 веб-серевера (например, Action для сервера Apache) используются для
 перенаправления документа, к примеру, для перенаправления запросов вида <tt>http://my.host/secret/script.php</tt>
 интерпретатору PHP. В таком случае веб-сервер вначале проверяет права
 доступа к директории <tt>/secret</tt>, и
 после этого создает перенаправленный запрос <tt>http://my.host/cgi-bin/php/secret/script.php</tt>.
 К сожалению, если запрос изначально задан в полном виде, проверка на наличие
 прав для файла <tt>/secret/script.php</tt>
 не выполняется, она происходит только для файла <tt>/cgi-bin/php</tt>. Таким образом, пользователь имеет
 возможность обратиться к <tt>/cgi-bin/php</tt>,
 и, как следствие, к любому защищенному документу на сервере.</p>
 <p>В PHP, указывая во время компиляции опцию --enable-force-cgi-redirect,
 а таке опции doc_root и user_dir во время выполнения
 скрипта, можно предотвратить подобные атаки для директорий с ограниченным
 доступом. Более детально приведенные опции, а также их комбинации будут
 рассмотрены ниже.</p>
 <h2><a name=security.cgi-bin.default></a>Вариант 1: обслуживаются только
 общедоступные файлы</h2>
 <p>В случае, если на вашем сервере отсутствуют файлы,
 доступ к которым ограничен паролем либо фильтром по IP-адресам, нет никакой
 необходимости использовать данные опции. Если ваш веб-сервер не разрешает
 выполнять перенаправления либо не имеет возможности взаимодействовать с исполняемым PHP-модулем на необходимом уровне безопасности,
 вы можете использовать опцию --enable-force-cgi-redirect во время сборки PHP.
 Но при этом вы должны убедиться, что альтернативные способы вызова скрипта,
 такие как непосредственно вызов <tt>http://my.host/cgi-bin/php/dir/script.php</tt>
 либо с переадресацией <tt>http://my.host/dir/script.php</tt>,
 недоступны.</p>
 <p>В веб-сервере Apache перенаправление может быть сконфигурировано при помощи
 директив AddHandler и Action (описано ниже).</p>
 <h2><a name=security.cgi-bin.force-redirect></a>Вариант 2: использование
 --enable-force-cgi-redirect</h2>
 <p>Эта опция, указываемая во время сборки PHP, предотвращает вызов скриптов
 непосредственно по адресу вида <tt>http://my.host/cgi-bin/php/secretdir/script.php</tt>.
 Вместо этого, PHP будет обрабатывать пришедший запрос только в том случае,
 если он был перенаправлен веб-сервером.</p>
 <p>Обычно перенаправление в веб-сервере Apache настраивается при помощи
 следующих опций:</p>
<div class="cdata"><pre>Action php-script /cgi-bin/php</pre><pre>AddHandler php-script .php</pre></div>
 <p>Эта опция проверена только для веб-сервера Apache, ее работа основывается
 на установке в случае перенаправления нестандартной переменной <tt>REDIRECT_STATUS</tt>, находящейся в
 CGI-окружении. В случае, если ваш веб-сервер не
 предоставляет возможности однозначно идентифицировать, является ли данный
 запрос перенаправленным, вы не можете использовать описываемую в данном
 разделе опцию и должны воспользоваться любым другим методом работы с
 CGI-приложениями.</p>
 <h2><a name=security.cgi-bin.doc-root></a>Вариант 3: использование опций
 doc_root и user_dir</h2>
 <p>Размещение динамического контента, такого как скрипты либо любые другие
 исполняемые файлы, в директории веб-сервера делает его потенциально опасным. В
 случае, если в конфигурации сервера допущена ошибка,
 возможна ситуация, когда скрипты не выполняются, а отображаются в браузере,
 как обычные HTML-документы, что может привести к утечке конфиденциальной
 информации (например, паролей), либо информации, являющейся интеллектуальной
 собственностью. Исходя из таких соображений, многие системные администраторы
 предпочитают использовать для хранения скриптов отдельную директорию, работая
 со всеми размещенными в ней файлами по CGI-интерфейсу.</p>
 <p>В случае, если невозможно гарантировать, что
 запросы не перенаправляются, как было показано в предыдущем разделе,
 необходимо указывать переменную doc_root, которая отличается от корневой
 директории веб-документов.</p>
 <p>Вы можете установить корневую директорию для PHP-скриптов, настроив
 параметр doc_root в конфигурационном
 файле, либо установив переменную окружения <tt>PHP_DOCUMENT_ROOT</tt>.
 В случае, если PHP используется посредством CGI,
 полный путь к открываемому файлу будет построен на основании значения
 переменной <tt><i>doc_root</i></tt> и
 указанного в запросе пути. Таким образом, вы можете быть уверены, что скрипты
 будут выполняться только внутри указанной вами директории (кроме директории <tt><i>user_dir</i></tt>, которая описана ниже).</p>
 <p>Еще одна используемая при настройке безопасности опция - user_dir. В случае, если переменная user_dir не установлена, путь к
 открываемому файлу строится относительно <tt><i>doc_root</i></tt>.
 Запрос вида <tt>http://my.host/~user/doc.php</tt>
 приводит к выполнению скрипта, находящегося не в домашнем каталоге
 соответствующего пользователя, а находящегося в подкаталоге doc_root скрипта <tt>~user/doc.php</tt> (да, имя директории
 начинается с символа <tt>~</tt>).</p>
 <p>Но если переменной <tt>public_php</tt>
 присвоено значение, например, <tt>http://my.host/~user/doc.php</tt>,
 тогда в приведенном выше примере будет выполнен скрипт <tt>doc.php</tt>, находящийся в домашнем каталоге
 пользователя, в директории <tt>public_php</tt>.
 Например, если домашний каталог пользователя <tt>/home/user</tt>,
 будет выполнен файл <tt>/home/user/public_php/doc.php</tt>.
</p>
 <p>Установка опции <tt><i>user_dir</i></tt>
 происходит независимо от установки <tt><i>doc_root</i></tt>,
 таким образом вы можете контролировать корневую
 директорию веб-сервера и пользовательские директории независимо друг от друга.
</p>
 <h2><a name=security.cgi-bin.shell></a>Вариант 4: PHP вне дерева
 веб-документов</h2>
 <p>Один из способов существенно повысить уровень безопасности - поместить
 исполняемый модуль PHP вне дерева веб-документов, например в <tt>/usr/local/bin</tt>. Единственным недостатком
 такого подхода является то, что первая строка каждого скрипта должна иметь
 вид:</p>
<div class="cdata"><pre><a name=AEN6098></a>#!/usr/local/bin/php</pre></div>
 <p>Также необходимо сделать все файлы скриптов исполняемыми.
 Таким образом, скрипт будет рассматриваться так же, как и любое другое
 CGI-приложение, написанное на Perl, sh или любом другом скриптовом языке,
 который использует дописывание <tt>#!</tt>
 в начало файла для запуска самого себя.</p>
 <p>Что бы внутри скрипта вы могли получить корректные значения переменных <tt>PATH_INFO</tt> и <tt>PATH_TRANSLATED</tt>, PHP должен быть сконфигурирован с опцией --enable-discard-path.
</p>
 <h1><a name=security.apache></a>Если PHP установлен как модуль Apache</h1>
 <p>Когда PHP используется как модуль Apache, он наследует права пользователя,
 с которыми был запущен веб-сервер (обычно это пользователь 'nobody'). Это
 влияет на обеспечение безопасности и реализацию авторизации. Например, если вы
 используете базу данных, которая не имеет встроенного механизма разграничения
 доступа, вам прийдется обеспечить доступ к БД для пользователя 'nobody'. В
 таком случае зловредный скрипт может получить доступ к базе данных и
 модифицировать ее, даже не зная логина и пароля. Вполне возможна ситуация,
 когда веб-паук неверными запросами страницы администратора базы данных
 уничтожит все данные или даже структуру БД. Вы можете избежать такой ситуации
 при помощи авторизации Apache или разработав собственную модель доступа,
 используя LDAP, файлы <tt>.htaccess</tt>
 или любые другие технологии, внедряя соответствующий код в
 ваши скрипты.</p>
 <p>Достаточно часто используются такие настройки безопасности, при которых PHP
 (имеется ввиду пользователь, с правами которого выполняется Apache) имеет
 минимальные привелегии, например отсутствует
 возможность записи в пользовательские директории. Или, например, отсутствует
 возможность работать с базой данных. При этом система
 безопасности не позволяет записывать как &quot;хорошие&quot;, так и
 &quot;плохие&quot; файлы, аналогично позволяет производить как
 &quot;хорошие&quot;, так и &quot;плохие&quot; транзакции.</p>
 <p>Распространенной ошибкой является запуск Apache с правами суперпользователя
 или любое другое расширение полномочий веб-сервера.</p>
 <p>Расширение привилегий веб-сервера до полномочий угрожает работоспособности
 всей системы, такие команды, как sudo, chroot должны выполняться исключительно
 теми, кто считает себя профессионалами в вопросах безопасности.</p>
 <p>Существует несколько простых решений. Используя open_basedir, вы можете
 ограничить дерево доступных директорий для PHP. Вы так же можете определить
 область доступа Apache, ограничив все веб-сервисы не-пользовательскими или не-системными файлами.</p>
 <p><a name=security.filesystem></a><b>Безопасность
 файловой системы</b></p>
 <p>PHP является одним из важных моментов в вопросе
 безопасности сервера, поскольку PHP-скрипты могут манипулировать файлами и
 каталогами на диске. В связи с этим существуют конфигурационные настройки,
 указывающие, какие файлы могут быть доступны и какие
 операции с ними можно выполнять. Необходимо проявлять осторожность,
 поскольку любой из файлов с соответствующими правами доступа может быть
 прочитан каждым, кто имеет доступ к файловой системе.</p>
 <p>Поскольку в PHP изначально предполагался полноправный
 пользовательский доступ к файловой системе, можно написать скрипт, который
 позволит читать системные файлы, такие как /etc/passwd, управлять сетевыми
 соединениями, отправлять задания принтеру, и так далее. Как следствие вы
 всегда должны быть уверены в том, что файлы, которые вы читаете или
 модифицируете, соответствуют вашим намерениям.</p>
 <p>Рассмотрим следующий пример, в коротом пользователь создал
 скрипт, удаляющий файл из его домашней директории. Предполагается ситуация,
 когда веб-интерфейс, написанный на PHP, регулярно
 используется для работы с файлами, и настройки безопасности позволяют удалять
 файлы в домашнем каталоге.</p>
<div class="cdata"><a name=AEN6120></a><b>Пример 15-1.
   Недостаточная проверка внешних данных.</b></p>
   </div>
<div class="cdata">&lt;?php<br>
     // Удаление файла из домашней директории пользователя<br>
     $username
     = $_POST['user_submitted_name'];<br>
     $homedir = &quot;/home/$username&quot;;<br>
     $file_to_delete
     = &quot;$userfile&quot;;<br>
     unlink (&quot;$homedir/$userfile&quot;);<br>
     echo &quot;$file_to_delete
     has been deleted!&quot;;<br>
     ?&gt;</div>
   
   </td>
  </tr>
 </table>
 <p>Поскольку переменные вводятся в пользовательской форме,
 существует возможность удалить файлы, принадлежащие кому-либо другому, введя
 соответствующие значения. В этом случае может понадобиться авторизация.
 Посмотрим, что произойдет, если будут отправлены значения &quot;../etc/&quot; и &quot;passwd&quot;. Скрипт выполнит следующие действия:</p>
 <table border=0 cellspacing=0 cellpadding=0 width="100%">
  <tr>
   <td>
   <p><a name=AEN6123></a><b>Пример 15-2. Атака на
   файловую систему</b></p>
<div class="cdata">&lt;?php<br>
     // Удаление любого файла, доступного из
     PHP-скрипта.<br>
     // В случае, если
     PHP работает с правами пользователя root:<br>
     $username = &quot;../etc/&quot;;<br>
     $homedir = &quot;/home/../etc/&quot;;<br>
     $file_to_delete = &quot;passwd&quot;;<br>
     unlink (&quot;/home/../etc/passwd&quot;);<br>
     echo &quot;/home/../etc/passwd
     has been deleted!&quot;;<br>
     ?&gt;</div>
   
   </td>
  </tr>
 </table>
 <p>Cуществуют
 два решения описанной проблемы.</p>
 <ul type=disc>
  <li>Ограничить доступ
      пользователя, с правами которого работает веб-сервер. </li>
  <li>Проверять все
      данные, вводимые пользователем. </li>
 </ul>
 <p>Вот улучшеный вариант кода:</p>
 <table border=0 cellspacing=0 cellpadding=0 width="100%">
  <tr>
   <td>
   <p><a name=AEN6131></a><b>Пример 15-3. Более
   безопасная проверка имени файла</b></p>
<div class="cdata">&lt;?php<br>
     // Удаление любого файла, доступного из
     PHP-скрипта.<br>
     $username
     = $_SERVER['REMOTE_USER']; // использование авторизации<br>
     <br>
     $homedir = &quot;/home/$username&quot;;<br>
     <br>
     $file_to_delete
     = basename(&quot;$userfile&quot;); // усечение пути<br>
     unlink ($homedir/$file_to_delete);<br>
     <br>
     $fp = fopen(&quot;/home/logging/filedelete.log&quot;,&quot;+a&quot;); //логируем удаление<br>
     $logstring
     = &quot;$username
     $homedir $file_to_delete&quot;;<br>
     fputs ($fp, $logstring);<br>
     fclose($fp);<br>
     <br>
     echo &quot;$file_to_delete
     has been deleted!&quot;;<br>
     ?&gt;</div>
   
   </td>
  </tr>
 </table>
 <p>Однако и такая проверка не
 учитывает все возможные ситуации. Если система авторизации позволяет
 пользователям выбирать произвольные логины, вломщик может создать учетную
 запись вида &quot;../etc/&quot; и система опять окажется уязвимой. Исходя из
 этого, вам может понадобиться более строгая проверка:</p>
 <table border=0 cellspacing=0 cellpadding=0 width="100%">
  <tr>
   <td>
   <p><a name=AEN6134></a><b>Пример 15-4. Более
   строгая проверка имени файла</b></p>
<div class="cdata">&lt;?php<br>
     $username = $_SERVER['REMOTE_USER']; // использование авторизации<br>
     $homedir = &quot;/home/$username&quot;;<br>
     <br>
     if (!ereg('^[^./][^/]*$', $userfile))<br>
     &nbsp; &nbsp; &nbsp;die('bad filename'); //завершение работы<br>
     <br>
     if (!ereg('^[^./][^/]*$', $username))<br>
     &nbsp; &nbsp; &nbsp;die('bad username'); //завершение работы<br>
     //etc...<br>
     ?&gt;</div>
   
   </td>
  </tr>
 </table>
 <p>В зависимости от используемой вами операционной системы
 необходимо предусматривать возможность атаки на разнообразные файлы, включая
 системные файлы устройств (/dev/ или COM1), конфигурационные файлы (например /etc/ или файлы с расширением .ini), хорошо
 известные области хранения данных (/home/, My Documents), и так далее. Исходя
 из этого, как правило, легче реализовать такую политику безопасности, в
 которой запрещено все, исключая то, что явно разрешено.</p>
 <h1><a name=security.database></a>Безопасность баз данных</h1>
 <p>На сегодняшний день базы данных являются ключевыми компонентами большинства
 веб-приложений, позволяя предоставлять на сайтах динамический контент.
 Поскольку в таких БД может храниться очень точная или конфиденциальная
 информация, вы должны обеспечить хорошую защиту данных.</p>
 <p>Для извлечения или сохранения любых данных вам необходимо открыть
 соединение с базой данных, отправить верный запрос, извлечь результат и
 закрыть соединение. В настоящее время наиболее распространенный стандарт
 общения - структурированный язык запросов (SQL). Всегда следует помнить о
 возможности атаки посредством SQL-запроса.</p>
 <p>Очевидно, что сам по себе PHP не может защитить вашу базу данных. Этот
 раздел документации рассказывает об основах безопасного доступа и управления
 данными в PHP-скриптах.</p>
 <p>Запомните простое правило: максимальная защита. Чем больше потенциально
 опасных участков системы вы проработаете, тем сложнее будет потенциальному
 взломщику получить доступ к базе данных или повредить ее. Хороший дизайн базы
 данных и программных приложений поможет вам справиться с вашими страхами.</p>
 <h2><a name=security.database.design></a>Проектирование базы данных</h2>
 <p>Первый шаг - это всегда создание БД, исключая тот случай, когда вы хотите
 использовать готовую базу, предоставляемую третьим лицом. После того, как база
 данных создана, она назначается пользователю, который выполнил создавший БД
 запрос. Как правило, только владелец (или суперпользователь) может выполнять
 различные действия с различными объектами, хранимыми в базе данных. Для того, чтобы и другие пользователи имели к ней доступ, их
 необходимо наделить соответствующими привелегиями.</p>
 <p>Приложения не должны соединяться с базой данных, используя учетную запись
 владельца или суперпользователя, иначе они смогут модифицировать структуру
 таблиц (например, удалить некоторые таблицы) или даже удалить все содержимое
 БД целиком.</p>
 <p>Вы можете создать различные учетные записи пользователей БД для каждой
 индивидуальной потребности приложения с соответствующими функциональными
 ограничениями. Рекомендуется назначать только самые необходимые привилегии,
 также вы должны избегать ситуаций, когда один и тот же пользователь может
 взаимодействовать с базой данных в нескольких режимах. Вы должны понимать, что
 если злоумышленник сможет воспользоваться какой-либо учетной записью вашей БД,
 он сможет вносить в базу все те изменения, что и программа, которая использует
 текущую учетную запись.</p>
 <p>Вам не обязательно реализовывать всю бизнес-логику в веб-приложении (т.е. в
 скриптах), для этого также можно использовать возможности, предоставляемые
 базой данных: триггеры, представления, правила. В случае роста системы вам
 понадобятся новые соединения с БД, и логику работы понадобиться дублировать
 для каждого нового интерфейса доступа. Исходя из вышесказанного, триггеры
 могут использоваться для прозрачной и автоматической обработки записей, что
 часто необходимо при отладке приложений или при трассировке отката транзакций.
</p>
 <h2><a name=security.database.connection></a>Соединение с базой данных</h2>
 <p>Вы можете использовать безопасные SSL или ssh соединения, для шифрования
 данных, которыми обмениваются клиент и сервер. Если вы реализуете что-нибудь
 из этого, то мониторинг трафика и сбор данных о вашей базе данных для
 потенциального взломщика существенно усложнится.</p>
 <h2><a name=security.database.storage></a>Защита хранилища базы данных</h2>
 <p>SSL/SSH защищает данные, которыми обмениваются клиент и сервер, но не
 защищают сами данные, хранимые в базе данных. SSL - протокол шифрования на
 уровне сеанса передачи данных.</p>
 <p>В случае, если взломщик получил непосредственный
 доступ к БД (в обход веб-сервера), он может извлечь интересующие данные или
 нарушить их целостность, поскольку информация не защищена на уровне самой БД.
 Шифрование данных - хороший способ предотвратить такую ситуацию, но лишь
 незначительное количество БД предоставляют такую возможность.</p>
 <p>Наиболее простое решение этой проблемы - установить вначале обыкновенный
 программный пакет для шифрования данных, а затем использовать его в ваших скриптах. PHP, в таком случае, может помочь вам в
 работе с такими расширениями как Mcrypt и Mhash, реализующими различные
 алгоритмы криптования. При таком подходе скрипт вначале шифрует сохраняемые
 данные, а затем дешифрует их при запросе. Ниже приведены примеры того, как
 работает шифрование данных в PHP-скриптах.</p>
 <p>В случае работы со скрытыми служебными данными их нешифрованное
 представление не требуется (т.е. не отображается), и, как следствие, можно
 использовать хеширование. Хорошо известный пример хэширования - хранение
 MD5-хеша от пароля в БД, вместо хранения оригинального значения. Более
 детальная информация доступна в описании функций <b>crypt()</b> and <b>md5()</b>.
</p>
<p><a name=AEN6164></a><b>Пример 15-5. Использование хешированных паролей</b></p>
<div class="cdata"><code>//
     сохранение хешированного пароля</code><br>
     <code>$query&nbsp; = sprintf(&quot;INSERT INTO users(name,pwd)
     VALUES('%s','%s');&quot;,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addslashes($username),
     md5($password));</code><br>
     <code>$result = pg_exec($connection, $query);</code><br>
     <br>
     <code>// проверка введенного пользователем логина и пароля на корректность</code><br>
     <code>$query = sprintf(&quot;SELECT 1 FROM users WHERE name='%s' AND
     pwd='%s';&quot;,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; addslashes($username),
     md5($password));</code><br>
     <code>$result = pg_exec($connection, $query);</code><br>
     <br>
     <code>if (pg_numrows($result) &gt; 0) {</code><br>
     <code>&nbsp; &nbsp; echo &quot;Welcome, $username!&quot;;</code><br>
     <code>}</code><br>
     <code>else {</code><br>
     <code>&nbsp; &nbsp; echo &quot;Authentication failed for
     $username.&quot;;</code><br>
     <code>} </code></div>
   
 <h2><a name=security.database.sql-injection></a>SQL-инъекции</h2>
 <p>Многие веб-разработчики даже не догадываются, что SQL-запросы могут быть
 подделаны, и считают, что SQL-запросы всегда достоверны. На самом деле
 поддельные запросы могут обойти ограничения доступа, стандартную проверку
 авторизации, а некоторые виды запросов могут дать возможность выполнять
 команды операционной системы.</p>
 <p>Принудительное внедрение вредоносных инструкций в SQL-запросы - методика, в
 которой взломщик создает или изменяет текущие SQL-запросы для работы со
 скрытыми данными, их изменения или даже выполнения опасных комманд
 операционной системы на сервере базы данных. Атака выполняется на базе
 приложения, строящего SQL-запросы из пользовательского ввода и статических
 переменных. Следующие примеры, к сожалению, построены на реальных фактах.</p>
 <p>Благодаря отсутствию проверки пользовательского ввода и соединением с базой
 данных под учетной записью суперпользователя (или любого другого пользователя,
 наделенного соответствующими привелегиями), взломщик может создать еще одного
 пользователя БД с правами суперпользователя.</p>
<p><a name=AEN6172></a><b>Пример 15-6. Постраничный вывод результата... и создание суперпользователя в PostgreSQL и MySQL </b></p>

<div class="cdata"><code>$offset = argv[0];     // проверка пользовательских данных отсутствует</code><br>
     <code>$query&nbsp; = &quot;SELECT id, name FROM products ORDER BY
     name LIMIT 20 OFFSET $offset;&quot;;</code><br>
     <code>// используя PostgreSQL </code><br>
     <code>$result = pg_exec($conn, $query);</code><br>
     <code>// используя MySQL</code><br>
     <code>$result = mysql_query($query); </code></div>
   
 <p>Обычно пользователи кликают по ссылкам 'вперед' и 'назад', вследствии чего
 значение переменной <tt>$offset</tt>
 заносится в адресную строку. Скрипт ожидает, что <tt>$offset</tt> - десятиричное число. Однако, взломщик может
 попытаться взломать систему, присоединив к строке запроса дополнительную
 подстроку, обработанную функцией <b>urlencode()</b>:</p>
<div class="cdata"><pre><a name=AEN6178></a>// используя PostgreSQL </pre><pre>0;</pre><pre>insert into pg_shadow(usename,usesysid,usesuper,usecatupd,passwd)</pre><pre>    select 'crack', usesysid, 't','t','crack'</pre><pre>    from pg_shadow where usename='postgres';</pre><pre>--</pre><pre> </pre><pre>// используя MySQL</pre><pre>0;</pre><pre>UPDATE user SET Password=PASSWORD('crack') WHERE user='root';</pre><pre>FLUSH PRIVILEGES;</pre></div>
 <p>Если это произойдет, скрипт предоставит взломщику доступ к
 базе с правами суперпользователя. Заметим, что <tt>0;</tt> использован для того, чтобы задать правильное значение
 смещения для первого запроса и корректно его завершить.</p>
 <p><b>Замечание: </b>Уже привычна технология, когда разработчики указывают
 принудительное игнорирование парсером SQL оставшейся части запроса при помощи
 нотации <tt>--</tt>, означающей
 комментарий.</p>
 <p>Еще один вероятный способ получить пароли учетных записей в БД - атака
 страниц, предоставляющих поиск по базе. Взломщику нужно лишь проверить,
 используется ли в запросе передаваемая на сервер и необрабатываемая надлежащим
 образом переменная. Это может быть один из устанавливаемых на предыдущей странице
 фильтров, таких как <tt>WHERE, ORDER BY, LIMIT</tt>
 и <tt>OFFSET</tt>, используемых при
 построении запросов <tt>SELECT</tt>. В
 случае, если используемая вами база данных
 поддерживает конструкцию <tt>UNION</tt>,
 взломщик может присоединить к оригинальному запросу еще один дополнительный,
 для извлечения пользовательских паролей. Настоятельно рекомендуем использовать
 только зашифрованные пароли.</p>
<p><a name=AEN6189></a><b>Пример 15-7. Листинг статей... и некоторых паролей
   (для любой базы данных) </b></p>
<div class="cdata"><code>$query&nbsp; = &quot;SELECT id, name,
     inserted, size FROM products</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WHERE
     size = '$size'</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ORDER
     BY $order LIMIT $limit, $offset;&quot;;</code><br>
     <code>$result = odbc_exec($conn, $query); </code></div>
   
 <p>Статическая часть запроса может комбинироваться с другим SQL-запросом, который откроет все пароли:</p>
<div class="cdata"><pre><a name=AEN6192></a>'</pre><pre>union select '1', concat(uname||'-'||passwd) as name, '1971-01-01', '0' from usertable;</pre><pre>--</pre></div>
 <p>Если этот запрос (использующий <tt>'</tt> и <tt>--</tt>)
 присоединить к значению одной из переменных, используемых для
 формирования <tt>$query</tt>, запрос
 заметно преобразится.</p>
 <p>Команды UPDATE также могут использоваться для атаки. Опять же, есть угроза
 разделения инструкции на несколько запросов,
 присоединения дополнительного запроса. Также взломщик может видоизменить
 выражение <tt>SET</tt>. В этом случае
 потенциальному взломщику необходимо обладать некоторой дополнительной информацией
 для успешного манипулирования запросами. Эту информацию можно получить,
 проанализировав используемые в форме имена переменных либо просто перебирая
 все наиболее распространенные варианты названия соответствующих полей (а их не
 так уж и много).</p>
<p><a name=AEN6199></a><b>Пример 15-8. От восстановления пароля... до
  получения дополнительных привилегий (для любой базы данных) </b></p>
<div class="cdata"><code>$query = &quot;UPDATE usertable SET pwd='$pwd'     WHERE uid='$uid';&quot;; </code></div>
   
 <p>Но злоумышленник может ввести значение <tt>' or uid like'%admin%'; --</tt> для переменной <tt>$uid</tt> для изменения пароля администратора
 или просто присвоить переменной <tt>$pwd</tt>
 значение <tt>&quot;hehehe', admin='yes',
 trusted=100 &quot;</tt> (с завершающими пробелами) для получения
 дополнительных привелегий. При выполнении запросы переплетаются:</p>
<div class="cdata"><a name=AEN6206></a><code>// $uid == ' or uid
   like'%admin%'; --</code><br>
   <code>$query = &quot;UPDATE usertable SET pwd='...' WHERE uid='' or uid like
   '%admin%'; --&quot;;</code><br>
   <br>
   <code>// $pwd == &quot;hehehe', admin='yes', trusted=100 &quot;</code><br>
   <code>$query = &quot;UPDATE usertable SET pwd='hehehe', admin='yes',
   trusted=100 WHERE ...;&quot; </code></div>
 <p>Пугающий пример того, как на сервере баз данных могут выполняться команды
 операционной системы.</p>
<p><a name=AEN6209></a><b>Пример 15-9. Выполнение команд операционной
   системы на сервере (для базы MSSQL)</b></p>

<div class="cdata"><code>$query&nbsp; = &quot;SELECT * FROM products
     WHERE id LIKE '%$prod%'&quot;;</code><br>
     <code>$result = mssql_query($query); </code></div>
   
   </td>
  </tr>
 </table>
 <p>Если взломщик введет значениме <tt>a%' exec
 master..xp_cmdshell 'net user test testpass /ADD' --</tt> для переменной <tt>$prod</tt>, тогда запрос <tt>$query</tt> будет выглядеть так:</p>
<div class="cdata"><a name=AEN6215></a><code>$query&nbsp; =
   &quot;SELECT * FROM products</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; WHERE
   id LIKE '%a%'</code><br>
   <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; exec
   master..xp_cmdshell 'net user test testpass /ADD'--&quot;;</code><br>
   <code>$result = mssql_query($query); </code></div>
 <p>MSSQL сервер выполняет SQL-команды в пакетном режиме, в том
 числе и операции по заведению локальных учетных записей базы данных. В случае, если приложение работает с привилегиями администратора и
 сервис MSSQL запущен с необходимыми привилегиями, выполнив приведенные выше
 действия, взломщик получит аккаунт для доступа к серверу.</p>
 <p><b>Замечание: </b>Некоторые приведенные в этой главе примеры касаются
 конкретной базы данных. Это не означает, что аналогичные атаки на другие
 программные продукты невозможны. Работоспособность вашей базы данных может
 быть нарушена каким-либо другим способом.</p>
 <h3><a name=security.database.avoiding></a>Способы защиты</h3>
 <p>Вы можете утешать себя тем, что в большинстве случаев, взломщик должен
 обладать некоторой информацией о структуре базы данных. Вы правы, но вы не
 знаете, когда и как будет предпринята попытка взлома, в случае если это произойдет ваша БД окажется незащищенной. Если вы
 используете программный продукт с открытыми исходными кодами или просто
 общедоступный пакет для работы с базой данных (например
 контент менеджер или форум), взломщик легко сможет воспроизвести интересующие
 его участки кода. В случае если они плохо спроектированы, это может являться
 одной из угроз вашей безопасности.</p>
 <p>Большинство успешных атак основывается на коде, написанном без учета
 соответствующих требований безопасности. Не доверяйте
 никаким вводим данным, особенно если они поступают со стороны клиента,
 даже если это списки в форме, скрытые поля или куки. Приведенные примеры
 показывают, к каким последствиям могут привести подделанные запросы.</p>
 <li>Старайтесь не открывать соединение с базой,
 используя учетную запись владельца или администратора. Всегда старайтесь
 использовать специально созданных пользователей с максимально ограниченными
 правами.</p>
 <li>Всегда проверяйте введенные данные на
 соответствие ожидаемому типу. В PHP есть множество функций для проверки
 данных: начиная от простейших Функций для работы с переменными и Функции
 определения типа символов (такие как <b>is_numeric()</b>, <b>ctype_digit()</b>)
 и заканчивая Perl-совместимыми регулярными выражениями.</p>
 <li>В случае, если
 приложение ожидает цифровой ввод, примените функцию <b>is_numeric()</b> для
 проверки введенных данных, или принудительно укажите их тип при помощи <b>settype()</b>,
 или просто используйте числовое представление при помощи функции <b>sprintf()</b>.
</p>
<p><a name=AEN6238></a><b>Пример 15-10. Более безопасная реализация
   постраничной навигации</b></p>

<div class="cdata"><code>settype($offset, 'integer');</code><br>
     <code>$query = &quot;SELECT id, name FROM products ORDER BY name LIMIT 20
     OFFSET $offset;&quot;;</code><br>
     <br>
     <code>// </code><code>обратите</code><code> </code><code>внимание</code><code> </code><code>на</code><code> </code><code>формат</code><code> %d, </code><code>использование</code><code> %s </code><code>было</code><code> </code><code>бы</code><code> </code><code>бессмысленно</code><br>
     <code>$query = sprintf(&quot;SELECT id, name FROM products ORDER BY name
     LIMIT 20 OFFSET %d;&quot;,</code><br>
     <code>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;$offset);     </code></div>

<ul>
 <li>Экранируйте любой нецифровой ввод, используемый
 в запросах к БД при помощи функций <b>addslashes()</b> или <b>addcslashes()</b>.
 Обратите внимание на первый пример. Следует помнить, что одного использования
 кавычек в запросе мало, это легко обойти.</li>
 <li>Не выводите никакой информации о БД, особенно о ее структуре. Также ознакомьтесь с соответствующими
 разделами документации: Сообщения об ошибках и Функции обработки и логирования
 ошибок.</li>
 <li>Вы можете использовать хранимые процедуры и
 заранее определенные курсоры для абстрагированной работы с данными, не
 предоставляя пользователям прямого доступа к данным и представлениям, но это
 решение имеет свои особенности.</li>
</ul>
 <p>Помимо всего вышесказанного, вы можете логировать запросы
 в вашем скрипте либо на уровне базы данных, если она это поддерживает.
 Очевидно, что логирование не может предотвратить нанесение ущерба, но может
 помочь при трассировке взломанного приложения. Лог-файл полезен не сам по
 себе, а информацией, которая в нем содержится. Причем, в большинстве случаев
 полезно логировать все возможные детали.</p>
 <p><a name=security.errors></a><b>Сообщения об ошибках</b></p>
 <p>С точки зрения безопасности вывод сообщений об ошибках
 несет в себе как плюсы, так и минусы.</p>
 <p>Одна из стандартных методик, применяемых в атаках - ввод
 некорректных данных с последующим анализом содержания и характера сообщений об
 ошибках. Это дает взломщику возможность проверить скрипты и данные сервера на
 наличие потенциальных дыр. Например, если взломщик получил некоторую информацию
 о странице на основании отправки формы, он попробует предопределить некоторые
 передаваемые значения или модифицировать их:</p>
<p><a name=AEN6257></a><b>Пример 15-11. Атака
   на переменные в HTML-странице</b></p>

<div class="cdata">&lt;form method=&quot;post&quot;     action=&quot;attacktarget?username=badfoo&amp;amp;password=badfoo&quot;&gt;</p>
     <p>&lt;input type=&quot;hidden&quot;     name=&quot;username&quot; value=&quot;badfoo&quot; /&gt;</p>
     <p>&lt;input type=&quot;hidden&quot;     name=&quot;password&quot; value=&quot;badfoo&quot; /&gt;</p>
     <p>&lt;/form&gt;</div>
   
 <p>Возникаемые во время работы скриптов ошибки являются
 достаточно ценной информацией для разработчика, содержащей такие данные, как
 функция или файл, а также номер строки, в которой возникла ошибка. Вся эта
 информация может быть использована для взлома. Для PHP-разработчика достаточно
 привычно пользоваться такими функциями, как <b>show_source()</b>, <b>highlight_string()</b> или <b>highlight_file()</b> в целях отладки, но в живых сайтах это может открыть
 информацию о скрытых переменных, непроверяемом синтаксисе и других
 потенциально опасных моментах. Особенно опасно наличие кода со встроенным
 механизмом отладки в публичных частях сайта. Взломщик может попытаться
 запустить отладочный механизм, подбирая основные признаки отладки:</p>
<p><a name=AEN6264></a><b>Пример 15-12.
   Использование стандартных отладочных переменных</b></p>

<div class="cdata">&lt;form method=&quot;post&quot; action=&quot;attacktarget?errors=Y&amp;amp;showerrors=1&amp;amp;debug=1&quot;&gt;</p>
     <p>&lt;input type=&quot;hidden&quot;     name=&quot;errors&quot; value=&quot;Y&quot; /&gt;</p>
     <p>&lt;input type=&quot;hidden&quot;     name=&quot;showerrors&quot; value=&quot;1&quot; /&gt;</p>
     <p>&lt;input type=&quot;hidden&quot;     name=&quot;debug&quot; value=&quot;1&quot; /&gt;</p>
     <p>&lt;/form&gt;</div>
   
 <p>Независимо от метода обработки ошибок возможность проверки
 системы на наличие ошибок снабжает взломщика дополнительной информацией.</p>
 <p>Например, стандартный вывод об ошибке указывает
 операционную систему, в которой выполняются PHP скрипты. Если взломщик
 анализирует обыкновенную HTML-страницу, пытаясь найти
 уязвимые места, используя ввод неверных данных он может обнаружить
 использование PHP скриптов в данной системе.</p>
 <p>Также уведомление об ошибке может дать информацию о том,
 какая база данных используется, или, к примеру, как построена логика работы
 скриптов. Это, в свою очередь, может позволить взломщику подключиться к
 открытому порту базы данных либо найти специфичные ошибки в коде. Пробуя
 поочередно различные неверные блоки данных, злоумышленник может определить
 порядок аутентификации в скрипте (например, по номерам строк с ошибками) или
 проверять на наличие дыр различные участки кода.</p>
 <p>Вывод стандартных ошибок, связанных с файловой системой,
 может указать, с какими привелегиями запущен веб-сервер, и как организованы
 каталоги сайта. Обработка подобных ошибок, написанная разработчиками
 приложения, может только усугубить проблему, если взломщиком будет найден способ обнаружить &quot;скрытую&quot; отладочную
 информацию.</p>
 <p>Существует три основныч способа решения этой проблемы.
 Первый заключается в том, чтобы структурировать все функции и попытаться
 компенсировать объем выдаваемых ошибок. Второй способ - полностью отключить в
 работающем коде вывод сообщений об ошибках. И, наконец, третий способ -
 использовать специальные средства PHP для создания собственного обработчика ошибок.
 В зависимости от используемой вами политики безопасности вы можете применять в
 вашей конкретной ситуации все три способа.</p>
 <p>Один из возможных способов обезопасить ваш код перед его
 публикацией для общего доступа - индивидуальное использование <b>error_reporting()</b>,
 чтобы выявить потенциально опасные переменные. Тестируя код перед выпуском
 релиза при помощи значения E_ALL, вы достаточно легко можете обнаружить
 участки кода, в которых переменные могут быть подменены либо модифицированы.
 После окончания тестирования, установив значение E_NONE, вы можете полностью
 отключить вывод сообщений об ошибках.</p>
<p><a name=AEN6274></a><b>Пример 15-13. Поиск
   потенциально опасных переменных при помощи E_ALL</b></p>

<div class="cdata">&lt;?php<br>
     if ($username) {&nbsp; // Переменная не инициализируется перед использованием<br>
     &nbsp; &nbsp; $good_login = 1;<br>
     }<br>
     if ($good_login
     == 1) { // Если предыдущая
     проверка потерпела неудачу, переменная оказывается неинициализированной<br>
     &nbsp; &nbsp; readfile (&quot;/highly/sensitive/data/index.html&quot;);<br>
     }<br>
     ?&gt;</div>
   
 <p><a name=security.registerglobals></a><b>Использование
 глобальных переменных (Register_Globals)</b></p>
 <p>Наверное, наиболее спорным моментом в разработке PHP стала
 замена значения по умолчанию для опции register_globals с ON на OFF в версии 4.2.0. Большинство пользователей доверились разработчикам, даже
 не зная, что это за опция и как она влияет на работу
 PHP. Эта страница документации призвана показать, как эта настройка сочетается
 с вопросами безопасности при разработке приложений. Следует понимать, что сама
 по себе эта опция никак не влияет на безопасность, ургозу представляет
 некорректное использование предоставляемых ею возможностей.</p>
 <p>В случае, если значение параметра
 register_globals ON, перед выполнением вашего кода будут инициализированы
 различные переменные, например, переменные, переданные при отправке формы.
 Также, учитывая тот факт, что PHP не требует инициализации переменных,
 написать потенциально опасный код очень легко. Это было очень спорным
 решением, но общество разработчиков PHP решило изменить значение по умолчанию
 этой директивы на OFF. В противном случае при написании кода разработчики не
 могли бы с уверенностью сказать, откуда пришла та или иная переменная и
 насколько она достоверна. До такого нововведения переменные, определяемые
 разработчиком внутри скрипта, и передаваемые пользователем внешние данные
 могли перемешиваться. Приведем простой пример злоупотребления конфигурационной
 опцией register_globals:</p>
<p><a name=AEN6284></a><b>Пример 15-14. Пример
   опасного кода с register_globals = on</b></p>

<div class="cdata">&lt;?php<br>
     // устанавливаем переменную $authorized =
     true только для пользователей, прошедших авторизацию<br>
     if (authenticated_user()) {<br>
     &nbsp; &nbsp; $authorized = true;<br>
     }<br>
     <br>
     // Поскольку в случае неудачи при проверке
     авторизации переменная $authorized <br>
     // не установлена, она может быть установлена
     автоматически, благодаря register_globals,<br>
     // например, при GET запросе GET
     auth.php?authorized=1.<br>
     // Таким образом, пройти эту проверку можно
     без авторизации<br>
     if ($authorized) {<br>
     &nbsp; &nbsp; include &quot;/highly/sensitive/data.php&quot;;<br>
     }<br>
     ?&gt;</div>
   
   </td>
  </tr>
 </table>
 <p>В случае register_globals = on логика работы скрипта может
 быть нарушена. В случае, если установленное значение
 off, переменная $authorized не может быть установлена из внешних данных запроса, и
 скрипт будет работать корректно. Но все же инициализация переменных - один из
 признаков хорошего тона в программировании. Например, в приведенном выше
 участке кода мы могли поместить $authorized =
 false в качестве первой строки. Такой код
 работал бы как со значением on, так и off опции register_globals, и подразумевая, что по умолчанию пользователь не проходил
 авторизацию.</p>
 <p>Приведем еще один пример, использующий сессии. В случае, если register_globals = on, мы можем использовать
 переменную $username в приведенном ниже примере, но тогда у нас не будет уверенности в
 достоверности ее значения (к примеру, она могла быть передана в GET-запросе).</p>
<p><a name=AEN6294></a><b>Пример 15-15. Пример
   использования сессий со значением register_globals on или off</b></p>

<div class="cdata">&lt;?php<br>
     // Мы не знаем, откуда получена переменная
     $username, но точно знаем, что<br>
     // переменная $_SESSION хранит в себе данные
     сессии<br>
     if (isset($_SESSION['username'])) {<br>
     <br>
     &nbsp; &nbsp; echo &quot;Hello
     &lt;b&gt;{$_SESSION['username']}&lt;/b&gt;&quot;;<br>
     <br>
     } else {<br>
     <br>
     &nbsp; &nbsp; echo &quot;Hello &lt;b&gt;Guest&lt;/b&gt;&lt;br /&gt;&quot;;<br>
     &nbsp; &nbsp; echo &quot;Would you like to login?&quot;;<br>
     <br>
     }<br>
     ?&gt;</div>
   
   </td>
  </tr>
 </table>
 <p>Также существует возможность реализации оперативного
 реагирования в случае попытки подмены переменных. Так как во время разработки
 приложения мы знаем ожидаемое значение переменной, а также знаем ее
 достоверное значение, мы можем их сопоставить. Это не защитит код от подмены
 переменных, но усложнит перебор возможных вариантов. Если вы не хотите знать,
 как именно были получены внешние данные, используйте переменную $_REQUEST, которая состоит из
 данных GET и POST запросов, а также данных COOKIE. Также, информацию об этом
 можно найти в разделе внешние данные в PHP.</p>
<p><a name=AEN6301></a><b>Пример 15-16.
   Обнаружение попытки подмены переменных</b></p>

<div class="cdata">&lt;?php<br>
     if (isset($_COOKIE['MAGIC_COOKIE'])) {<br>
     <br>
     &nbsp; &nbsp; // MAGIC_COOKIE получена из достоверного источника.<br>
     &nbsp; &nbsp; // Для
     полной уверенности необходимо проверить ее значение.<br>
     <br>
     } elseif (isset($_GET['MAGIC_COOKIE'])
     || isset($_POST['MAGIC_COOKIE'])) {<br>
     <br>
     &nbsp; &nbsp;mail(&quot;admin@example.com&quot;, &quot;Обнаружена
     попытка взлома&quot;, $_SERVER['REMOTE_ADDR']);<br>
     &nbsp; &nbsp;echo &quot;Обнаружено нарушение безопасности,
     администратор уведомлен.&quot;;<br>
     &nbsp; &nbsp;exit;<br>
     <br>
     } else {<br>
     <br>
     &nbsp; &nbsp;//
     MAGIC_COOKIE в данных запроса не присутствует<br>
     }<br>
     ?&gt;</div>
   
   </td>
  </tr>
 </table>
 <p>Следует понимать, что установка register_globals в off не
 сделает ваш код безопасным. Каждую полученную от пользователя переменную
 следует проверять на соответствие ожидаемому значению. Всегда проверяйте ввод
 пользователя и инициализируйте все используемые переменные. Для проверки на
 наличие неинициализированных переменных можно включить в опцию <b>error_reporting()</b>
 отображение ошибок категории <b>E_NOTICE</b>.</p>
 <p><b>Суперглобальные переменные: замечание о доступности: </b>Начиная с PHP 4.1.0, стали доступными суперглобальные
 массивы, такие как $_GET, $_POST, $_SERVER и т.д. Дополнительную информацию смотрите в разделе
 руководства superglobals</p>
 <p><a name=security.variables></a><b>Данные, введенные пользователем</b></p>
 <p>Наиболее опасные дыры во многих PHP-скриптах возникают не
 столько из-за самого языка, сколько из-за кода, написанного без учета
 соответствующих требований безопасности. Как следствие, вы всегда должны
 выделять время на исследование разрабатываемого участка кода, чтобы оценить
 потенциальную угрозу от ввода переменной с нестандартным значением.</p>
<p><a name=AEN6317></a><b>Пример 15-17.
   Потенциально опасное использование переменных</b></p>

<div class="cdata">&lt;?php<br>
     // удалить файлы из домашней директории
     пользователя...<br>
     // а может, еще что нибудь?<br>
     unlink ($evil_var);<br>
     <br>
     // записать в лог-файл выполняемое
     действие... <br>
     // может быть, даже /etc/passwd?<br>
     fputs ($fp, $evil_var);<br>
     <br>
     // выполнение тривиальных действий... или rm
     -rf *?<br>
     system ($evil_var);<br>
     exec ($evil_var);<br>
     <br>
     ?&gt;</div>
   
   </td>
  </tr>
 </table>
 <p>Вы должны тщательно проверять ваш код и быть абсолютно
 уверены в том, что все данные, передаваемые веб-браузером, проверяются
 надлежащим образом. Попробуйте ответить для себя на следующие вопросы:</p>
 <ul type=disc>
  <li>Будет ли данный
      скрипт воздействовать исключительно на предполагаемые данные? </li>
  <li>Правильно ли будут
      обработаны некорректные или нестандартные данные? </li>
  <li>Возможно ли
      использование скрипта не предусмотренным способом? </li>
  <li>Возможно ли его
      использование в сочетании с другими скриптами в негативных целях? </li>
  <li>Будет ли каждая
      транзакция корректно логирована? </li>
 </ul>
 <p>Ответив на эти вопросы во время
 написания скрипта, а не после, вы, возможно, предотвратите последующую
 доработку скрипта в целях повышения его безопасности. Начиная разработку с
 этих вопросов, вы не гарантируете полную безопасность вашей системы, но
 сможете значительно повысить её.</p>
 <p>Вы также можете предусмотреть
 отключение таких конфигурационных опций, как register_globals, magic_quotes и
 некоторых других, которые могут приводить к сомнениям относительно
 происхождения или значения получаемых переменных. Использование при написании
 кода режима error_reporting(E_ALL) может помочь, предупреждая вас об
 использовании переменных до инициализации или проверки (что предотвратит
 работу с данными, отличныи от ожидаемых).</p>
 
 
 <p><a name=security.hiding></a><b>Сокрытие PHP</b></p>
 <p>В общем случае внесение неясности ненамного улучшает
 защищенность системы. Но бывают случаи, когда следует использовать малейшую
 возможность.</p>
 <p>Несколько несложных методик могут помочь вам скрыть PHP,
 что усложняет работу потенциального взломщика, который пытается найти брешь в
 вашей системе. Установив опцию expose_php = off в конфигурационном файле php.ini, вы уменьшите количество
 доступной хакеру информации.</p>
 <p>Еще одна методика заключается в настройке веб-сервера
 таким образом, чтобы он обрабатывал файлы с различными расширениями как
 PHP-скрипты. Это можно указать как в .htaccess файлах, так и конфигурационном файле Apache. В таком
 случае вы сможете использовать при написании кода нестандартные расширения:</p>
<p><a name=AEN6339></a><b>Пример 15-18. Маскировка
   PHP под другие языки программирования</b></p>

<div class="cdata"># Теперь
     PHP-скрипты могут иметь те же расширения, что и другие языки
     программирования</p>
     <p>AddType application/x-httpd-php .asp .py .pl</div>
   
 <p>Или скрыть его совсем:</p>
 <table border=0 cellspacing=0 cellpadding=0 width="100%">
  <tr>
   <td>
   <p><a name=AEN6342></a><b>Пример 15-19.
   Использование неизвестных расширений для PHP-скриптов</b></p>
<div class="cdata"># Теперь
     PHP-скрипты могут иметь неизвестные типы файлов</p>
     <p>AddType application/x-httpd-php .bop .foo .133t</div>
   
 <p>Также можно спрятать его под видом HTML-кода, что приведет
 к потере производительности, так как все HTML файлы будут обрабатываться как
 PHP-код:</p>
   <p><a name=AEN6345></a><b>Пример 15-20.
   Маскировка PHP-кода под html-файлы</b></p>
<div class="cdata"># Теперь
     PHP-скртпы могут выглядеть как обыкновенный HTML</p>
     <p>AddType application/x-httpd-php .htm .html</div>
 <p>Чтобы достичь желаемого эффекта, вы должны переименовать
 все ваши скрипты в соответствии с выбранным вами расширением. Описанное в этом
 разделе документации повышение безопасности через сокрытие PHP имеет мало
 недостатков при небольших затратах.</p>
 <h1><a name=security.current></a>Необходимость обновлений</h1>
 <p>PHP, как и любая другая система, все время тщательно проверяется и улучшается.
 Каждая новая версия содержит множество как существенных, так и мелких новшеств
 и доработок, которые, в том числе, касаются повышения безопасности, расширения
 конфигурационных возможностей, а так же стабильности вашей системы.</p>
 <p>Как и в других языках программирования, рекомендуется регулярно обновлять
 PHP и быть в курсе изменений, сделанных в последних версиях.</p>
 </p>

</div>

<!-- AddThis Fav -->
<div class="addthis_toolbox addthis_default_style addthis_32x32_style noprint"><noindex>
 <a rel="nofollow" class="addthis_button_vk" title="ВКонтакте"></a>
 <a rel="nofollow" class="addthis_button_facebook"></a>
 <a rel="nofollow" class="addthis_button_twitter"></a>
 <a rel="nofollow" class="addthis_button_livejournal"></a>
 <a rel="nofollow" class="addthis_button_google"></a>
 <a rel="nofollow" class="addthis_button_linkedin"></a>
 <a rel="nofollow" class="addthis_button_myspace"></a>
 <a rel="nofollow" class="addthis_button_mymailru" title="Мой Мир @Mail.ru"></a>
 <span class="addthis_separator">&nbsp;</span>
 <a rel="nofollow" class="addthis_button_email" title="Переслать @ другу"></a>
 <a rel="nofollow" class="addthis_button_print" title="Отправить на печать"></a>
 <a rel="nofollow" class="addthis_button_favorites" title="В закладки браузера"></a>
 <span class="addthis_separator">&nbsp;</span>
 <a rel="nofollow" class="addthis_button_compact"></a></noindex>
 <span class="right"><a href="http://lib.misto.kiev.ua/DONATIONS/" target="_blank">Поддержать сайт</a> на родительском проекте <acronym title="Киевская Городская Библиотека">КГБ</acronym></span>
</div><p class="cb"></p>

<div align="center"><a name="apicomments"></a><iframe src='/api/comments.php?page=http://php5.kiev.ua/phpbook.html' width='95%' height='400'
 name='apicomment' frameborder='0' scrolling='auto' class='comment' onload='cmsIframeMaximize(this,window.frames.apicomment);'>Фрейм с коментариями</iframe></div>

<div align="center" class="advert"><noindex>
<div id="rotaban_202656" class="rbrocks rotaban_faf76e5d37374477bf8cff1a27546c78"></div></noindex>
<div id="saperu"></div>


</div>

<div id="b-footer"><noindex>
 <div id="counters"><!-- I.UA counter --><a href="http://www.i.ua/" target="_blank" onclick="this.href='http://i.ua/r.php?27463';" title="Rated by I.UA" rel=nofollow>
<script type="text/javascript" language="javascript"><!--
iS='<img src="http://r.i.ua/s?u27463&p63&n'+Math.random();
iD=document;iD.cookie="iua=1";if(iD.cookie)iS+='&c1';
iS+='&d'+(screen.colorDepth?screen.colorDepth:screen.pixelDepth)
+"&w"+screen.width+'&h'+screen.height
iT=iD.referrer.slice(7);iH=window.location.href.slice(7);
((iI=iT.indexOf('/'))!=-1)?(iT=iT.substring(0,iI)):(iI=iT.length);
if(iT!=iH.substring(0,iI))iS+='&f'+escape(iD.referrer.slice(7))
iS+='&r'+escape(iH);
iD.write(iS+'" border="0" width="88" height="31" />');
//--></script></a><!-- End of I.UA counter --></div><noindex>

 <span class="vcard"><p>&copy;2011 <a href="http://lib.misto.kiev.ua" target="_blank" class="org">КГБ: Киевская городская библиотека</a>.
 All Rights Reserved - <span class="category">Справочники</span>
 <a class="url" rel="me" href="http://php5.kiev.ua/">php5.kiev.ua</a>.
 <span class="adr"><span class="locality">Киев</span>, <span class="country-name">Украина</span>.</span> <span class="note">Ua-IX</span>.
 <span class="geo hidden">GEO:<span class="latitude">50,433334</span><span class="longitude">30,516666</span></span> </p>
 <p><address>Webmaster <a class="sndemail email" href="mailto:lecha@mambursoft.org.ua?subj=php5">email</a></address> |
 <span class="fn"><b>Рекламная служба</b></span> <span class="tel home mobiletel">+38 050 4468872</span>
 <span class="workhours hidden">9:00 - 21:00</span> |
 <noindex><a target='_blank' rel="nofollow" href="http://lib.tc/gxtJg6" qhref='http://www.sape.ru/r.vRztIcQhLI.php'>Обмен ссылками</a></noindex></p></span>
</div>

<script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#username=mambur"></script>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-3541542-5");
pageTracker._initData();
pageTracker._trackPageview();
</script>

<!--
WARNING: DO NOT SEND MAIL TO THE FOLLOWING EMAIL ADDRESS! YOU WILL
BE BLOCKED INSTANTLY AND PERMANENTLY!
<a href="mailto:aaaatrap-4dc0f9956e8a4652@kde.org">Block me</a>
WARNING END
-->

</body>
</html>

