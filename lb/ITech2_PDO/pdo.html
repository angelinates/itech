<!DOCTYPE html>
<html>
<head>
	<title>Лабораторная работа №1. Пояснения про PDO</title>
	<meta charset="utf-8">
	<meta name="description " content="Версия 2019.03.06. Методические указания для выполнения лабораторной работы по курсу ИТех2 для потока КИ. Пояснения про PDO.">
	<link rel="stylesheet" type="text/css" href="styles.css">
	<style>
	  @media screen and (max-width: 1600px) {
		img {width: 70%}
	  }
	  @media screen and (max-width: 1280px) {
		img {width: 60%}
	  }
	  @media screen and (max-width: 980px) {
		img {width: 70%}
	  }
	  @media screen and (max-width: 620px) {
		img {width: 80%}
	  }
	</style>
</head>

<body>
	<div id="container">
		<h1 id="start">Унифицированный интерфейс PDO</h1>
		<div class="chapter">
			<h3 id="theme_1">1. Общая информация</h3>
			<p>Расширение PDO (объекты данных PHP) определяет простой и согласованный интерфейс для доступа к базам данных в PHP. Каждый драйвер базы данных, в котором реализован этот интерфейс, может представить специфичный для базы данных функционал в виде стандартных функций расширения (рисунок 1.1). PDO не зря расшифровывается как РНР Data Object - так как взаимодействие с базами данных осуществляется посредством объектов.</p>
			<figure class="pic_w_caption">
				<img src="images/2.1_bgless.png">
				<figcaption>Рисунок 1.1 – Схема реализации интерфейса для доступа к базам данных в PHP</figcaption>
			</figure>
			<p>К основным задачам PDO относятся следующие:
				<ul>
					<li>обеспечение стандартизированного API для реализации основных возможностей различных реляционных СУБД;</li>
					<li>обеспечение переносимости приложений между различными СУБД за счет абстракции средств доступа к СУБД. PDO не абстрагирует саму базу данных, не переписывает SQL-запросы и не эмулирует отсутствующий в СУБД функционал, но упрощает переход с одной СУБД на другую;</li>
					<li>расширяемость, путем создания новых драйверов для работы с СУБД в РНР.</li>
				</ul>
			</p>
			<p>Поддерживает следующие драйверы БД (просмотреть список драйвер возможно с помощью метода <span class="code">PDO::getAvailableDrivers()</span>):</p>
			<pre>
		PDO_CUBRID Cubrid
		PDO_DBLIB FreeTDS / Microsoft SQL Server / Sybase
		PDO_FIREBIRD Firebird/Interbase 6
		PDO_IBM IBM DB2
		PDO_INFORMIX IBM Informix Dynamic Server
		PDO_MYSQL MySQL 3.x/4.x/5.x
		PDO_OCI Oracle Call Interface
		PDO_ODBC ODBC v3 (IBM DB2, unixODBC и win32 ODBC)
		PDO_PGSQL PostgreSQL
		PDO_SQLITE SQLite 3 и SQLite 2
		PDO_SQLSRV Microsoft SQL Server / SQL Azure
		PDO_4D 4D
			</pre>
		</div>
		
		<br>
		
		
		<br>
		
		<br>
		<p class="text_indent">
			Далее будут рассмотрены основные принципы работы с классами PDO и PDOStatement.
		</p>
		<p class="text_indent"><b>Соединение и закрытие соединения с базой данных.</b></p>
		<p class="text_indent">
			Соединение с базой данных устанавливается тогда, когда создаётся экземпляр класса PDO (например, объект <span class="code">$pdh</span>), причем не имеет значения, какой драйвер используется. Его конструктор принимает параметры для того, чтобы определить источник базы данных (известный как DSN), и необязательные параметры для указания имени пользователя (<span class="code">username</span>), пароля (<span class="code">password</span>) и массива опций подключения (<span class="code">driver_options</span>).
		</p>
		<p class="text_indent">
			Формат записи конструктора следующий:
			<br><span class="code">PDO::_construct ( string dsn [, string username [, string password [, array driver_options]]] )</span>
		</p>
		<p class="text_indent">
			DSN требуется в качестве первого параметра конструктора при создании нового объекта класса PDO, оно составлено из следующих элементов:
			<ul>
				<li><span class="code">DSN prefix</span> - приставка DSN, драйвер СУБД, например, "<span class="code">mysql</span>" или "<span class="code">mysqli</span>";</li>
				<li><span class="code">host</span> - имя хоста, на котором находится сервер базы данных (если он нужен);</li>
				<li><span class="code">port</span> - номер порта для сервера базы данных;</li>
				<li><span class="code">dbname</span> - имя базы данных, к которой открывается подключение;</li>
				<li><span class="code">unix_socket</span> - сокет Unix MySQL (не должен использоваться с хостом или портом);</li>
				<li><span class="code">charset</span> – кодировка (до PHP 5.3.6 этот элемент игнорирован).</li>
			</ul>
		</p>
		<p class="text_indent">
			Варианты строки подключения драйвера <u>PDO_MYSQL:</u>
		<pre>
mysql:host=localhost;dbname=testdb
mysql:host=localhost;port=3307;dbname=testdb
mysql:unix_socket=/tmp/mysql.sock;dbname=testdb
		</pre>
		</p>
		<p class="text_indent">
			Вариант строки подключения драйвера <u>PDO_SQLITE</u>:
		<span class="code">sqlite:/path/to/database.db</span>
		<br>Для создания базы данных в памяти, используйте: <span class="code">sqlite::memory:</span>
		<br>Вариант строки подключения драйвера для sqlite (version 2): <span class="code">sqlite2:/path/to/database.db</span>
		<br>Пример создания объекта PDO и подключения к СУБД MySQL.
		<pre>
&lt;?php
    $dsn = 'mysql:host=localhost;dbname=testdb'; $username = 'имя пользователя';
    $password = 'пароль';
    $options = array( PDO:: MYSQL_ATTR_INIT_COMMAND =&gt; 'SET NAMES utf8');
    $dbh = new PDO ($dsn, $username, $password, $options);
?&gt;
		</pre>
		</p>
		<p class="text_indent">
			В результате успешного подключения к базе данных возвращается экземпляр класса PDO. Соединение остается активным в течение жизни этого объекта PDO. Для того чтобы завершить соединение, нужно уничтожить объект, гарантируя, что все остальные ссылки на него будут удалены – это можно осуществить путем присвоения NULL переменной, содержащей объект. Если вы не сделать этого явно, PHP автоматически закрывает соединение после завершения скрипта.
		<pre>
&lt;?php
    $dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
    // используем соединения здесь, после чего закрываем его
    $dbh = null;
?&gt;
		</pre>
		</p>
		
		<p class="text_indent">
			<u>Опции подключения можно устанавливать тремя способами:</u>
		</p>
		<p class="text_indent">
			– При соединении с базой данных наиболее часто используемые опции соединения – это такие как <span class="code">PDO::ATTR_PERSISTENT</span> для создания постоянных подключений к серверам баз данных, которые не закрываются в конце сценария, но кэшируются и их можно использовать повторно, когда другой сценарий запрашивает соединение с использованием тех же учетных данных, и <span class="code">PDO::MYSQL_ATTR_INIT_COMMAND</span>, позволяющая частично реализовать указание кодировки при создании объекта PDO:
		<pre>
&lt;?php
	$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass, array(
		PDO::ATTR_PERSISTENT =&gt; true, PDO::MYSQL_ATTR_INIT_COMMAND =&gt; 'SET NAMES \'UTF8\''
		));
?&gt;
		</pre>
		</p>
		<p class="text_indent">
			– При использовании метода <span class="code">PDOObj-&gt;setAttribute()</span> для присваивания атрибута PDO объекту, метода <br><span class="code">PDOStatement-&gt;setAttribute()</span> для установки опций конкретного драйвера:
		<pre>
&lt;?php
	$dbh = new PDO($connection_string);
	$dbh-&gt;setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE, PDO::FETCH_OBJ);
	$dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
?&gt;
		</pre>
		</p>
		<p class="text_indent">
			– При использовании некоторых функции выборки данных, например, у метода <span class="code">PDO::prepare()</span> в качестве второго параметра учитываются опции драйвера (одна или более пар ключ=&gt;значение для установки значений атрибутов объекта PDOStatement):
		<pre>
&lt;?php
	$sth = $dbh-&gt;prepare($sql, array(PDO::ATTR_CURSOR =&gt; PDO::CURSOR_FWDONLY));
?&gt;
		</pre>
		</p>
		<p class="text_indent">
			Если требуется написать переносимый код, не зависящий от типа подключаемой базы данных рекомендуется не использовать специфичные для конкретного драйвера константы и конструкции запросов.
		</p>
		<p class="text_indent">
			Блок <span class="code">try/catch</span> рекомендуется использовать для оборачивания в него всех PDO-операций и использования <u>механизм исключений PDOException</u> для вывода ошибок:
		<pre>
&lt;?php
	try {
		$dbh = new PDO('mysql:host=localhost;dbname=test', $user, $pass);
		foreach($dbh-&gt;query('SELECT * from FOO') as $row) {
			print_r($row);
		}
		$dbh = null;
	}
	catch (PDOException $e) {
		print "Error!: " . $e-&gt;getMessage() . "&lt;br/&gt;";
		die();
	}
?&gt;
		</pre>
		</p>
		
		<br>
		<p class="text_indent"><b>Выполнение запросов к базе данных.</b></p>
		<p class="text_indent">
			Метод <span class="code"><b>query()</b></span> выполняет SQL запрос <span class="code">statement</span> без подготовки и возвращает результирующий набор в виде объекта <span class="code">PDOStatement</span> или <span class="code">FALSE</span> при ошибке.
		<pre>
PDOStatement PDO::query ( string $statement )
		</pre>
		</p>
		<p class="text_indent">
			Особенностью <span class="code"><b>query()</b></span> является то, что после выполнения SELECT запроса можно сразу работать с результирующим набором посредством курсора.
		</p>
		<p class="text_indent">
			Метод <span class="code"><b>query()</b></span> требует, чтобы вы должным образом экранировали все данных, чтобы избежать SQL инъекций и других вопросов. Поэтому его следует использовать в запросах без включения внешних данных.
		<pre>
&lt;?php
	$conn-&gt;query("SET CHARACTER SET utf8");
	function getFruit($conn) {
		$sql = 'SELECT name, color, calories FROM fruit ORDER BY name';
		foreach ($conn-&gt;query($sql) as $row) {
			print $row['name'] . "\t";
			print $row['color'] . "\t";
			print $row['calories'] . "\n";
		}
	}
?&gt;
		</pre>
		</p>
		
		<br>
		<p class="text_indent"><b>Быстрое получение данных из запроса.</b></p>
		<p class="text_indent">
			PDO предлагает некоторые дополнительные пути для получения информации из запроса без использования <span class="code">fetch*()</span> функций и цикла по результату.
		</p>
		<p class="text_indent">
			Метод <span class="code"><b>PDOStatement::rowCount</b></span> возвращает количество строк, которые были затронуты в ходе выполнения последнего запроса <span class="code">DELETE</span>, <span class="code">INSERT</span> или <span class="code">UPDATE</span>, запущенного соответствующим объектом <span class="code">PDOStatement</span>.
		<pre>
$stmt = $db-&gt;query('SELECT * FROM table');
$row_count = $stmt-&gt;rowCount();
		</pre>
		</p>
		<p class="text_indent">
			В другом случае используйте метод <span class="code"><b>PDOStatement::columnCount()</b></span>, чтобы узнать количество столбцов в результирующем наборе, который представляет объект <span class="code">PDOStatement</span>.
		</p>
		<p class="text_indent">
			Если объект <span class="code">PDOStatement</span> был возвращен из метода <span class="code">query()</span>, число столбцов можно узнать сразу же. Если объект <span class="code">PDOStatement</span> был возвращен из метода <span class="code">PDO::prepare(), точное количество столбцов можно будет узнать только после запуска метода <span class="code">PDOStatement::execute()</span>.
		<pre>
&lt;?php 
	sth = $dbh-&gt;prepare("SELECT name, colour FROM fruit");
	
	/* Подсчет количества столбцов в (несуществующем) результирующем наборе */
	$colcount = $sth-&gt;columnCount();
	
	print("Перед вызовом execute(), в результирующем наборе $colcount столбцов (должно быть 0)\n");
	$sth-&gt;execute();
	
	/* Подсчет количества столбцов в результирующем наборе */
	$colcount = $sth-&gt;columnCount();
	
	print("После вызова execute(), в результирующем наборе $colcount столбцов (должно быть 2)\n");
?&gt;
		</pre>
		<p class="text_indent">
			Метод <span class="code"><b>PDO::lastInsertId</b></span> возвращает ID последней вставленной строки либо последнее значение, которое выдал объект последовательности.
		<pre>
$db-?&gt;query("INSERT INTO users SET name='Vasya',address='Here',email='vasya@test.com'");
$insertId=$db-?&gt;lastInsertId();
		</pre>
		</p>
		<p class="text_indent">
			Если вы не используете prepared statements, тогда необходимо для безопасного использования SQL запросов использовать метод <span class="code"><b>quote()</b></span>, который возвращает строку, в которой проставлены кавычки в строковых данных (если требуется) и экранированы специальные символы внутри строки подходящим для драйвера способом.
		<pre>
&lt;?php
	$conn = new PDO('sqlite:/home/lynn/music.sql3');
	
	/* небезопасная строка */
	$string = 'Naughty \' string';
	
	print "Неэкранированная строка: $string\n";
	print "Экранированная строка:" . $conn-&gt;quote($string) . "\n";
	
	//Запрос с условием и экранированием
	$conn-&lt;query('SELECT * FROM table WHERE id = ' . $conn-&lt;quote($id));
?&gt;


Вывод результата:
Неэкранированная строка: Naughty ' string
Экранированная строка: 'Naughty '' string'
		</pre>
		</p>
		<p class="text_indent">
			Метод <span class="code"><b>exec()</b></span> запускает SQL запрос statement на выполнение и используется для операций, которые не возвращают никаких данных, кроме количества затронутых ими записей. Данные внутри запроса должны быть правильно экранированы. Используется, например, при удалении данных из базы данных.
		<pre>
&lt;?php
	$dbh = new PDO('odbc:sample', 'db2inst1', 'ibmdb2');
	
	/* Удаляем все записи из таблицы FRUIT */
	$count = $dbh-&gt;exec("DELETE FROM fruit WHERE colour = 'red'");
	
	/* Получим количество удаленных записей */
	print("Удалено $count строк.\n");
?&gt;
		</pre>
		</p>
		
		<br>
		<p class="text_indent"><b>Выполнение подготовленных запросов.</b></p>
		<p class="text_indent">
			Подготовленные выражения (англ. prepared statments) позволяют определить выражение один раз, а затем многократно его выполнять с разными параметрами, что повышает скорость выполнения и экономит траффик между приложением и базой данных. Также они позволяют отделить переменные от запроса, что позволяет сделать код безопаснее. С этой целью применяется метод prepare(), который подготавливает запрос statement к выполнению и возвращает ассоциированный с этим запросом объект PDOStatement.
		</p>
		<p class="text_indent">
			Обратите внимание, что после создания объектом PDO подготовленного выражения в классе PDOStatement, используется только он, соответственно, в нем есть свои функции errorCode, errorInfo, а также результат выполнения запросов, также сразу же хранится в нем.
		</p>
		<p class="text_indent">
			<span class="code">PDOStatement PDO::prepare ( string $statement [, array $driver_options = array() ] )</span>
			<br>Запрос может содержать именованные (<span class="code">:name</span>) или неименованные (?) псевдопеременные, которые будут заменены реальными значениями во время запуска запроса на выполнение. Если вы определили переменные знаком вопроса, то в функцию execute передайте массив значений, в той, последовательности, в которой стоят переменные. Использовать одновременно и именованные, и неименованные псевдопеременные в одном запросе нельзя, необходимо выбрать что-то одно.
		<pre>
&lt;?php
	/* Выполнение SQL запроса с передачей ему массива именованных параметров */
	$sql = 'SELECT name, colour, calories
				FROM fruit
				WHERE calories &lt; :calories AND colour = :colour';
	
	/*Предписание создать объект PDOStatement с последовательным курсором*/
	$sth = $dbh-&gt;prepare($sql, array(PDO::ATTR_CURSOR =&gt; PDO::CURSOR_FWDONLY));
	$sth-&gt;execute(array(':calories' =&gt; 150, ':colour' =&gt; 'red'));
	$red = $sth-&gt;fetchAll();
	
	/* Выполнение запроса с передачей ему массива неименованных параметров */
	$sth = $dbh-&gt;prepare('SELECT name, colour, calories
							FROM fruit
							WHERE calories &lt; ? AND colour = ?');
	$sth-&gt;execute(array(150, 'red')); $red = $sth-&gt;fetchAll();
?&gt;
		</pre>
		</p>
		<p class="text_indent">
			В предыдущем примере пропущена функция <span class="code"><b>bind*()</b></span>, задающая значение именованной или неименованной псевдопеременной в подготовленном SQL запросе.
		</p>
		<p class="text_indent">
			Существует три вида функции типа <b>bind*()</b>:
		<ul>
			<li><b>bindValue()</b> задает значение именованной или неименованной псевдопеременной в подготовленном SQL запросе</li>
			<pre>
bool PDOStatement::bindValue ( mixed $parameter , mixed $value [, int $data_type = PDO::PARAM_STR ] )

&lt;?php
	/* Выполнение подготовленного запроса с именованными псевдопеременными */
	$sth = $dbh-&gt;prepare('SELECT name, colour, calories
				FROM fruit
				WHERE calories &lt; :calories');
	$sth-&gt;bindValue(':calories', 150, PDO::PARAM_INT);
	$sth-&gt;execute();
	
	/* Выполнение подготовленного запроса с неименованными псевдопеременными (?) */
	$sth = $dbh-&gt;prepare('SELECT name, colour, calories
				FROM fruit
				WHERE calories &lt; ? AND colour = ?');
	$sth-&gt;bindValue(1, 150, PDO::PARAM_INT);
	$sth-&gt;bindValue(2, ‘red’, PDO::PARAM_STR);
	$sth-&gt;execute();
?&gt;
			</pre>
			
			<li><b>bindParam()</b> привязывает именованный или неименованный параметр подготавливаемого SQL запроса с настоящей переменной, при изменении настоящей переменной, не нужно больше вызывать никаких дополнительных функций, можно сразу <span class="code">execute()</span>.В отличие от <span class="code">bindValue()</span>, переменная привязывается по ссылке, и ее значение будет вычисляться во время вызова <span class="code">execute()</span></li>
			<pre>
bool PDOStatement::bindParam ( mixed $parameter , mixed &$variable [, int $data_type = PDO::PARAM_STR [, int $length [, mixed $driver_options ]]] )
&lt;?php
	/* Выполнение запроса с привязкой PHP переменных */
	$calories = 150;
	$colour = 'red';
	
	/* Выполнение подготовленного запроса с именованными псевдопеременными */
	$sth = $dbh-&gt;prepare('SELECT name, colour, calories
				FROM fruit
				WHERE calories &lt; :calories');
	$sth-&gt;bindParam(':calories', $calories, PDO::PARAM_INT);
	$sth-&gt;execute();
	/*Выполнение подготовленного запроса с неименованными псевдопеременными (?)*/
	sth = $dbh-&gt;prepare('SELECT name, colour, calories 
				FROM fruit
				WHERE calories &lt; ? AND colour = ?');
	$sth-&gt;bindParam(1, $calories, PDO::PARAM_INT);
	$sth-&gt;execute();
?&gt;
			</pre>
			
			<li><b>bindColumn()</b> привязывает переменную к заданному столбцу в результирующем наборе запроса. Каждый вызов <u>PDOStatement::fetch()</u> или <u>PDOStatement::fetchAll()</u> будет обновлять все переменные, задавать им значения столбцов, с которыми они связаны</li>
			<pre>
bool PDOStatement::bindColumn ( mixed $column , mixed &$param [, int $type [, int $maxlen [, mixed $driverdata ]]] )

&lt;?php
	$sql = 'SELECT name, colour, calories FROM fruit';
	$stmt = $dbh-&gt;prepare($sql);
	
	/* Связывание по номеру столбца */
	$stmt-&gt;bindColumn(1, $name);
	$stmt-&gt;bindColumn(2, $colour);
	/* Связывание по имени столбца */
	$stmt-&gt;bindColumn('calories', $cals);
	$stmt-&gt;execute();
?&gt;
			</pre>
		</ul>
		</p>
		<p class="text_indent">
			Первым параметром <i>parameter</i> каждой из функций является идентификатор параметра запроса. Для подготавливаемых запросов с именованными параметрами это будет имя в виде <span class="code">:name</span>. Если используются неименованные параметры (знаки вопроса ?) это будет позиция псевдопеременной в запросе (начиная с 1).
		</p>
		<p class="text_indent">
			Третьим параметром каждой из функций <i>data_type</i> является явно заданный тип данных параметра (одна из констант <span class="code">PDO::PARAM_*</span>):
		<pre>
&lt;?php $sth3-&gt;bindParam(‘:id’,$id, PDO::PARAM_INT);
      $sth3-&gt;bindParam(‘:id’,$id, PDO::PARAM_STR); ?&gt;
		</pre>
		</p>
		<p class="text_indent">
			Третьим методом в цепочке при выполнении подготовленных выражений является метод <b>PDOStatement::execute()</b>, который запускает подготовленный запрос. Метод <span class="code">execute</span> также прекрасно работает когда вы повторяете запрос несколько раз.
		</p>
		<p class="text_indent">
			Если в SQL-выражении много параметров, то назначать каждому по переменной весьма неудобно. В таких случаях можно хранить данные в массиве и передавать его:
		<pre>
&lt;?php // набор данных, которые мы будем вставлять
	$data = array('Cathy', '9 Dark and Twisty Road', 'Cardiff');
	$STH = $DBH-&gt;prepare("INSERT INTO folks (name, addr, city) values (?, ?, ?)");
	$STH-&gt;execute($data);
?&gt;
		</pre>
		</p>
		<p class="text_indent">
			Элемент <span class="code">$data[0]</span> вставится на место первого placeholder’а, элемент <span class="code">$data[1]</span> – на место второго, и т.д.
		</p>
		
		<br>
		<p class="text_indent"><b>Выборка строк из запроса.</b></p>
		<p class="text_indent">
			Для извлечения <u>следующей строки</u> из результирующего набора используйте метод <b>fetch()</b>:
		<pre>
mixed PDOStatement::fetch ([ int $fetch_style [, int $cursor_orientation = PDO::FETCH_ORI_NEXT [, int $cursor_offset = 0 ]]] )
		</pre>
		</p>
		<p class="text_indent">
			Для извлечения всех строк из результирующего набор можно применить цикл по результатам выборки:
		<pre>
&lt;?php
	// Выбираем каждую строку на каждой итерации пока не выберем все строки
	while ($row = $res-&gt;fetch(PDO::FETCH_NUM)) {
		echo $id = $row[0];
	}
?&gt;
		</pre>
		</p>
		<p class="text_indent">
			В случае успешного выполнения функции возвращаемое значение зависит от режима выборки. Например, для запроса указанного в примере ниже можно задать различные режимы.
		<pre>
&lt;?php
	$sth = $dbh-&gt;prepare("SELECT name, colour FROM fruit");
	$sth-&gt;execute();
?&gt;
		</pre>
		</p>
		<p class="text_indent">
			Параметр <i>fetch_style определяет</i>, в каком виде PDO вернет эту строку <span class="code">(одна из констант PDO::FETCH_*)</span>:
		<ul>
			<li><span class="code">PDO::FETCH_ASSOC</span> возвращает массив с названиями столбцов в виде ключей</li>
			<pre>
&lt;?php print_r($sth-&gt;fetch(PDO::FETCH_ASSOC));?&gt;

Вывод результата:
Array ( [ID_Authors] =&gt; 1 [name] =&gt; Косминский Е.А. )
Доступ к данным:
&lt;?php while($row = $sth-&gt;fetch(PDO::FETCH_ASSOC))
{ echo "&lt;p&gt;" . $row[' ID_Authors '] . "&nbsp;" . $row[' name '] . "&lt;/p&gt;";}?&gt;
			</pre>
			
			<li><span class="code">PDO::FETCH_NUM</span> возвращает массив, с ключами в виде порядковых номеров столбцов (начиная с 0);</li>
			<pre>
&lt;?php print_r($result-&gt;fetch(PDO::FETCH_NUM));?&gt;
Вывод результата:
Array ( [0] =&gt; 1 [1] =&gt; Косминский Е.А. )
Доступ к данным:
&lt;?php while($row ($result-&gt;fetch(PDO::FETCH_NUM))
{ echo "&lt;p&gt;" . $row[0] . "&nbsp;" . $row[1] . "&lt;/p&gt;";}?&gt;
			</pre>
			
			<li><span class="code">PDO::FETCH_BOTH</span> (по умолчанию) возвращает массив, индексированный именами столбцов результирующего набора, а также их номерами (начиная с 0);</li>
			<pre>
&lt;?php print_r($sth-&gt;fetch(PDO::FETCH_BOTH)); ?&gt;
Вывод результата:
Array ( [ID_Authors] =&gt; 1 [0] =&gt; 1 [name] =&gt; Косминский Е.А. [1] =&gt; Косминский Е.А. )
Доступ к данным:
&lt;?php while($row ($result-&gt;fetch(PDO::FETCH_ BOTH))
{ echo "&lt;p&gt;" . $row[0] . "&nbsp;" . $row['name'] . "&lt;/p&gt;";}?&gt;
			</pre>
			
			<li><span class="code">PDO::FETCH_OBJ</span> создает анонимный объект со свойствами, соответствующими именам столбцов результирующего набора.</li>
			<pre>
&lt;?php print_r($result-&gt;fetch(PDO::FETCH_OBJ)); ?&gt;
Вывод результата:
stdClass Object ( [ID_Authors] =&gt; 1 [name] =&gt; Косминский Е.А. )
Доступ к данным:
while ($row = $result-&gt;fetch(PDO::FETCH_OBJ))
{ echo $row-&gt;ID_Authors;
  echo $row-&gt;name;}
			</pre>
			
			<li><span class="code">PDO::FETCH_LAZY</span> комбинирует <span class="code">PDO::FETCH_BOTH</span> и <span class="code">PDO::FETCH_OBJ</span>, создавая новый объект со свойствами, соответствующими именам столбцов результирующего набора</li>
			<pre>
&lt;?php print_r($result-&gt;fetch(PDO::FETCH_LAZY)); ?&gt;
Вывод результата:
PDORow Object ( [queryString] =&gt; select ID_Authors, name from Authors order by ID_Authors [ID_Authors] =&gt; 1 [name] =&gt; Косминский Е.А. )
Доступ к данным:
$number=0;
while ($row = $result-&gt;fetch(PDO::FETCH_LAZY))
{ echo $row-&gt;$number; echo "&lt;br&gt;";
  echo $row-&gt;name; echo "&lt;br&gt;";}
			</pre>
			
			<li><span class="code">PDO::FETCH_BOUND</span>: возвращает <span class="code">TRUE</span> и присваивает значения столбцов результирующего набора переменным PHP, которые были привязаны к этим столбцам методом <span class="code">PDOStatement::bindColumn()</span></li>
			
			<li><span class="code">PDO::FETCH_CLASS</span> создает и возвращает объект запрошенного класса, присваивая значения столбцов результирующего набора именованным свойствам класса. Если <i>fetch_style</i> включает в себя атрибут <span class="code">PDO::FETCH_CLASSTYPE</span> (например, <span class="code">PDO::FETCH_CLASS</span> | <span class="code">PDO::FETCH_CLASSTYPE</span>), то имя класса, от которого нужно создать объект, будет взято из первого столбца.</li>
			
			<li><span class="code">PDO::FETCH_INTO</span> обновляет существующий объект запрошенного класса, присваивая значения столбцов результирующего набора именованным свойствам объекта</li>
		</ul>
		</p>
		<p class="text_indent">
			Значением параметра <i>cursor_orientation</i> должна быть одна из констант <span class="code">PDO::FETCH_ORI_*</span>, по умолчанию <span class="code">PDO::FETCH_ORI_NEXT</span>, предписывающая выбрать следующую строку из результирующего набора.
		</p>
		<p class="text_indent">
			Для объектов PDOStatement, представляющих прокручиваемый курсор, параметр <span class="code">cursor_orientation</span> которых принимает значение <span class="code">PDO::FETCH_ORI_REL</span>, эта величина <i>offset</i> указывает, какая строка относительно текущего положения курсора будет извлечена функцией <span class="code">PDOStatement::fetch()</span>.
		</p>
		<p class="text_indent">
			Для возврата массива, содержащего все строки результирующего набора используйте метод <b>fetchAll()</b>:
		<pre>
array PDOStatement::fetchAll ([ int $fetch_style [, mixed $fetch_argument [, array $ctor_args = array() ]]] )
		</pre>
		</p>
		<p class="text_indent">
			Массив представляет каждую строку либо в виде массива значений одного столбца, либо в виде объекта, имена свойств которого совпадают с именами столбцов.
		<pre>
&lt;?php
	$sth = $dbh-&gt;prepare("select ID_Authors, name from Authors order by ID_Authors");
	$sth-&gt;execute();
	
	/* Извлечение всех оставшихся строк результирующего набора */
	print("Извлечение всех оставшихся строк результирующего набора:\n");
	$result = $sth-&gt;fetchAll();
	print_r($result);
?&gt;

Вывод результата:
Array ( [0] =&gt; Array ( [0] =&gt; 1 [1] =&gt; Косминский Е.А. )
[1] =&gt; Array ( [0] =&gt; 2 [1] =&gt; Бочаров В.В. )
[2] =&gt; Array ( [0] =&gt; 3 [1] =&gt; Уильям Уолкер Аткинсон )
[3] =&gt; Array ( [0] =&gt; 4 [1] =&gt; Лоис Макмастер Буджолд ) )
		</pre>
		</p>
		<p class="text_indent">
			По умолчанию параметр <i>fetch_style</i> принимает значение <span class="code">PDO::ATTR_DEFAULT_FETCH_MODE</span>, которое в свою очередь имеет по умолчанию значение <span class="code">PDO::FETCH_BOTH</span>. Если требуется извлечь только уникальные строки одного столбца, нужно передать побитовое ИЛИ (|) констант <span class="code">PDO::FETCH_COLUMN</span> и <span class="code">PDO::FETCH_UNIQUE</span>.
		</p>
		<p class="text_indent">
			Чтобы получить ассоциативный массив строк сгруппированный по значениям определенного столбца, нужно передать побитовое ИЛИ (|) констант <span class="code">PDO::FETCH_COLUMN</span> и <span class="code">PDO::FETCH_GROUP</span>.
		</p>
		<p class="text_indent">
			Смысл аргумента <i>fetch_argument</i> зависит от значения параметра <span class="code">fetch_style</span>. Например, если это параметр <span class="code">PDO::FETCH_COLUMN</span>, то будет возвращен указанный столбец (индексация столбцов начинается с 0).
		<pre>
&lt;?php
	$sth = $dbh-&gt;prepare("SELECT name, colour FROM fruit");
	$sth-&gt;execute();
	
	/* Извлечение всех значений первого столбца */
	$result = $sth-&gt;fetchAll(PDO::FETCH_COLUMN, 0);
	foreach ($result as $row) {
		echo $name=$row; echo "&lt;br&gt;";
	}
?&gt;
Вывод результата:
Array(3)( [0] =&gt; string(5) =&gt; apple
[1] =&gt; string(4) =&gt; pear
[2] =&gt; string(10) =&gt; watermelon)
		</pre>
		</p>
		<p class="text_indent">
			Для случаев, когда параметру <span class="code">fetch_style</span> присвоено значение <span class="code">PDO::FETCH_CLASS</span> могут быть заданы аргументы конструктора класса <i>ctor_args</i>.
		</p>
		<p class="text_indent">
			Если необходимо возвратить данные одного столбца следующей строки результирующего набора можно воспользоваться функцией <span class="code">fetchColumn()</span>, параметром которой является номер столбца, данные которого необходимо извлечь:
		<pre>
string PDOStatement::fetchColumn ([ int $column_number = 0 ] )
&lt;?php
	$sth = $dbh-&gt;prepare("SELECT name, colour FROM fruit");
	$sth-&gt;execute();
	
	print("Получение значения первого столбца следующей строки:\n");
	$result = $sth-&gt;fetchColumn();
	
	print("Получение значения второго столбца следующей строки:\n");
	$result = $sth-&gt;fetchColumn(1);
?&gt;

Вывод результата:
Получение значения первого столбца следующей строки:
name = lemon
Получение значения второго столбца следующей строки:
colour = red
		</pre>
		</p>
		<p class="text_indent">
			Для того, чтобы извлечь следующую строку и получить ее в виде объекта воспользуйтесь функцией <b>fetchObject()</b>:
		<pre>
mixed PDOStatement::fetchObject ([ string $class_name = "stdClass" [, array $ctor_args ]] )
		</pre>
		</p>
		<p class="text_indent">
			Этот метод является альтернативой вызову <span class="code">PDOStatement::fetch()</span> с параметром <span class="code">PDO::FETCH_CLASS</span> или <span class="code">PDO::FETCH_OBJ</span>. В качестве параметров у этого метода применяется имя класса создаваемого объекта (<i>class_name</i> ), элементы этого массива будут переданы в конструктор класса (<i>ctor_args</i> )
		</p>
		<p class="text_indent">
			Для задания режима выборки по умолчанию для всех вызовов объекта запроса используется метод <b>setFetchMode()</b>, варианты которого представлены ниже:
		<pre>
bool PDOStatement::setFetchMode ( int $mode )
bool PDOStatement::setFetchMode ( int $PDO::FETCH_COLUMN , int $colno )
bool PDOStatement::setFetchMode ( int $PDO::FETCH_CLASS , string $classname , array $ctorargs )
bool PDOStatement::setFetchMode ( int $PDO::FETCH_INTO , object $object )
		</pre>
		</p>
		<p class="text_indent">
			Возвращает <span class="code">1</span> в случае успешной установки режима или <span class="code">FALSE</span> в случае возникновения ошибки.
		<pre>
&lt;?php
	$sql = 'SELECT name, colour, calories FROM fruit';
	try {
		$stmt = $dbh-&gt;query($sql);
		$result = $stmt-&gt;setFetchMode(PDO::FETCH_NUM);
		// цикл while() переберет весь результат запроса.
		while ($row = $stmt-&gt;fetch()) {
			print $row[0] . "\t" . $row[1] . "\t" . $row[2] . "\n";
		}
	}
	catch (PDOException $e) {
		print $e-&gt;getMessage();
	}
?&gt;
		</pre>
		</p>
		<p class="text_indent">
			Метод <span class="code">closeCursor()</span> класса PDOStatement освобождает соединение с сервером, давая возможность запускать другие SQL запросы. Метод оставляет запрос в состоянии готовности к повторному запуску.
		</p>
		
		<br>
		<p class="text_indent"><b>Выполнение транзакций данных.</b></p>
		<p class="text_indent">
			Транзакция – это совокупность запросов базу данных, которые должны быть обязательно выполнены все. Если какой-либо запрос не выполнен или выполнен с ошибкой, то транзакция отменяется и изменений данных в базе не происходит.
		</p>
		<p class="text_indent">
			Это нужно, чтобы гарантировать сохранение целостности данных при нескольких запросах. например при переводе денежных средств со счета на счет.
		</p>
		<p class="text_indent">
			Чтобы выполнить транзакцию в PDO необходимо перейти в режим ручного подтверждения запросов.
		</p>
		<p class="text_indent">
			Кстати говоря, транзакции используются постоянно, но обычно PDO работает в режиме автоподтверждения, потому все транзакции состоят из одного запроса.
		</p>
		<p class="text_indent">
			Инициализация транзакции осуществляется с помощью метода PDO::beginTransaction(), который выключает режим автоматической фиксации транзакции (режим автоподтверждения). После этого выполняем столько запросов к базе данных сколько необходимо сделать в этой транзакции.
		</p>
		<p class="text_indent">
			В то время, как режим автоматической фиксации выключен, изменения, внесенные в базу данных через объект экземпляра PDO, не применяются, пока вы не завершите (фиксируете) транзакцию, вызвав PDO::commit(),возвращая соединение с базой данных в режим автоматической фиксации до тех пор, пока следующий вызов PDO::beginTransaction() не начнет новую транзакцию.
		<pre>
&lt;?php
	/* Начало транзакции, отключение автоматической фиксации */
	$dbh-&gt;beginTransaction();
	
	/* Вставка множества записей по принципу "все или ничего" */
	$sql = 'INSERT INTO fruit (name, colour, calories) VALUES (?, ?, ?)';
	$sth = $dbh-&gt;prepare($sql);
	
	foreach ($fruits as $fruit) {
		$sth-&gt;execute(array( $fruit-&gt;name, $fruit-&gt;colour, $fruit-&gt;calories, ));
	}
	
	/* Фиксация изменений */
	$dbh-&gt;commit();
	
	/* Соединение с базой данных снова в режиме автоматической фиксации */
?&gt;
		</pre>
		</p>
		<p class="text_indent">
			Вызов PDO::rollBack() откатит все изменения в базе данных, сделанные в рамках текущей транзакции, которая была создана методом <u>PDO::beginTransaction()</u>, и вернет соединение к режиму автоматической фиксации. Если активной транзакции нет, будет выброшено исключение <u>PDOException</u>.
		</p>
		<p class="text_indent">
			В следущем примере создается транзакция и выполняются два запроса, которые модифицируют данные в базе, а затем база возвращается к исходному состоянию. В MySQL, тем не менее, выражение <span class="code">DROP TABLE</span> автоматически фиксирует изменения, находящиеся внутри транзакции, поэтому ничего откачено не будет.
		<pre>
&lt;?php
	/* Начинаем транзакцию, выключаем автофиксацию */
	$dbh-&gt;beginTransaction();
	
	/* Изменяем схему базы данных и данные в таблицах */
	$sth = $dbh-&gt;exec("DROP TABLE fruit");
	$sth = $dbh-&gt;exec("UPDATE dessert
				SET name = 'hamburger'");
	
	/* Осознаем свою ошибку и откатываем транзакцию */
	$dbh-&gt;rollBack();
	/* База данных возвращается в режим автофиксации */
?&gt;
		</pre>
		</p>
		<p class="text_indent">
			Для проверки есть ли активные транзакции в настоящее время внутри драйвера используется метод <span class="code">PDO::inTransaction()</span>.
		</p>
	</div>		
	
	<a href="#start">Вернуться к началу</a>
</body>
</html>